// THIS FILE IS AUTOGENERATED DO NOT EDIT BY HAND
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Drawing;
using Mutagen.Bethesda.Skyrim;
using Spriggan.Converters.Base;
using Microsoft.Extensions.DependencyInjection;

public class IAcousticSpaceGetter_Converter : JsonConverter<IAcousticSpaceGetter>
{
  public override IAcousticSpaceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAcousticSpaceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AcousticSpace");
    writer.WritePropertyName("AmbientSound");
    JsonSerializer.Serialize(writer, value.AmbientSound, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EnvironmentType");
    JsonSerializer.Serialize(writer, value.EnvironmentType, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("UseSoundFromRegion");
    JsonSerializer.Serialize(writer, value.UseSoundFromRegion, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class AcousticSpace_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AcousticSpace>
{
  private IAcousticSpaceGetter_Converter _getterConverter;
  public AcousticSpace_Converter(IAcousticSpaceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AcousticSpace value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAcousticSpaceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AcousticSpace Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AcousticSpace();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AmbientSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.AmbientSound, ref reader);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EnvironmentType":
            ConverterHelpers.ReadFormLinkNullable<IReverbParametersGetter>(retval.EnvironmentType, ref reader);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "UseSoundFromRegion":
            ConverterHelpers.ReadFormLinkNullable<IRegionGetter>(retval.UseSoundFromRegion, ref reader);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IActionRecordGetter_Converter : JsonConverter<IActionRecordGetter>
{
  public override IActionRecordGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IActionRecordGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ActionRecord");
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class ActionRecord_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ActionRecord>
{
  private IActionRecordGetter_Converter _getterConverter;
  public ActionRecord_Converter(IActionRecordGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ActionRecord value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IActionRecordGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ActionRecord Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ActionRecord();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Color":
            retval.Color = JsonSerializer.Deserialize<Color?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IActivateParentGetter_Converter : JsonConverter<IActivateParentGetter>
{
  public override IActivateParentGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IActivateParentGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ActivateParent");
    writer.WritePropertyName("Delay");
    JsonSerializer.Serialize(writer, value.Delay, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WriteEndObject();
  }
}
public class ActivateParent_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ActivateParent>
{
  private IActivateParentGetter_Converter _getterConverter;
  public ActivateParent_Converter(IActivateParentGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ActivateParent value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IActivateParentGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ActivateParent Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ActivateParent();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Delay":
            retval.Delay = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<ILinkedReferenceGetter>(retval.Reference, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IActivateParentsGetter_Converter : JsonConverter<IActivateParentsGetter>
{
  public override IActivateParentsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IActivateParentsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ActivateParents");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    if (value.Parents != default)
    {
      writer.WritePropertyName("Parents");
      writer.WriteStartArray();
      foreach (var itm in value.Parents)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Parents");
    }
    writer.WriteEndObject();
  }
}
public class ActivateParents_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ActivateParents>
{
  private IActivateParentsGetter_Converter _getterConverter;
  public ActivateParents_Converter(IActivateParentsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ActivateParents value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IActivateParentsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ActivateParents Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ActivateParents();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents.Flag>(ref reader, options);
            break;
        case "Parents":
            ConverterHelpers.ReadExtendedList<ActivateParent>(retval.Parents, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IActivatorGetter_Converter : JsonConverter<IActivatorGetter>
{
  public override IActivatorGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IActivatorGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Activator");
    writer.WritePropertyName("ActivateTextOverride");
    JsonSerializer.Serialize(writer, value.ActivateTextOverride, options);
    writer.WritePropertyName("ActivationSound");
    JsonSerializer.Serialize(writer, value.ActivationSound, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("InteractionKeyword");
    JsonSerializer.Serialize(writer, value.InteractionKeyword, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("LoopingSound");
    JsonSerializer.Serialize(writer, value.LoopingSound, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MarkerColor");
    JsonSerializer.Serialize(writer, value.MarkerColor, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("WaterType");
    JsonSerializer.Serialize(writer, value.WaterType, options);
    writer.WriteEndObject();
  }
}
public class Activator_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Activator>
{
  private IActivatorGetter_Converter _getterConverter;
  public Activator_Converter(IActivatorGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Activator value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IActivatorGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Activator Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Activator();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateTextOverride":
            retval.ActivateTextOverride = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ActivationSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.ActivationSound, ref reader);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "InteractionKeyword":
            ConverterHelpers.ReadFormLinkNullable<IKeywordGetter>(retval.InteractionKeyword, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "LoopingSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.LoopingSound, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Activator.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MarkerColor":
            retval.MarkerColor = JsonSerializer.Deserialize<Color?>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "WaterType":
            ConverterHelpers.ReadFormLinkNullable<IWaterGetter>(retval.WaterType, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IActorValueInformationGetter_Converter : JsonConverter<IActorValueInformationGetter>
{
  public override IActorValueInformationGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IActorValueInformationGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ActorValueInformation");
    writer.WritePropertyName("Abbreviation");
    JsonSerializer.Serialize(writer, value.Abbreviation, options);
    writer.WritePropertyName("CNAM");
    JsonSerializer.Serialize(writer, value.CNAM, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    if (value.PerkTree != default)
    {
      writer.WritePropertyName("PerkTree");
      writer.WriteStartArray();
      foreach (var itm in value.PerkTree)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("PerkTree");
    }
    writer.WritePropertyName("Skill");
    JsonSerializer.Serialize(writer, value.Skill, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class ActorValueInformation_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ActorValueInformation>
{
  private IActorValueInformationGetter_Converter _getterConverter;
  public ActorValueInformation_Converter(IActorValueInformationGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ActorValueInformation value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IActorValueInformationGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ActorValueInformation Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ActorValueInformation();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Abbreviation":
            retval.Abbreviation = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "CNAM":
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "PerkTree":
            ConverterHelpers.ReadExtendedList<ActorValuePerkNode>(retval.PerkTree, ref reader, options);
            break;
        case "Skill":
            retval.Skill = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValueSkill>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IActorValuePerkNodeGetter_Converter : JsonConverter<IActorValuePerkNodeGetter>
{
  public override IActorValuePerkNodeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IActorValuePerkNodeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ActorValuePerkNode");
    writer.WritePropertyName("AssociatedSkill");
    JsonSerializer.Serialize(writer, value.AssociatedSkill, options);
    if (value.ConnectionLineToIndices != default)
    {
      writer.WritePropertyName("ConnectionLineToIndices");
      writer.WriteStartArray();
      foreach (var itm in value.ConnectionLineToIndices)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ConnectionLineToIndices");
    }
    writer.WritePropertyName("FNAM");
    JsonSerializer.Serialize(writer, value.FNAM, options);
    writer.WritePropertyName("HorizontalPosition");
    JsonSerializer.Serialize(writer, value.HorizontalPosition, options);
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WritePropertyName("Perk");
    JsonSerializer.Serialize(writer, value.Perk, options);
    writer.WritePropertyName("PerkGridX");
    JsonSerializer.Serialize(writer, value.PerkGridX, options);
    writer.WritePropertyName("PerkGridY");
    JsonSerializer.Serialize(writer, value.PerkGridY, options);
    writer.WritePropertyName("VerticalPosition");
    JsonSerializer.Serialize(writer, value.VerticalPosition, options);
    writer.WriteEndObject();
  }
}
public class ActorValuePerkNode_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ActorValuePerkNode>
{
  private IActorValuePerkNodeGetter_Converter _getterConverter;
  public ActorValuePerkNode_Converter(IActorValuePerkNodeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ActorValuePerkNode value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IActorValuePerkNodeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ActorValuePerkNode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ActorValuePerkNode();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AssociatedSkill":
            ConverterHelpers.ReadFormLinkNullable<IActorValueInformationGetter>(retval.AssociatedSkill, ref reader);
            break;
        case "ConnectionLineToIndices":
            ConverterHelpers.ReadExtendedList<UInt32>(retval.ConnectionLineToIndices, ref reader, options);
            break;
        case "FNAM":
            break;
        case "HorizontalPosition":
            retval.HorizontalPosition = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Index":
            retval.Index = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "Perk":
            ConverterHelpers.ReadFormLink<IPerkGetter>(retval.Perk, ref reader);
            break;
        case "PerkGridX":
            retval.PerkGridX = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "PerkGridY":
            retval.PerkGridY = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "VerticalPosition":
            retval.VerticalPosition = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IActorValueSkillGetter_Converter : JsonConverter<IActorValueSkillGetter>
{
  public override IActorValueSkillGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IActorValueSkillGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ActorValueSkill");
    writer.WritePropertyName("ImproveMult");
    JsonSerializer.Serialize(writer, value.ImproveMult, options);
    writer.WritePropertyName("ImproveOffset");
    JsonSerializer.Serialize(writer, value.ImproveOffset, options);
    writer.WritePropertyName("OffsetMult");
    JsonSerializer.Serialize(writer, value.OffsetMult, options);
    writer.WritePropertyName("UseMult");
    JsonSerializer.Serialize(writer, value.UseMult, options);
    writer.WriteEndObject();
  }
}
public class ActorValueSkill_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ActorValueSkill>
{
  private IActorValueSkillGetter_Converter _getterConverter;
  public ActorValueSkill_Converter(IActorValueSkillGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ActorValueSkill value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IActorValueSkillGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ActorValueSkill Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ActorValueSkill();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ImproveMult":
            retval.ImproveMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ImproveOffset":
            retval.ImproveOffset = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "OffsetMult":
            retval.OffsetMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "UseMult":
            retval.UseMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAddonNodeGetter_Converter : JsonConverter<IAddonNodeGetter>
{
  public override IAddonNodeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAddonNodeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AddonNode");
    writer.WritePropertyName("AlwaysLoaded");
    JsonSerializer.Serialize(writer, value.AlwaysLoaded, options);
    writer.WritePropertyName("DNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.DNAMDataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MasterParticleSystemCap");
    JsonSerializer.Serialize(writer, value.MasterParticleSystemCap, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("NodeIndex");
    JsonSerializer.Serialize(writer, value.NodeIndex, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Sound");
    JsonSerializer.Serialize(writer, value.Sound, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class AddonNode_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AddonNode>
{
  private IAddonNodeGetter_Converter _getterConverter;
  public AddonNode_Converter(IAddonNodeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AddonNode value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAddonNodeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AddonNode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AddonNode();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AlwaysLoaded":
            retval.AlwaysLoaded = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "DNAMDataTypeState":
            retval.DNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AddonNode.DNAMDataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MasterParticleSystemCap":
            retval.MasterParticleSystemCap = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "NodeIndex":
            retval.NodeIndex = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Sound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.Sound, ref reader);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAIDataGetter_Converter : JsonConverter<IAIDataGetter>
{
  public override IAIDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAIDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AIData");
    writer.WritePropertyName("Aggression");
    JsonSerializer.Serialize(writer, value.Aggression, options);
    writer.WritePropertyName("AggroRadiusBehavior");
    JsonSerializer.Serialize(writer, value.AggroRadiusBehavior, options);
    writer.WritePropertyName("Assistance");
    JsonSerializer.Serialize(writer, value.Assistance, options);
    writer.WritePropertyName("Attack");
    JsonSerializer.Serialize(writer, value.Attack, options);
    writer.WritePropertyName("Confidence");
    JsonSerializer.Serialize(writer, value.Confidence, options);
    writer.WritePropertyName("EnergyLevel");
    JsonSerializer.Serialize(writer, value.EnergyLevel, options);
    writer.WritePropertyName("Mood");
    JsonSerializer.Serialize(writer, value.Mood, options);
    writer.WritePropertyName("Responsibility");
    JsonSerializer.Serialize(writer, value.Responsibility, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WritePropertyName("Warn");
    JsonSerializer.Serialize(writer, value.Warn, options);
    writer.WritePropertyName("WarnOrAttack");
    JsonSerializer.Serialize(writer, value.WarnOrAttack, options);
    writer.WriteEndObject();
  }
}
public class AIData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AIData>
{
  private IAIDataGetter_Converter _getterConverter;
  public AIData_Converter(IAIDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AIData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAIDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AIData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AIData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Aggression":
            retval.Aggression = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Aggression>(ref reader, options);
            break;
        case "AggroRadiusBehavior":
            retval.AggroRadiusBehavior = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Assistance":
            retval.Assistance = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Assistance>(ref reader, options);
            break;
        case "Attack":
            retval.Attack = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Confidence":
            retval.Confidence = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Confidence>(ref reader, options);
            break;
        case "EnergyLevel":
            retval.EnergyLevel = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Mood":
            retval.Mood = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Mood>(ref reader, options);
            break;
        case "Responsibility":
            retval.Responsibility = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Responsibility>(ref reader, options);
            break;
        case "Unused":
            retval.Unused = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Warn":
            retval.Warn = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "WarnOrAttack":
            retval.WarnOrAttack = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAlchemicalApparatusGetter_Converter : JsonConverter<IAlchemicalApparatusGetter>
{
  public override IAlchemicalApparatusGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAlchemicalApparatusGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AlchemicalApparatus");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("Quality");
    JsonSerializer.Serialize(writer, value.Quality, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class AlchemicalApparatus_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AlchemicalApparatus>
{
  private IAlchemicalApparatusGetter_Converter _getterConverter;
  public AlchemicalApparatus_Converter(IAlchemicalApparatusGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AlchemicalApparatus value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAlchemicalApparatusGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AlchemicalApparatus Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AlchemicalApparatus();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AlchemicalApparatus.DATADataType>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "Quality":
            retval.Quality = JsonSerializer.Deserialize<QualityLevel?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAlphaGetter_Converter : JsonConverter<IAlphaGetter>
{
  public override IAlphaGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAlphaGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Alpha");
    writer.WritePropertyName("Base");
    JsonSerializer.Serialize(writer, value.Base, options);
    writer.WritePropertyName("Cutoff");
    JsonSerializer.Serialize(writer, value.Cutoff, options);
    writer.WriteEndObject();
  }
}
public class Alpha_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Alpha>
{
  private IAlphaGetter_Converter _getterConverter;
  public Alpha_Converter(IAlphaGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Alpha value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAlphaGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Alpha Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Alpha();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Base":
            retval.Base = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Cutoff":
            retval.Cutoff = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAlphaLayerGetter_Converter : JsonConverter<IAlphaLayerGetter>
{
  public override IAlphaLayerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAlphaLayerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AlphaLayer");
    writer.WritePropertyName("AlphaLayerData");
    JsonSerializer.Serialize(writer, value.AlphaLayerData, options);
    writer.WritePropertyName("Header");
    JsonSerializer.Serialize(writer, value.Header, options);
    writer.WriteEndObject();
  }
}
public class AlphaLayer_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AlphaLayer>
{
  private IAlphaLayerGetter_Converter _getterConverter;
  public AlphaLayer_Converter(IAlphaLayerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AlphaLayer value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAlphaLayerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AlphaLayer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AlphaLayer();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AlphaLayerData":
            break;
        case "Header":
            retval.Header = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LayerHeader>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAlternateTextureGetter_Converter : JsonConverter<IAlternateTextureGetter>
{
  public override IAlternateTextureGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAlternateTextureGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AlternateTexture");
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("NewTexture");
    JsonSerializer.Serialize(writer, value.NewTexture, options);
    writer.WriteEndObject();
  }
}
public class AlternateTexture_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AlternateTexture>
{
  private IAlternateTextureGetter_Converter _getterConverter;
  public AlternateTexture_Converter(IAlternateTextureGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AlternateTexture value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAlternateTextureGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AlternateTexture Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AlternateTexture();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Index":
            retval.Index = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "NewTexture":
            ConverterHelpers.ReadFormLink<ITextureSetGetter>(retval.NewTexture, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAmbientColorsGetter_Converter : JsonConverter<IAmbientColorsGetter>
{
  public override IAmbientColorsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAmbientColorsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AmbientColors");
    writer.WritePropertyName("DirectionalXMinus");
    JsonSerializer.Serialize(writer, value.DirectionalXMinus, options);
    writer.WritePropertyName("DirectionalXPlus");
    JsonSerializer.Serialize(writer, value.DirectionalXPlus, options);
    writer.WritePropertyName("DirectionalYMinus");
    JsonSerializer.Serialize(writer, value.DirectionalYMinus, options);
    writer.WritePropertyName("DirectionalYPlus");
    JsonSerializer.Serialize(writer, value.DirectionalYPlus, options);
    writer.WritePropertyName("DirectionalZMinus");
    JsonSerializer.Serialize(writer, value.DirectionalZMinus, options);
    writer.WritePropertyName("DirectionalZPlus");
    JsonSerializer.Serialize(writer, value.DirectionalZPlus, options);
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("Specular");
    JsonSerializer.Serialize(writer, value.Specular, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class AmbientColors_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AmbientColors>
{
  private IAmbientColorsGetter_Converter _getterConverter;
  public AmbientColors_Converter(IAmbientColorsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AmbientColors value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAmbientColorsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AmbientColors Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AmbientColors();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DirectionalXMinus":
            retval.DirectionalXMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalXPlus":
            retval.DirectionalXPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalYMinus":
            retval.DirectionalYMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalYPlus":
            retval.DirectionalYPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalZMinus":
            retval.DirectionalZMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalZPlus":
            retval.DirectionalZPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Specular":
            retval.Specular = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AmbientColors.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAmmunitionGetter_Converter : JsonConverter<IAmmunitionGetter>
{
  public override IAmmunitionGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAmmunitionGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Ammunition");
    writer.WritePropertyName("Damage");
    JsonSerializer.Serialize(writer, value.Damage, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("Projectile");
    JsonSerializer.Serialize(writer, value.Projectile, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("ShortName");
    JsonSerializer.Serialize(writer, value.ShortName, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class Ammunition_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Ammunition>
{
  private IAmmunitionGetter_Converter _getterConverter;
  public Ammunition_Converter(IAmmunitionGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Ammunition value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAmmunitionGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Ammunition Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Ammunition();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Damage":
            retval.Damage = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ammunition.DATADataType>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ammunition.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ammunition.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "Projectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.Projectile, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "ShortName":
            retval.ShortName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAnimatedObjectGetter_Converter : JsonConverter<IAnimatedObjectGetter>
{
  public override IAnimatedObjectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAnimatedObjectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AnimatedObject");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("UnloadEvent");
    JsonSerializer.Serialize(writer, value.UnloadEvent, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class AnimatedObject_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AnimatedObject>
{
  private IAnimatedObjectGetter_Converter _getterConverter;
  public AnimatedObject_Converter(IAnimatedObjectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AnimatedObject value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAnimatedObjectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AnimatedObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AnimatedObject();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "UnloadEvent":
            retval.UnloadEvent = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAnimationChangeThresholdsGetter_Converter : JsonConverter<IAnimationChangeThresholdsGetter>
{
  public override IAnimationChangeThresholdsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAnimationChangeThresholdsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AnimationChangeThresholds");
    writer.WritePropertyName("Directional");
    JsonSerializer.Serialize(writer, value.Directional, options);
    writer.WritePropertyName("MovementSpeed");
    JsonSerializer.Serialize(writer, value.MovementSpeed, options);
    writer.WritePropertyName("RotationSpeed");
    JsonSerializer.Serialize(writer, value.RotationSpeed, options);
    writer.WriteEndObject();
  }
}
public class AnimationChangeThresholds_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AnimationChangeThresholds>
{
  private IAnimationChangeThresholdsGetter_Converter _getterConverter;
  public AnimationChangeThresholds_Converter(IAnimationChangeThresholdsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AnimationChangeThresholds value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAnimationChangeThresholdsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AnimationChangeThresholds Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AnimationChangeThresholds();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Directional":
            retval.Directional = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MovementSpeed":
            retval.MovementSpeed = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RotationSpeed":
            retval.RotationSpeed = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAPackageDataGetter_Converter : JsonConverter<IAPackageDataGetter>
{
  public override IAPackageDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAPackageDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "APackageData");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class APackageData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.APackageData>
{
  private IAPackageDataGetter_Converter _getterConverter;
  public APackageData_Converter(IAPackageDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.APackageData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAPackageDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.APackageData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.APackageData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IArmorGetter_Converter : JsonConverter<IArmorGetter>
{
  public override IArmorGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IArmorGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Armor");
    writer.WritePropertyName("AlternateBlockMaterial");
    JsonSerializer.Serialize(writer, value.AlternateBlockMaterial, options);
    if (value.Armature != default)
    {
      writer.WritePropertyName("Armature");
      writer.WriteStartArray();
      foreach (var itm in value.Armature)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Armature");
    }
    writer.WritePropertyName("ArmorRating");
    JsonSerializer.Serialize(writer, value.ArmorRating, options);
    writer.WritePropertyName("BashImpactDataSet");
    JsonSerializer.Serialize(writer, value.BashImpactDataSet, options);
    writer.WritePropertyName("BodyTemplate");
    JsonSerializer.Serialize(writer, value.BodyTemplate, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EnchantmentAmount");
    JsonSerializer.Serialize(writer, value.EnchantmentAmount, options);
    writer.WritePropertyName("EquipmentType");
    JsonSerializer.Serialize(writer, value.EquipmentType, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("ObjectEffect");
    JsonSerializer.Serialize(writer, value.ObjectEffect, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("Race");
    JsonSerializer.Serialize(writer, value.Race, options);
    writer.WritePropertyName("RagdollConstraintTemplate");
    JsonSerializer.Serialize(writer, value.RagdollConstraintTemplate, options);
    writer.WritePropertyName("TemplateArmor");
    JsonSerializer.Serialize(writer, value.TemplateArmor, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WritePropertyName("WorldModel");
    JsonSerializer.Serialize(writer, value.WorldModel, options);
    writer.WriteEndObject();
  }
}
public class Armor_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Armor>
{
  private IArmorGetter_Converter _getterConverter;
  public Armor_Converter(IArmorGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Armor value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IArmorGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Armor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Armor();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AlternateBlockMaterial":
            ConverterHelpers.ReadFormLinkNullable<IMaterialTypeGetter>(retval.AlternateBlockMaterial, ref reader);
            break;
        case "Armature":
            ConverterHelpers.ReadFormLinkList<IArmorAddonGetter>(retval.Armature, ref reader);
            break;
        case "ArmorRating":
            retval.ArmorRating = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BashImpactDataSet":
            ConverterHelpers.ReadFormLinkNullable<IImpactDataSetGetter>(retval.BashImpactDataSet, ref reader);
            break;
        case "BodyTemplate":
            retval.BodyTemplate = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BodyTemplate>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Armor.DATADataType>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EnchantmentAmount":
            retval.EnchantmentAmount = JsonSerializer.Deserialize<UInt16?>(ref reader, options);
            break;
        case "EquipmentType":
            ConverterHelpers.ReadFormLinkNullable<IEquipTypeGetter>(retval.EquipmentType, ref reader);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Armor.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "ObjectEffect":
            ConverterHelpers.ReadFormLinkNullable<IEffectRecordGetter>(retval.ObjectEffect, ref reader);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "Race":
            ConverterHelpers.ReadFormLinkNullable<IRaceGetter>(retval.Race, ref reader);
            break;
        case "RagdollConstraintTemplate":
            retval.RagdollConstraintTemplate = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TemplateArmor":
            ConverterHelpers.ReadFormLinkNullable<IArmorGetter>(retval.TemplateArmor, ref reader);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "WorldModel":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IArmorAddonGetter_Converter : JsonConverter<IArmorAddonGetter>
{
  public override IArmorAddonGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IArmorAddonGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ArmorAddon");
    if (value.AdditionalRaces != default)
    {
      writer.WritePropertyName("AdditionalRaces");
      writer.WriteStartArray();
      foreach (var itm in value.AdditionalRaces)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("AdditionalRaces");
    }
    writer.WritePropertyName("ArtObject");
    JsonSerializer.Serialize(writer, value.ArtObject, options);
    writer.WritePropertyName("BodyTemplate");
    JsonSerializer.Serialize(writer, value.BodyTemplate, options);
    writer.WritePropertyName("DetectionSoundValue");
    JsonSerializer.Serialize(writer, value.DetectionSoundValue, options);
    writer.WritePropertyName("DNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.DNAMDataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FirstPersonModel");
    JsonSerializer.Serialize(writer, value.FirstPersonModel, options);
    writer.WritePropertyName("FootstepSound");
    JsonSerializer.Serialize(writer, value.FootstepSound, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("Race");
    JsonSerializer.Serialize(writer, value.Race, options);
    writer.WritePropertyName("SkinTexture");
    JsonSerializer.Serialize(writer, value.SkinTexture, options);
    writer.WritePropertyName("TextureSwapList");
    JsonSerializer.Serialize(writer, value.TextureSwapList, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("WeaponAdjust");
    JsonSerializer.Serialize(writer, value.WeaponAdjust, options);
    writer.WritePropertyName("WeightSliderEnabled");
    JsonSerializer.Serialize(writer, value.WeightSliderEnabled, options);
    writer.WritePropertyName("WorldModel");
    JsonSerializer.Serialize(writer, value.WorldModel, options);
    writer.WriteEndObject();
  }
}
public class ArmorAddon_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ArmorAddon>
{
  private IArmorAddonGetter_Converter _getterConverter;
  public ArmorAddon_Converter(IArmorAddonGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ArmorAddon value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IArmorAddonGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ArmorAddon Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ArmorAddon();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AdditionalRaces":
            ConverterHelpers.ReadFormLinkList<IRaceGetter>(retval.AdditionalRaces, ref reader);
            break;
        case "ArtObject":
            ConverterHelpers.ReadFormLinkNullable<IArtObjectGetter>(retval.ArtObject, ref reader);
            break;
        case "BodyTemplate":
            retval.BodyTemplate = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BodyTemplate>(ref reader, options);
            break;
        case "DetectionSoundValue":
            retval.DetectionSoundValue = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "DNAMDataTypeState":
            retval.DNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ArmorAddon.DNAMDataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FirstPersonModel":
            break;
        case "FootstepSound":
            ConverterHelpers.ReadFormLinkNullable<IFootstepSetGetter>(retval.FootstepSound, ref reader);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Priority":
            break;
        case "Race":
            ConverterHelpers.ReadFormLinkNullable<IRaceGetter>(retval.Race, ref reader);
            break;
        case "SkinTexture":
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TextureSwapList":
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "WeaponAdjust":
            retval.WeaponAdjust = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "WeightSliderEnabled":
            break;
        case "WorldModel":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IArmorModelGetter_Converter : JsonConverter<IArmorModelGetter>
{
  public override IArmorModelGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IArmorModelGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ArmorModel");
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WriteEndObject();
  }
}
public class ArmorModel_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ArmorModel>
{
  private IArmorModelGetter_Converter _getterConverter;
  public ArmorModel_Converter(IArmorModelGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ArmorModel value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IArmorModelGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ArmorModel Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ArmorModel();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IArtObjectGetter_Converter : JsonConverter<IArtObjectGetter>
{
  public override IArtObjectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IArtObjectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ArtObject");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class ArtObject_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ArtObject>
{
  private IArtObjectGetter_Converter _getterConverter;
  public ArtObject_Converter(IArtObjectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ArtObject value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IArtObjectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ArtObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ArtObject();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<TypeEnum?>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAssociationTypeGetter_Converter : JsonConverter<IAssociationTypeGetter>
{
  public override IAssociationTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAssociationTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AssociationType");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("ParentTitle");
    JsonSerializer.Serialize(writer, value.ParentTitle, options);
    writer.WritePropertyName("Title");
    JsonSerializer.Serialize(writer, value.Title, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class AssociationType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AssociationType>
{
  private IAssociationTypeGetter_Converter _getterConverter;
  public AssociationType_Converter(IAssociationTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AssociationType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAssociationTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AssociationType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AssociationType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AssociationType.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ParentTitle":
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Title":
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAttackGetter_Converter : JsonConverter<IAttackGetter>
{
  public override IAttackGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAttackGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Attack");
    writer.WritePropertyName("AttackData");
    JsonSerializer.Serialize(writer, value.AttackData, options);
    writer.WritePropertyName("AttackEvent");
    JsonSerializer.Serialize(writer, value.AttackEvent, options);
    writer.WriteEndObject();
  }
}
public class Attack_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Attack>
{
  private IAttackGetter_Converter _getterConverter;
  public Attack_Converter(IAttackGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Attack value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAttackGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Attack Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Attack();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AttackData":
            retval.AttackData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AttackData>(ref reader, options);
            break;
        case "AttackEvent":
            retval.AttackEvent = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAttackDataGetter_Converter : JsonConverter<IAttackDataGetter>
{
  public override IAttackDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAttackDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AttackData");
    writer.WritePropertyName("AttackAngle");
    JsonSerializer.Serialize(writer, value.AttackAngle, options);
    writer.WritePropertyName("AttackType");
    JsonSerializer.Serialize(writer, value.AttackType, options);
    writer.WritePropertyName("Chance");
    JsonSerializer.Serialize(writer, value.Chance, options);
    writer.WritePropertyName("DamageMult");
    JsonSerializer.Serialize(writer, value.DamageMult, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Knockdown");
    JsonSerializer.Serialize(writer, value.Knockdown, options);
    writer.WritePropertyName("RecoveryTime");
    JsonSerializer.Serialize(writer, value.RecoveryTime, options);
    writer.WritePropertyName("Spell");
    JsonSerializer.Serialize(writer, value.Spell, options);
    writer.WritePropertyName("Stagger");
    JsonSerializer.Serialize(writer, value.Stagger, options);
    writer.WritePropertyName("StaminaMult");
    JsonSerializer.Serialize(writer, value.StaminaMult, options);
    writer.WritePropertyName("StrikeAngle");
    JsonSerializer.Serialize(writer, value.StrikeAngle, options);
    writer.WriteEndObject();
  }
}
public class AttackData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AttackData>
{
  private IAttackDataGetter_Converter _getterConverter;
  public AttackData_Converter(IAttackDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AttackData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAttackDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AttackData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AttackData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AttackAngle":
            retval.AttackAngle = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AttackType":
            ConverterHelpers.ReadFormLink<IKeywordGetter>(retval.AttackType, ref reader);
            break;
        case "Chance":
            retval.Chance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DamageMult":
            retval.DamageMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AttackData.Flag>(ref reader, options);
            break;
        case "Knockdown":
            retval.Knockdown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RecoveryTime":
            retval.RecoveryTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Spell":
            ConverterHelpers.ReadFormLink<ISpellRecordGetter>(retval.Spell, ref reader);
            break;
        case "Stagger":
            retval.Stagger = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "StaminaMult":
            retval.StaminaMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "StrikeAngle":
            retval.StrikeAngle = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IAvailableMorphsGetter_Converter : JsonConverter<IAvailableMorphsGetter>
{
  public override IAvailableMorphsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IAvailableMorphsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "AvailableMorphs");
    writer.WritePropertyName("Brow");
    JsonSerializer.Serialize(writer, value.Brow, options);
    writer.WritePropertyName("Eye");
    JsonSerializer.Serialize(writer, value.Eye, options);
    writer.WritePropertyName("Lip");
    JsonSerializer.Serialize(writer, value.Lip, options);
    writer.WritePropertyName("Nose");
    JsonSerializer.Serialize(writer, value.Nose, options);
    writer.WriteEndObject();
  }
}
public class AvailableMorphs_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.AvailableMorphs>
{
  private IAvailableMorphsGetter_Converter _getterConverter;
  public AvailableMorphs_Converter(IAvailableMorphsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.AvailableMorphs value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IAvailableMorphsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.AvailableMorphs Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.AvailableMorphs();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Brow":
            retval.Brow = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Morph>(ref reader, options);
            break;
        case "Eye":
            retval.Eye = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Morph>(ref reader, options);
            break;
        case "Lip":
            retval.Lip = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Morph>(ref reader, options);
            break;
        case "Nose":
            retval.Nose = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Morph>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IBaseLayerGetter_Converter : JsonConverter<IBaseLayerGetter>
{
  public override IBaseLayerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IBaseLayerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "BaseLayer");
    writer.WritePropertyName("Header");
    JsonSerializer.Serialize(writer, value.Header, options);
    writer.WriteEndObject();
  }
}
public class BaseLayer_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.BaseLayer>
{
  private IBaseLayerGetter_Converter _getterConverter;
  public BaseLayer_Converter(IBaseLayerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.BaseLayer value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IBaseLayerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.BaseLayer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.BaseLayer();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Header":
            retval.Header = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LayerHeader>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IBodyDataGetter_Converter : JsonConverter<IBodyDataGetter>
{
  public override IBodyDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IBodyDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "BodyData");
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WriteEndObject();
  }
}
public class BodyData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.BodyData>
{
  private IBodyDataGetter_Converter _getterConverter;
  public BodyData_Converter(IBodyDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.BodyData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IBodyDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.BodyData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.BodyData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Index":
            retval.Index = JsonSerializer.Deserialize<PartIndex?>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IBodyPartGetter_Converter : JsonConverter<IBodyPartGetter>
{
  public override IBodyPartGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IBodyPartGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "BodyPart");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("BPNDDataTypeState");
    JsonSerializer.Serialize(writer, value.BPNDDataTypeState, options);
    writer.WritePropertyName("DamageMult");
    JsonSerializer.Serialize(writer, value.DamageMult, options);
    writer.WritePropertyName("ExplodableDebris");
    JsonSerializer.Serialize(writer, value.ExplodableDebris, options);
    writer.WritePropertyName("ExplodableDebrisCount");
    JsonSerializer.Serialize(writer, value.ExplodableDebrisCount, options);
    writer.WritePropertyName("ExplodableDebrisScale");
    JsonSerializer.Serialize(writer, value.ExplodableDebrisScale, options);
    writer.WritePropertyName("ExplodableDecalCount");
    JsonSerializer.Serialize(writer, value.ExplodableDecalCount, options);
    writer.WritePropertyName("ExplodableExplosion");
    JsonSerializer.Serialize(writer, value.ExplodableExplosion, options);
    writer.WritePropertyName("ExplodableExplosionChance");
    JsonSerializer.Serialize(writer, value.ExplodableExplosionChance, options);
    writer.WritePropertyName("ExplodableImpactData");
    JsonSerializer.Serialize(writer, value.ExplodableImpactData, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("GorePositioning");
    JsonSerializer.Serialize(writer, value.GorePositioning, options);
    writer.WritePropertyName("GoreRotation");
    JsonSerializer.Serialize(writer, value.GoreRotation, options);
    writer.WritePropertyName("GoreTargetBone");
    JsonSerializer.Serialize(writer, value.GoreTargetBone, options);
    writer.WritePropertyName("HealthPercent");
    JsonSerializer.Serialize(writer, value.HealthPercent, options);
    writer.WritePropertyName("IkStartNode");
    JsonSerializer.Serialize(writer, value.IkStartNode, options);
    writer.WritePropertyName("LimbReplacementModel");
    JsonSerializer.Serialize(writer, value.LimbReplacementModel, options);
    writer.WritePropertyName("LimbReplacementScale");
    JsonSerializer.Serialize(writer, value.LimbReplacementScale, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("PartNode");
    JsonSerializer.Serialize(writer, value.PartNode, options);
    writer.WritePropertyName("PoseMatching");
    JsonSerializer.Serialize(writer, value.PoseMatching, options);
    writer.WritePropertyName("SeverableDebris");
    JsonSerializer.Serialize(writer, value.SeverableDebris, options);
    writer.WritePropertyName("SeverableDebrisCount");
    JsonSerializer.Serialize(writer, value.SeverableDebrisCount, options);
    writer.WritePropertyName("SeverableDebrisScale");
    JsonSerializer.Serialize(writer, value.SeverableDebrisScale, options);
    writer.WritePropertyName("SeverableDecalCount");
    JsonSerializer.Serialize(writer, value.SeverableDecalCount, options);
    writer.WritePropertyName("SeverableExplosion");
    JsonSerializer.Serialize(writer, value.SeverableExplosion, options);
    writer.WritePropertyName("SeverableImpactData");
    JsonSerializer.Serialize(writer, value.SeverableImpactData, options);
    writer.WritePropertyName("TextureFilesHashes");
    JsonSerializer.Serialize(writer, value.TextureFilesHashes, options);
    writer.WritePropertyName("ToHitChance");
    JsonSerializer.Serialize(writer, value.ToHitChance, options);
    writer.WritePropertyName("TrackingMaxAngle");
    JsonSerializer.Serialize(writer, value.TrackingMaxAngle, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("VatsTarget");
    JsonSerializer.Serialize(writer, value.VatsTarget, options);
    writer.WriteEndObject();
  }
}
public class BodyPart_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.BodyPart>
{
  private IBodyPartGetter_Converter _getterConverter;
  public BodyPart_Converter(IBodyPartGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.BodyPart value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IBodyPartGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.BodyPart Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.BodyPart();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "BPNDDataTypeState":
            retval.BPNDDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BodyPart.BPNDDataType>(ref reader, options);
            break;
        case "DamageMult":
            retval.DamageMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ExplodableDebris":
            ConverterHelpers.ReadFormLink<IDebrisGetter>(retval.ExplodableDebris, ref reader);
            break;
        case "ExplodableDebrisCount":
            retval.ExplodableDebrisCount = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "ExplodableDebrisScale":
            retval.ExplodableDebrisScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ExplodableDecalCount":
            retval.ExplodableDecalCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "ExplodableExplosion":
            ConverterHelpers.ReadFormLink<IExplosionGetter>(retval.ExplodableExplosion, ref reader);
            break;
        case "ExplodableExplosionChance":
            retval.ExplodableExplosionChance = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "ExplodableImpactData":
            ConverterHelpers.ReadFormLink<IImpactDataSetGetter>(retval.ExplodableImpactData, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BodyPart.Flag>(ref reader, options);
            break;
        case "GorePositioning":
            retval.GorePositioning = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "GoreRotation":
            retval.GoreRotation = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "GoreTargetBone":
            retval.GoreTargetBone = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "HealthPercent":
            retval.HealthPercent = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "IkStartNode":
            retval.IkStartNode = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "LimbReplacementModel":
            retval.LimbReplacementModel = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "LimbReplacementScale":
            retval.LimbReplacementScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "PartNode":
            retval.PartNode = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "PoseMatching":
            retval.PoseMatching = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "SeverableDebris":
            ConverterHelpers.ReadFormLink<IDebrisGetter>(retval.SeverableDebris, ref reader);
            break;
        case "SeverableDebrisCount":
            retval.SeverableDebrisCount = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SeverableDebrisScale":
            retval.SeverableDebrisScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SeverableDecalCount":
            retval.SeverableDecalCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "SeverableExplosion":
            ConverterHelpers.ReadFormLink<IExplosionGetter>(retval.SeverableExplosion, ref reader);
            break;
        case "SeverableImpactData":
            ConverterHelpers.ReadFormLink<IImpactDataSetGetter>(retval.SeverableImpactData, ref reader);
            break;
        case "TextureFilesHashes":
            break;
        case "ToHitChance":
            retval.ToHitChance = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "TrackingMaxAngle":
            retval.TrackingMaxAngle = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BodyPart.PartType>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VatsTarget":
            retval.VatsTarget = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IBodyPartDataGetter_Converter : JsonConverter<IBodyPartDataGetter>
{
  public override IBodyPartDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IBodyPartDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "BodyPartData");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    if (value.Parts != default)
    {
      writer.WritePropertyName("Parts");
      writer.WriteStartArray();
      foreach (var itm in value.Parts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Parts");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class BodyPartData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.BodyPartData>
{
  private IBodyPartDataGetter_Converter _getterConverter;
  public BodyPartData_Converter(IBodyPartDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.BodyPartData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IBodyPartDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.BodyPartData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.BodyPartData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Parts":
            ConverterHelpers.ReadExtendedList<BodyPart>(retval.Parts, ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IBodyTemplateGetter_Converter : JsonConverter<IBodyTemplateGetter>
{
  public override IBodyTemplateGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IBodyTemplateGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "BodyTemplate");
    writer.WritePropertyName("ActsLike44");
    JsonSerializer.Serialize(writer, value.ActsLike44, options);
    writer.WritePropertyName("ArmorType");
    JsonSerializer.Serialize(writer, value.ArmorType, options);
    writer.WritePropertyName("FirstPersonFlags");
    JsonSerializer.Serialize(writer, value.FirstPersonFlags, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WriteEndObject();
  }
}
public class BodyTemplate_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.BodyTemplate>
{
  private IBodyTemplateGetter_Converter _getterConverter;
  public BodyTemplate_Converter(IBodyTemplateGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.BodyTemplate value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IBodyTemplateGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.BodyTemplate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.BodyTemplate();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActsLike44":
            retval.ActsLike44 = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "ArmorType":
            retval.ArmorType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ArmorType>(ref reader, options);
            break;
        case "FirstPersonFlags":
            retval.FirstPersonFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BipedObjectFlag>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BodyTemplate.Flag>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IBookGetter_Converter : JsonConverter<IBookGetter>
{
  public override IBookGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IBookGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Book");
    writer.WritePropertyName("BookText");
    JsonSerializer.Serialize(writer, value.BookText, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("InventoryArt");
    JsonSerializer.Serialize(writer, value.InventoryArt, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("Teaches");
    JsonSerializer.Serialize(writer, value.Teaches, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class Book_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Book>
{
  private IBookGetter_Converter _getterConverter;
  public Book_Converter(IBookGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Book value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IBookGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Book Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Book();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BookText":
            retval.BookText = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Book.DATADataType>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Book.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "InventoryArt":
            ConverterHelpers.ReadFormLinkNullable<IStaticGetter>(retval.InventoryArt, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Teaches":
            retval.Teaches = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BookTeachTarget>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Book.BookType>(ref reader, options);
            break;
        case "Unused":
            retval.Unused = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IBookSkillGetter_Converter : JsonConverter<IBookSkillGetter>
{
  public override IBookSkillGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IBookSkillGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "BookSkill");
    writer.WritePropertyName("Skill");
    JsonSerializer.Serialize(writer, value.Skill, options);
    writer.WriteEndObject();
  }
}
public class BookSkill_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.BookSkill>
{
  private IBookSkillGetter_Converter _getterConverter;
  public BookSkill_Converter(IBookSkillGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.BookSkill value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IBookSkillGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.BookSkill Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.BookSkill();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Skill":
            retval.Skill = JsonSerializer.Deserialize<Skill?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IBookSpellGetter_Converter : JsonConverter<IBookSpellGetter>
{
  public override IBookSpellGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IBookSpellGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "BookSpell");
    writer.WritePropertyName("Spell");
    JsonSerializer.Serialize(writer, value.Spell, options);
    writer.WriteEndObject();
  }
}
public class BookSpell_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.BookSpell>
{
  private IBookSpellGetter_Converter _getterConverter;
  public BookSpell_Converter(IBookSpellGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.BookSpell value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IBookSpellGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.BookSpell Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.BookSpell();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Spell":
            ConverterHelpers.ReadFormLink<ISpellGetter>(retval.Spell, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IBookTeachesNothingGetter_Converter : JsonConverter<IBookTeachesNothingGetter>
{
  public override IBookTeachesNothingGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IBookTeachesNothingGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "BookTeachesNothing");
    writer.WritePropertyName("RawContent");
    JsonSerializer.Serialize(writer, value.RawContent, options);
    writer.WriteEndObject();
  }
}
public class BookTeachesNothing_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.BookTeachesNothing>
{
  private IBookTeachesNothingGetter_Converter _getterConverter;
  public BookTeachesNothing_Converter(IBookTeachesNothingGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.BookTeachesNothing value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IBookTeachesNothingGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.BookTeachesNothing Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.BookTeachesNothing();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "RawContent":
            retval.RawContent = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IBoundingGetter_Converter : JsonConverter<IBoundingGetter>
{
  public override IBoundingGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IBoundingGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Bounding");
    writer.WritePropertyName("Height");
    JsonSerializer.Serialize(writer, value.Height, options);
    writer.WritePropertyName("Position");
    JsonSerializer.Serialize(writer, value.Position, options);
    writer.WritePropertyName("RotationQ1");
    JsonSerializer.Serialize(writer, value.RotationQ1, options);
    writer.WritePropertyName("RotationQ2");
    JsonSerializer.Serialize(writer, value.RotationQ2, options);
    writer.WritePropertyName("RotationQ3");
    JsonSerializer.Serialize(writer, value.RotationQ3, options);
    writer.WritePropertyName("RotationQ4");
    JsonSerializer.Serialize(writer, value.RotationQ4, options);
    writer.WritePropertyName("Width");
    JsonSerializer.Serialize(writer, value.Width, options);
    writer.WriteEndObject();
  }
}
public class Bounding_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Bounding>
{
  private IBoundingGetter_Converter _getterConverter;
  public Bounding_Converter(IBoundingGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Bounding value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IBoundingGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Bounding Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Bounding();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Height":
            retval.Height = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Position":
            retval.Position = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "RotationQ1":
            retval.RotationQ1 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RotationQ2":
            retval.RotationQ2 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RotationQ3":
            retval.RotationQ3 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RotationQ4":
            retval.RotationQ4 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Width":
            retval.Width = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICameraPathGetter_Converter : JsonConverter<ICameraPathGetter>
{
  public override ICameraPathGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICameraPathGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CameraPath");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.RelatedPaths != default)
    {
      writer.WritePropertyName("RelatedPaths");
      writer.WriteStartArray();
      foreach (var itm in value.RelatedPaths)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RelatedPaths");
    }
    if (value.Shots != default)
    {
      writer.WritePropertyName("Shots");
      writer.WriteStartArray();
      foreach (var itm in value.Shots)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Shots");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("Zoom");
    JsonSerializer.Serialize(writer, value.Zoom, options);
    writer.WritePropertyName("ZoomMustHaveCameraShots");
    JsonSerializer.Serialize(writer, value.ZoomMustHaveCameraShots, options);
    writer.WriteEndObject();
  }
}
public class CameraPath_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CameraPath>
{
  private ICameraPathGetter_Converter _getterConverter;
  public CameraPath_Converter(ICameraPathGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CameraPath value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICameraPathGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CameraPath Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CameraPath();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "RelatedPaths":
            ConverterHelpers.ReadFormLinkList<ICameraPathGetter>(retval.RelatedPaths, ref reader);
            break;
        case "Shots":
            ConverterHelpers.ReadFormLinkList<ICameraShotGetter>(retval.Shots, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Zoom":
            retval.Zoom = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CameraPath.ZoomType>(ref reader, options);
            break;
        case "ZoomMustHaveCameraShots":
            retval.ZoomMustHaveCameraShots = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICameraShotGetter_Converter : JsonConverter<ICameraShotGetter>
{
  public override ICameraShotGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICameraShotGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CameraShot");
    writer.WritePropertyName("Action");
    JsonSerializer.Serialize(writer, value.Action, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("ImageSpaceModifier");
    JsonSerializer.Serialize(writer, value.ImageSpaceModifier, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("Location");
    JsonSerializer.Serialize(writer, value.Location, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MaxTime");
    JsonSerializer.Serialize(writer, value.MaxTime, options);
    writer.WritePropertyName("MinTime");
    JsonSerializer.Serialize(writer, value.MinTime, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("NearTargetDistance");
    JsonSerializer.Serialize(writer, value.NearTargetDistance, options);
    writer.WritePropertyName("Target");
    JsonSerializer.Serialize(writer, value.Target, options);
    writer.WritePropertyName("TargetPercentBetweenActors");
    JsonSerializer.Serialize(writer, value.TargetPercentBetweenActors, options);
    writer.WritePropertyName("TimeMultiplierGlobal");
    JsonSerializer.Serialize(writer, value.TimeMultiplierGlobal, options);
    writer.WritePropertyName("TimeMultiplierPlayer");
    JsonSerializer.Serialize(writer, value.TimeMultiplierPlayer, options);
    writer.WritePropertyName("TimeMultiplierTarget");
    JsonSerializer.Serialize(writer, value.TimeMultiplierTarget, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class CameraShot_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CameraShot>
{
  private ICameraShotGetter_Converter _getterConverter;
  public CameraShot_Converter(ICameraShotGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CameraShot value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICameraShotGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CameraShot Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CameraShot();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Action":
            retval.Action = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CameraShot.ActionType>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CameraShot.DATADataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CameraShot.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "ImageSpaceModifier":
            ConverterHelpers.ReadFormLinkNullable<IImageSpaceAdapterGetter>(retval.ImageSpaceModifier, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Location":
            retval.Location = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CameraShot.LocationType>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MaxTime":
            retval.MaxTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MinTime":
            retval.MinTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "NearTargetDistance":
            retval.NearTargetDistance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Target":
            retval.Target = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CameraShot.TargetType>(ref reader, options);
            break;
        case "TargetPercentBetweenActors":
            retval.TargetPercentBetweenActors = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "TimeMultiplierGlobal":
            retval.TimeMultiplierGlobal = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "TimeMultiplierPlayer":
            retval.TimeMultiplierPlayer = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "TimeMultiplierTarget":
            retval.TimeMultiplierTarget = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICellGetter_Converter : JsonConverter<ICellGetter>
{
  public override ICellGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICellGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Cell");
    writer.WritePropertyName("AcousticSpace");
    JsonSerializer.Serialize(writer, value.AcousticSpace, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Grid");
    JsonSerializer.Serialize(writer, value.Grid, options);
    writer.WritePropertyName("ImageSpace");
    JsonSerializer.Serialize(writer, value.ImageSpace, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("Landscape");
    JsonSerializer.Serialize(writer, value.Landscape, options);
    writer.WritePropertyName("Lighting");
    JsonSerializer.Serialize(writer, value.Lighting, options);
    writer.WritePropertyName("LightingTemplate");
    JsonSerializer.Serialize(writer, value.LightingTemplate, options);
    writer.WritePropertyName("LNAM");
    JsonSerializer.Serialize(writer, value.LNAM, options);
    writer.WritePropertyName("Location");
    JsonSerializer.Serialize(writer, value.Location, options);
    writer.WritePropertyName("LockList");
    JsonSerializer.Serialize(writer, value.LockList, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MaxHeightData");
    JsonSerializer.Serialize(writer, value.MaxHeightData, options);
    writer.WritePropertyName("Music");
    JsonSerializer.Serialize(writer, value.Music, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    if (value.NavigationMeshes != default)
    {
      writer.WritePropertyName("NavigationMeshes");
      writer.WriteStartArray();
      foreach (var itm in value.NavigationMeshes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("NavigationMeshes");
    }
    writer.WritePropertyName("OcclusionData");
    JsonSerializer.Serialize(writer, value.OcclusionData, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    if (value.Persistent != default)
    {
      writer.WritePropertyName("Persistent");
      writer.WriteStartArray();
      foreach (var itm in value.Persistent)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Persistent");
    }
    writer.WritePropertyName("PersistentTimestamp");
    JsonSerializer.Serialize(writer, value.PersistentTimestamp, options);
    writer.WritePropertyName("PersistentUnknownGroupData");
    JsonSerializer.Serialize(writer, value.PersistentUnknownGroupData, options);
    if (value.Regions != default)
    {
      writer.WritePropertyName("Regions");
      writer.WriteStartArray();
      foreach (var itm in value.Regions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Regions");
    }
    writer.WritePropertyName("SkyAndWeatherFromRegion");
    JsonSerializer.Serialize(writer, value.SkyAndWeatherFromRegion, options);
    if (value.Temporary != default)
    {
      writer.WritePropertyName("Temporary");
      writer.WriteStartArray();
      foreach (var itm in value.Temporary)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Temporary");
    }
    writer.WritePropertyName("TemporaryTimestamp");
    JsonSerializer.Serialize(writer, value.TemporaryTimestamp, options);
    writer.WritePropertyName("TemporaryUnknownGroupData");
    JsonSerializer.Serialize(writer, value.TemporaryUnknownGroupData, options);
    writer.WritePropertyName("Timestamp");
    JsonSerializer.Serialize(writer, value.Timestamp, options);
    writer.WritePropertyName("UnknownGroupData");
    JsonSerializer.Serialize(writer, value.UnknownGroupData, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("Water");
    JsonSerializer.Serialize(writer, value.Water, options);
    writer.WritePropertyName("WaterEnvironmentMap");
    JsonSerializer.Serialize(writer, value.WaterEnvironmentMap, options);
    writer.WritePropertyName("WaterHeight");
    JsonSerializer.Serialize(writer, value.WaterHeight, options);
    writer.WritePropertyName("WaterNoiseTexture");
    JsonSerializer.Serialize(writer, value.WaterNoiseTexture, options);
    writer.WritePropertyName("WaterVelocity");
    JsonSerializer.Serialize(writer, value.WaterVelocity, options);
    writer.WritePropertyName("XWCN");
    JsonSerializer.Serialize(writer, value.XWCN, options);
    writer.WritePropertyName("XWCS");
    JsonSerializer.Serialize(writer, value.XWCS, options);
    writer.WriteEndObject();
  }
}
public class Cell_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Cell>
{
  private ICellGetter_Converter _getterConverter;
  public Cell_Converter(ICellGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Cell value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICellGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Cell Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Cell();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AcousticSpace":
            ConverterHelpers.ReadFormLinkNullable<IAcousticSpaceGetter>(retval.AcousticSpace, ref reader);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Cell.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Grid":
            retval.Grid = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CellGrid>(ref reader, options);
            break;
        case "ImageSpace":
            ConverterHelpers.ReadFormLinkNullable<IImageSpaceGetter>(retval.ImageSpace, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Landscape":
            retval.Landscape = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Landscape>(ref reader, options);
            break;
        case "Lighting":
            retval.Lighting = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CellLighting>(ref reader, options);
            break;
        case "LightingTemplate":
            ConverterHelpers.ReadFormLink<ILightingTemplateGetter>(retval.LightingTemplate, ref reader);
            break;
        case "LNAM":
            break;
        case "Location":
            ConverterHelpers.ReadFormLinkNullable<ILocationGetter>(retval.Location, ref reader);
            break;
        case "LockList":
            ConverterHelpers.ReadFormLinkNullable<ILockListGetter>(retval.LockList, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Cell.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MaxHeightData":
            retval.MaxHeightData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CellMaxHeightData>(ref reader, options);
            break;
        case "Music":
            ConverterHelpers.ReadFormLinkNullable<IMusicTypeGetter>(retval.Music, ref reader);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "NavigationMeshes":
            ConverterHelpers.ReadExtendedList<NavigationMesh>(retval.NavigationMeshes, ref reader, options);
            break;
        case "OcclusionData":
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Persistent":
            ConverterHelpers.ReadExtendedList<IPlaced>(retval.Persistent, ref reader, options);
            break;
        case "PersistentTimestamp":
            retval.PersistentTimestamp = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "PersistentUnknownGroupData":
            retval.PersistentUnknownGroupData = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Regions":
            ConverterHelpers.ReadFormLinkList<IRegionGetter>(retval.Regions, ref reader);
            break;
        case "SkyAndWeatherFromRegion":
            ConverterHelpers.ReadFormLinkNullable<IRegionGetter>(retval.SkyAndWeatherFromRegion, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Temporary":
            ConverterHelpers.ReadExtendedList<IPlaced>(retval.Temporary, ref reader, options);
            break;
        case "TemporaryTimestamp":
            retval.TemporaryTimestamp = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "TemporaryUnknownGroupData":
            retval.TemporaryUnknownGroupData = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Timestamp":
            retval.Timestamp = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "UnknownGroupData":
            retval.UnknownGroupData = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Water":
            ConverterHelpers.ReadFormLinkNullable<IWaterGetter>(retval.Water, ref reader);
            break;
        case "WaterEnvironmentMap":
            retval.WaterEnvironmentMap = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "WaterHeight":
            retval.WaterHeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "WaterNoiseTexture":
            retval.WaterNoiseTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "WaterVelocity":
            retval.WaterVelocity = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CellWaterVelocity>(ref reader, options);
            break;
        case "XWCN":
            break;
        case "XWCS":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICellBlockGetter_Converter : JsonConverter<ICellBlockGetter>
{
  public override ICellBlockGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICellBlockGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CellBlock");
    writer.WritePropertyName("BlockNumber");
    JsonSerializer.Serialize(writer, value.BlockNumber, options);
    writer.WritePropertyName("GroupType");
    JsonSerializer.Serialize(writer, value.GroupType, options);
    writer.WritePropertyName("LastModified");
    JsonSerializer.Serialize(writer, value.LastModified, options);
    if (value.SubBlocks != default)
    {
      writer.WritePropertyName("SubBlocks");
      writer.WriteStartArray();
      foreach (var itm in value.SubBlocks)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("SubBlocks");
    }
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class CellBlock_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CellBlock>
{
  private ICellBlockGetter_Converter _getterConverter;
  public CellBlock_Converter(ICellBlockGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CellBlock value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICellBlockGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CellBlock Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CellBlock();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BlockNumber":
            retval.BlockNumber = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "GroupType":
            retval.GroupType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.GroupTypeEnum>(ref reader, options);
            break;
        case "LastModified":
            retval.LastModified = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SubBlocks":
            ConverterHelpers.ReadExtendedList<CellSubBlock>(retval.SubBlocks, ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICellGridGetter_Converter : JsonConverter<ICellGridGetter>
{
  public override ICellGridGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICellGridGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CellGrid");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Point");
    JsonSerializer.Serialize(writer, value.Point, options);
    writer.WriteEndObject();
  }
}
public class CellGrid_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CellGrid>
{
  private ICellGridGetter_Converter _getterConverter;
  public CellGrid_Converter(ICellGridGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CellGrid value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICellGridGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CellGrid Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CellGrid();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CellGrid.Flag>(ref reader, options);
            break;
        case "Point":
            retval.Point = JsonSerializer.Deserialize<Noggog.P2Int>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICellLightingGetter_Converter : JsonConverter<ICellLightingGetter>
{
  public override ICellLightingGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICellLightingGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CellLighting");
    writer.WritePropertyName("AmbientColor");
    JsonSerializer.Serialize(writer, value.AmbientColor, options);
    writer.WritePropertyName("AmbientDirectionalXMinus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalXMinus, options);
    writer.WritePropertyName("AmbientDirectionalXPlus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalXPlus, options);
    writer.WritePropertyName("AmbientDirectionalYMinus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalYMinus, options);
    writer.WritePropertyName("AmbientDirectionalYPlus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalYPlus, options);
    writer.WritePropertyName("AmbientDirectionalZMinus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalZMinus, options);
    writer.WritePropertyName("AmbientDirectionalZPlus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalZPlus, options);
    writer.WritePropertyName("AmbientScale");
    JsonSerializer.Serialize(writer, value.AmbientScale, options);
    writer.WritePropertyName("AmbientSpecular");
    JsonSerializer.Serialize(writer, value.AmbientSpecular, options);
    writer.WritePropertyName("DirectionalColor");
    JsonSerializer.Serialize(writer, value.DirectionalColor, options);
    writer.WritePropertyName("DirectionalFade");
    JsonSerializer.Serialize(writer, value.DirectionalFade, options);
    writer.WritePropertyName("DirectionalRotationXY");
    JsonSerializer.Serialize(writer, value.DirectionalRotationXY, options);
    writer.WritePropertyName("DirectionalRotationZ");
    JsonSerializer.Serialize(writer, value.DirectionalRotationZ, options);
    writer.WritePropertyName("FogClipDistance");
    JsonSerializer.Serialize(writer, value.FogClipDistance, options);
    writer.WritePropertyName("FogFar");
    JsonSerializer.Serialize(writer, value.FogFar, options);
    writer.WritePropertyName("FogFarColor");
    JsonSerializer.Serialize(writer, value.FogFarColor, options);
    writer.WritePropertyName("FogMax");
    JsonSerializer.Serialize(writer, value.FogMax, options);
    writer.WritePropertyName("FogNear");
    JsonSerializer.Serialize(writer, value.FogNear, options);
    writer.WritePropertyName("FogNearColor");
    JsonSerializer.Serialize(writer, value.FogNearColor, options);
    writer.WritePropertyName("FogPower");
    JsonSerializer.Serialize(writer, value.FogPower, options);
    writer.WritePropertyName("Inherits");
    JsonSerializer.Serialize(writer, value.Inherits, options);
    writer.WritePropertyName("LightFadeBegin");
    JsonSerializer.Serialize(writer, value.LightFadeBegin, options);
    writer.WritePropertyName("LightFadeEnd");
    JsonSerializer.Serialize(writer, value.LightFadeEnd, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class CellLighting_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CellLighting>
{
  private ICellLightingGetter_Converter _getterConverter;
  public CellLighting_Converter(ICellLightingGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CellLighting value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICellLightingGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CellLighting Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CellLighting();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AmbientColor":
            retval.AmbientColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalXMinus":
            retval.AmbientDirectionalXMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalXPlus":
            retval.AmbientDirectionalXPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalYMinus":
            retval.AmbientDirectionalYMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalYPlus":
            retval.AmbientDirectionalYPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalZMinus":
            retval.AmbientDirectionalZMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalZPlus":
            retval.AmbientDirectionalZPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientScale":
            retval.AmbientScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AmbientSpecular":
            retval.AmbientSpecular = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalColor":
            retval.DirectionalColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalFade":
            retval.DirectionalFade = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DirectionalRotationXY":
            retval.DirectionalRotationXY = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "DirectionalRotationZ":
            retval.DirectionalRotationZ = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "DirectionalXMinus":
            retval.DirectionalXMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalXPlus":
            retval.DirectionalXPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalYMinus":
            retval.DirectionalYMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalYPlus":
            retval.DirectionalYPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalZMinus":
            retval.DirectionalZMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalZPlus":
            retval.DirectionalZPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "FogClipDistance":
            retval.FogClipDistance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogFar":
            retval.FogFar = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogFarColor":
            retval.FogFarColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "FogMax":
            retval.FogMax = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogNear":
            retval.FogNear = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogNearColor":
            retval.FogNearColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "FogPower":
            retval.FogPower = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Inherits":
            retval.Inherits = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CellLighting.Inherit>(ref reader, options);
            break;
        case "LightFadeBegin":
            retval.LightFadeBegin = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "LightFadeEnd":
            retval.LightFadeEnd = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Specular":
            retval.Specular = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CellLighting.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICellMaxHeightDataGetter_Converter : JsonConverter<ICellMaxHeightDataGetter>
{
  public override ICellMaxHeightDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICellMaxHeightDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CellMaxHeightData");
    writer.WritePropertyName("HeightMap");
    JsonSerializer.Serialize(writer, value.HeightMap, options);
    writer.WritePropertyName("Offset");
    JsonSerializer.Serialize(writer, value.Offset, options);
    writer.WriteEndObject();
  }
}
public class CellMaxHeightData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CellMaxHeightData>
{
  private ICellMaxHeightDataGetter_Converter _getterConverter;
  public CellMaxHeightData_Converter(ICellMaxHeightDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CellMaxHeightData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICellMaxHeightDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CellMaxHeightData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CellMaxHeightData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "HeightMap":
            break;
        case "Offset":
            retval.Offset = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICellNavmeshParentGetter_Converter : JsonConverter<ICellNavmeshParentGetter>
{
  public override ICellNavmeshParentGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICellNavmeshParentGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CellNavmeshParent");
    writer.WritePropertyName("Parent");
    JsonSerializer.Serialize(writer, value.Parent, options);
    writer.WritePropertyName("UnusedWorldspaceParent");
    JsonSerializer.Serialize(writer, value.UnusedWorldspaceParent, options);
    writer.WriteEndObject();
  }
}
public class CellNavmeshParent_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CellNavmeshParent>
{
  private ICellNavmeshParentGetter_Converter _getterConverter;
  public CellNavmeshParent_Converter(ICellNavmeshParentGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CellNavmeshParent value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICellNavmeshParentGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CellNavmeshParent Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CellNavmeshParent();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Parent":
            ConverterHelpers.ReadFormLink<ICellGetter>(retval.Parent, ref reader);
            break;
        case "UnusedWorldspaceParent":
            ConverterHelpers.ReadFormLink<IWorldspaceGetter>(retval.UnusedWorldspaceParent, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICellSubBlockGetter_Converter : JsonConverter<ICellSubBlockGetter>
{
  public override ICellSubBlockGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICellSubBlockGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CellSubBlock");
    writer.WritePropertyName("BlockNumber");
    JsonSerializer.Serialize(writer, value.BlockNumber, options);
    if (value.Cells != default)
    {
      writer.WritePropertyName("Cells");
      writer.WriteStartArray();
      foreach (var itm in value.Cells)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Cells");
    }
    writer.WritePropertyName("GroupType");
    JsonSerializer.Serialize(writer, value.GroupType, options);
    writer.WritePropertyName("LastModified");
    JsonSerializer.Serialize(writer, value.LastModified, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class CellSubBlock_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CellSubBlock>
{
  private ICellSubBlockGetter_Converter _getterConverter;
  public CellSubBlock_Converter(ICellSubBlockGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CellSubBlock value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICellSubBlockGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CellSubBlock Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CellSubBlock();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BlockNumber":
            retval.BlockNumber = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Cells":
            ConverterHelpers.ReadExtendedList<Cell>(retval.Cells, ref reader, options);
            break;
        case "GroupType":
            retval.GroupType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.GroupTypeEnum>(ref reader, options);
            break;
        case "LastModified":
            retval.LastModified = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICellWaterVelocityGetter_Converter : JsonConverter<ICellWaterVelocityGetter>
{
  public override ICellWaterVelocityGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICellWaterVelocityGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CellWaterVelocity");
    writer.WritePropertyName("Angle");
    JsonSerializer.Serialize(writer, value.Angle, options);
    writer.WritePropertyName("Offset");
    JsonSerializer.Serialize(writer, value.Offset, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class CellWaterVelocity_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CellWaterVelocity>
{
  private ICellWaterVelocityGetter_Converter _getterConverter;
  public CellWaterVelocity_Converter(ICellWaterVelocityGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CellWaterVelocity value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICellWaterVelocityGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CellWaterVelocity Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CellWaterVelocity();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Angle":
            retval.Angle = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "Offset":
            retval.Offset = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown2":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IClassGetter_Converter : JsonConverter<IClassGetter>
{
  public override IClassGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IClassGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Class");
    writer.WritePropertyName("BleedoutDefault");
    JsonSerializer.Serialize(writer, value.BleedoutDefault, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icon");
    JsonSerializer.Serialize(writer, value.Icon, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MaxTrainingLevel");
    JsonSerializer.Serialize(writer, value.MaxTrainingLevel, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("SkillWeights");
    JsonSerializer.Serialize(writer, value.SkillWeights, options);
    writer.WritePropertyName("StatWeights");
    JsonSerializer.Serialize(writer, value.StatWeights, options);
    writer.WritePropertyName("Teaches");
    JsonSerializer.Serialize(writer, value.Teaches, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VoicePoints");
    JsonSerializer.Serialize(writer, value.VoicePoints, options);
    writer.WriteEndObject();
  }
}
public class Class_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Class>
{
  private IClassGetter_Converter _getterConverter;
  public Class_Converter(IClassGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Class value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IClassGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Class Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Class();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BleedoutDefault":
            retval.BleedoutDefault = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Class.DATADataType>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icon":
            retval.Icon = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MaxTrainingLevel":
            retval.MaxTrainingLevel = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "SkillWeights":
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "StatWeights":
            break;
        case "Teaches":
            retval.Teaches = JsonSerializer.Deserialize<Skill?>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VoicePoints":
            retval.VoicePoints = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IClimateGetter_Converter : JsonConverter<IClimateGetter>
{
  public override IClimateGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IClimateGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Climate");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Moons");
    JsonSerializer.Serialize(writer, value.Moons, options);
    writer.WritePropertyName("PhaseLength");
    JsonSerializer.Serialize(writer, value.PhaseLength, options);
    writer.WritePropertyName("SunGlareTexture");
    JsonSerializer.Serialize(writer, value.SunGlareTexture, options);
    writer.WritePropertyName("SunriseBeginRaw");
    JsonSerializer.Serialize(writer, value.SunriseBeginRaw, options);
    writer.WritePropertyName("SunriseEndRaw");
    JsonSerializer.Serialize(writer, value.SunriseEndRaw, options);
    writer.WritePropertyName("SunsetBeginRaw");
    JsonSerializer.Serialize(writer, value.SunsetBeginRaw, options);
    writer.WritePropertyName("SunsetEndRaw");
    JsonSerializer.Serialize(writer, value.SunsetEndRaw, options);
    writer.WritePropertyName("SunTexture");
    JsonSerializer.Serialize(writer, value.SunTexture, options);
    writer.WritePropertyName("TNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.TNAMDataTypeState, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("Volatility");
    JsonSerializer.Serialize(writer, value.Volatility, options);
    if (value.WeatherTypes != default)
    {
      writer.WritePropertyName("WeatherTypes");
      writer.WriteStartArray();
      foreach (var itm in value.WeatherTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("WeatherTypes");
    }
    writer.WriteEndObject();
  }
}
public class Climate_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Climate>
{
  private IClimateGetter_Converter _getterConverter;
  public Climate_Converter(IClimateGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Climate value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IClimateGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Climate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Climate();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Moons":
            retval.Moons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Climate.Moon>(ref reader, options);
            break;
        case "PhaseLength":
            retval.PhaseLength = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SunGlareTexture":
            retval.SunGlareTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "SunriseBeginRaw":
            retval.SunriseBeginRaw = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "SunriseEndRaw":
            retval.SunriseEndRaw = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "SunsetBeginRaw":
            retval.SunsetBeginRaw = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "SunsetEndRaw":
            retval.SunsetEndRaw = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "SunTexture":
            retval.SunTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "TNAMDataTypeState":
            retval.TNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Climate.TNAMDataType>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Volatility":
            retval.Volatility = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "WeatherTypes":
            ConverterHelpers.ReadExtendedList<WeatherType>(retval.WeatherTypes, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICloudLayerGetter_Converter : JsonConverter<ICloudLayerGetter>
{
  public override ICloudLayerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICloudLayerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CloudLayer");
    writer.WritePropertyName("Alphas");
    JsonSerializer.Serialize(writer, value.Alphas, options);
    writer.WritePropertyName("Colors");
    JsonSerializer.Serialize(writer, value.Colors, options);
    writer.WritePropertyName("Enabled");
    JsonSerializer.Serialize(writer, value.Enabled, options);
    writer.WritePropertyName("XSpeed");
    JsonSerializer.Serialize(writer, value.XSpeed, options);
    writer.WritePropertyName("YSpeed");
    JsonSerializer.Serialize(writer, value.YSpeed, options);
    writer.WriteEndObject();
  }
}
public class CloudLayer_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CloudLayer>
{
  private ICloudLayerGetter_Converter _getterConverter;
  public CloudLayer_Converter(ICloudLayerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CloudLayer value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICloudLayerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CloudLayer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CloudLayer();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Alphas":
            retval.Alphas = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherAlpha>(ref reader, options);
            break;
        case "Colors":
            retval.Colors = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "Enabled":
            retval.Enabled = JsonSerializer.Deserialize<Boolean?>(ref reader, options);
            break;
        case "XSpeed":
            retval.XSpeed = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "YSpeed":
            retval.YSpeed = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICollisionLayerGetter_Converter : JsonConverter<ICollisionLayerGetter>
{
  public override ICollisionLayerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICollisionLayerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CollisionLayer");
    if (value.CollidesWith != default)
    {
      writer.WritePropertyName("CollidesWith");
      writer.WriteStartArray();
      foreach (var itm in value.CollidesWith)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("CollidesWith");
    }
    writer.WritePropertyName("DebugColor");
    JsonSerializer.Serialize(writer, value.DebugColor, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class CollisionLayer_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CollisionLayer>
{
  private ICollisionLayerGetter_Converter _getterConverter;
  public CollisionLayer_Converter(ICollisionLayerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CollisionLayer value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICollisionLayerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CollisionLayer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CollisionLayer();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CollidesWith":
            ConverterHelpers.ReadFormLinkList<ICollisionLayerGetter>(retval.CollidesWith, ref reader);
            break;
        case "DebugColor":
            retval.DebugColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CollisionLayer.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Index":
            retval.Index = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IColorFrameGetter_Converter : JsonConverter<IColorFrameGetter>
{
  public override IColorFrameGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IColorFrameGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ColorFrame");
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("Time");
    JsonSerializer.Serialize(writer, value.Time, options);
    writer.WriteEndObject();
  }
}
public class ColorFrame_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ColorFrame>
{
  private IColorFrameGetter_Converter _getterConverter;
  public ColorFrame_Converter(IColorFrameGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ColorFrame value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IColorFrameGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ColorFrame Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ColorFrame();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Color":
            retval.Color = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Time":
            retval.Time = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IColorRecordGetter_Converter : JsonConverter<IColorRecordGetter>
{
  public override IColorRecordGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IColorRecordGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ColorRecord");
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Playable");
    JsonSerializer.Serialize(writer, value.Playable, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class ColorRecord_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ColorRecord>
{
  private IColorRecordGetter_Converter _getterConverter;
  public ColorRecord_Converter(IColorRecordGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ColorRecord value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IColorRecordGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ColorRecord Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ColorRecord();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Color":
            retval.Color = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Playable":
            retval.Playable = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICombatStyleGetter_Converter : JsonConverter<ICombatStyleGetter>
{
  public override ICombatStyleGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICombatStyleGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CombatStyle");
    writer.WritePropertyName("AvoidThreatChance");
    JsonSerializer.Serialize(writer, value.AvoidThreatChance, options);
    writer.WritePropertyName("CloseRange");
    JsonSerializer.Serialize(writer, value.CloseRange, options);
    writer.WritePropertyName("CSGDDataTypeState");
    JsonSerializer.Serialize(writer, value.CSGDDataTypeState, options);
    writer.WritePropertyName("CSMD");
    JsonSerializer.Serialize(writer, value.CSMD, options);
    writer.WritePropertyName("DefensiveMult");
    JsonSerializer.Serialize(writer, value.DefensiveMult, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EquipmentScoreMultMagic");
    JsonSerializer.Serialize(writer, value.EquipmentScoreMultMagic, options);
    writer.WritePropertyName("EquipmentScoreMultMelee");
    JsonSerializer.Serialize(writer, value.EquipmentScoreMultMelee, options);
    writer.WritePropertyName("EquipmentScoreMultRanged");
    JsonSerializer.Serialize(writer, value.EquipmentScoreMultRanged, options);
    writer.WritePropertyName("EquipmentScoreMultShout");
    JsonSerializer.Serialize(writer, value.EquipmentScoreMultShout, options);
    writer.WritePropertyName("EquipmentScoreMultStaff");
    JsonSerializer.Serialize(writer, value.EquipmentScoreMultStaff, options);
    writer.WritePropertyName("EquipmentScoreMultUnarmed");
    JsonSerializer.Serialize(writer, value.EquipmentScoreMultUnarmed, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Flight");
    JsonSerializer.Serialize(writer, value.Flight, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("GroupOffensiveMult");
    JsonSerializer.Serialize(writer, value.GroupOffensiveMult, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LongRangeStrafeMult");
    JsonSerializer.Serialize(writer, value.LongRangeStrafeMult, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Melee");
    JsonSerializer.Serialize(writer, value.Melee, options);
    writer.WritePropertyName("OffensiveMult");
    JsonSerializer.Serialize(writer, value.OffensiveMult, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class CombatStyle_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CombatStyle>
{
  private ICombatStyleGetter_Converter _getterConverter;
  public CombatStyle_Converter(ICombatStyleGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CombatStyle value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICombatStyleGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CombatStyle Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CombatStyle();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AvoidThreatChance":
            retval.AvoidThreatChance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CloseRange":
            retval.CloseRange = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CombatStyleCloseRange>(ref reader, options);
            break;
        case "CSGDDataTypeState":
            retval.CSGDDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CombatStyle.CSGDDataType>(ref reader, options);
            break;
        case "CSMD":
            break;
        case "DefensiveMult":
            retval.DefensiveMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EquipmentScoreMultMagic":
            retval.EquipmentScoreMultMagic = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EquipmentScoreMultMelee":
            retval.EquipmentScoreMultMelee = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EquipmentScoreMultRanged":
            retval.EquipmentScoreMultRanged = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EquipmentScoreMultShout":
            retval.EquipmentScoreMultShout = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EquipmentScoreMultStaff":
            retval.EquipmentScoreMultStaff = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EquipmentScoreMultUnarmed":
            retval.EquipmentScoreMultUnarmed = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "Flight":
            retval.Flight = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CombatStyleFlight>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "GroupOffensiveMult":
            retval.GroupOffensiveMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LongRangeStrafeMult":
            retval.LongRangeStrafeMult = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CombatStyle.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Melee":
            retval.Melee = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CombatStyleMelee>(ref reader, options);
            break;
        case "OffensiveMult":
            retval.OffensiveMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICombatStyleCloseRangeGetter_Converter : JsonConverter<ICombatStyleCloseRangeGetter>
{
  public override ICombatStyleCloseRangeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICombatStyleCloseRangeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CombatStyleCloseRange");
    writer.WritePropertyName("CircleMult");
    JsonSerializer.Serialize(writer, value.CircleMult, options);
    writer.WritePropertyName("FallbackMult");
    JsonSerializer.Serialize(writer, value.FallbackMult, options);
    writer.WritePropertyName("FlankDistance");
    JsonSerializer.Serialize(writer, value.FlankDistance, options);
    writer.WritePropertyName("StalkTime");
    JsonSerializer.Serialize(writer, value.StalkTime, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class CombatStyleCloseRange_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CombatStyleCloseRange>
{
  private ICombatStyleCloseRangeGetter_Converter _getterConverter;
  public CombatStyleCloseRange_Converter(ICombatStyleCloseRangeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CombatStyleCloseRange value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICombatStyleCloseRangeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CombatStyleCloseRange Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CombatStyleCloseRange();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CircleMult":
            retval.CircleMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FallbackMult":
            retval.FallbackMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FlankDistance":
            retval.FlankDistance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "StalkTime":
            retval.StalkTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CombatStyleCloseRange.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICombatStyleFlightGetter_Converter : JsonConverter<ICombatStyleFlightGetter>
{
  public override ICombatStyleFlightGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICombatStyleFlightGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CombatStyleFlight");
    writer.WritePropertyName("DiveBombChance");
    JsonSerializer.Serialize(writer, value.DiveBombChance, options);
    writer.WritePropertyName("FlyingAttackChance");
    JsonSerializer.Serialize(writer, value.FlyingAttackChance, options);
    writer.WritePropertyName("GroundAttackChance");
    JsonSerializer.Serialize(writer, value.GroundAttackChance, options);
    writer.WritePropertyName("GroundAttackTime");
    JsonSerializer.Serialize(writer, value.GroundAttackTime, options);
    writer.WritePropertyName("HoverChance");
    JsonSerializer.Serialize(writer, value.HoverChance, options);
    writer.WritePropertyName("HoverTime");
    JsonSerializer.Serialize(writer, value.HoverTime, options);
    writer.WritePropertyName("PerchAttackChance");
    JsonSerializer.Serialize(writer, value.PerchAttackChance, options);
    writer.WritePropertyName("PerchAttackTime");
    JsonSerializer.Serialize(writer, value.PerchAttackTime, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class CombatStyleFlight_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CombatStyleFlight>
{
  private ICombatStyleFlightGetter_Converter _getterConverter;
  public CombatStyleFlight_Converter(ICombatStyleFlightGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CombatStyleFlight value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICombatStyleFlightGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CombatStyleFlight Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CombatStyleFlight();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DiveBombChance":
            retval.DiveBombChance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FlyingAttackChance":
            retval.FlyingAttackChance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "GroundAttackChance":
            retval.GroundAttackChance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "GroundAttackTime":
            retval.GroundAttackTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "HoverChance":
            retval.HoverChance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "HoverTime":
            retval.HoverTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "PerchAttackChance":
            retval.PerchAttackChance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "PerchAttackTime":
            retval.PerchAttackTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CombatStyleFlight.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICombatStyleMeleeGetter_Converter : JsonConverter<ICombatStyleMeleeGetter>
{
  public override ICombatStyleMeleeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICombatStyleMeleeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CombatStyleMelee");
    writer.WritePropertyName("AttackStaggeredMult");
    JsonSerializer.Serialize(writer, value.AttackStaggeredMult, options);
    writer.WritePropertyName("BashAttackMult");
    JsonSerializer.Serialize(writer, value.BashAttackMult, options);
    writer.WritePropertyName("BashMult");
    JsonSerializer.Serialize(writer, value.BashMult, options);
    writer.WritePropertyName("BashPowerAttackMult");
    JsonSerializer.Serialize(writer, value.BashPowerAttackMult, options);
    writer.WritePropertyName("BashRecoilMult");
    JsonSerializer.Serialize(writer, value.BashRecoilMult, options);
    writer.WritePropertyName("PowerAttackBlockingMult");
    JsonSerializer.Serialize(writer, value.PowerAttackBlockingMult, options);
    writer.WritePropertyName("PowerAttackStaggeredMult");
    JsonSerializer.Serialize(writer, value.PowerAttackStaggeredMult, options);
    writer.WritePropertyName("SpecialAttackMult");
    JsonSerializer.Serialize(writer, value.SpecialAttackMult, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class CombatStyleMelee_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CombatStyleMelee>
{
  private ICombatStyleMeleeGetter_Converter _getterConverter;
  public CombatStyleMelee_Converter(ICombatStyleMeleeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CombatStyleMelee value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICombatStyleMeleeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CombatStyleMelee Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CombatStyleMelee();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AttackStaggeredMult":
            retval.AttackStaggeredMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BashAttackMult":
            retval.BashAttackMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BashMult":
            retval.BashMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BashPowerAttackMult":
            retval.BashPowerAttackMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BashRecoilMult":
            retval.BashRecoilMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "PowerAttackBlockingMult":
            retval.PowerAttackBlockingMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "PowerAttackStaggeredMult":
            retval.PowerAttackStaggeredMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SpecialAttackMult":
            retval.SpecialAttackMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CombatStyleMelee.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IConditionFloatGetter_Converter : JsonConverter<IConditionFloatGetter>
{
  public override IConditionFloatGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IConditionFloatGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ConditionFloat");
    writer.WritePropertyName("CompareOperator");
    JsonSerializer.Serialize(writer, value.CompareOperator, options);
    writer.WritePropertyName("ComparisonValue");
    JsonSerializer.Serialize(writer, value.ComparisonValue, options);
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Unknown1");
    JsonSerializer.Serialize(writer, value.Unknown1, options);
    writer.WriteEndObject();
  }
}
public class ConditionFloat_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ConditionFloat>
{
  private IConditionFloatGetter_Converter _getterConverter;
  public ConditionFloat_Converter(IConditionFloatGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ConditionFloat value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IConditionFloatGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ConditionFloat Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ConditionFloat();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CompareOperator":
            retval.CompareOperator = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CompareOperator>(ref reader, options);
            break;
        case "ComparisonValue":
            retval.ComparisonValue = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ConditionData>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Condition.Flag>(ref reader, options);
            break;
        case "Unknown1":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IConditionGlobalGetter_Converter : JsonConverter<IConditionGlobalGetter>
{
  public override IConditionGlobalGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IConditionGlobalGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ConditionGlobal");
    writer.WritePropertyName("CompareOperator");
    JsonSerializer.Serialize(writer, value.CompareOperator, options);
    writer.WritePropertyName("ComparisonValue");
    JsonSerializer.Serialize(writer, value.ComparisonValue, options);
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Unknown1");
    JsonSerializer.Serialize(writer, value.Unknown1, options);
    writer.WriteEndObject();
  }
}
public class ConditionGlobal_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ConditionGlobal>
{
  private IConditionGlobalGetter_Converter _getterConverter;
  public ConditionGlobal_Converter(IConditionGlobalGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ConditionGlobal value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IConditionGlobalGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ConditionGlobal Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ConditionGlobal();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CompareOperator":
            retval.CompareOperator = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CompareOperator>(ref reader, options);
            break;
        case "ComparisonValue":
            ConverterHelpers.ReadFormLink<IGlobalGetter>(retval.ComparisonValue, ref reader);
            break;
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ConditionData>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Condition.Flag>(ref reader, options);
            break;
        case "Unknown1":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IConstructibleObjectGetter_Converter : JsonConverter<IConstructibleObjectGetter>
{
  public override IConstructibleObjectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IConstructibleObjectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ConstructibleObject");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("CreatedObject");
    JsonSerializer.Serialize(writer, value.CreatedObject, options);
    writer.WritePropertyName("CreatedObjectCount");
    JsonSerializer.Serialize(writer, value.CreatedObjectCount, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Items != default)
    {
      writer.WritePropertyName("Items");
      writer.WriteStartArray();
      foreach (var itm in value.Items)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Items");
    }
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("WorkbenchKeyword");
    JsonSerializer.Serialize(writer, value.WorkbenchKeyword, options);
    writer.WriteEndObject();
  }
}
public class ConstructibleObject_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ConstructibleObject>
{
  private IConstructibleObjectGetter_Converter _getterConverter;
  public ConstructibleObject_Converter(IConstructibleObjectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ConstructibleObject value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IConstructibleObjectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ConstructibleObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ConstructibleObject();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "CreatedObject":
            ConverterHelpers.ReadFormLinkNullable<IConstructibleGetter>(retval.CreatedObject, ref reader);
            break;
        case "CreatedObjectCount":
            retval.CreatedObjectCount = JsonSerializer.Deserialize<UInt16?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Items":
            ConverterHelpers.ReadExtendedList<ContainerEntry>(retval.Items, ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "WorkbenchKeyword":
            ConverterHelpers.ReadFormLinkNullable<IKeywordGetter>(retval.WorkbenchKeyword, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IContainerGetter_Converter : JsonConverter<IContainerGetter>
{
  public override IContainerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IContainerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Container");
    writer.WritePropertyName("CloseSound");
    JsonSerializer.Serialize(writer, value.CloseSound, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Items != default)
    {
      writer.WritePropertyName("Items");
      writer.WriteStartArray();
      foreach (var itm in value.Items)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Items");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("OpenSound");
    JsonSerializer.Serialize(writer, value.OpenSound, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class Container_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Container>
{
  private IContainerGetter_Converter _getterConverter;
  public Container_Converter(IContainerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Container value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IContainerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Container Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Container();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CloseSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.CloseSound, ref reader);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Container.DATADataType>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Container.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Items":
            ConverterHelpers.ReadExtendedList<ContainerEntry>(retval.Items, ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Container.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "OpenSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.OpenSound, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IContainerEntryGetter_Converter : JsonConverter<IContainerEntryGetter>
{
  public override IContainerEntryGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IContainerEntryGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ContainerEntry");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WriteEndObject();
  }
}
public class ContainerEntry_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ContainerEntry>
{
  private IContainerEntryGetter_Converter _getterConverter;
  public ContainerEntry_Converter(IContainerEntryGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ContainerEntry value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IContainerEntryGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ContainerEntry Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ContainerEntry();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ExtraData>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IContainerItemGetter_Converter : JsonConverter<IContainerItemGetter>
{
  public override IContainerItemGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IContainerItemGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ContainerItem");
    writer.WritePropertyName("Count");
    JsonSerializer.Serialize(writer, value.Count, options);
    writer.WriteEndObject();
  }
}
public class ContainerItem_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ContainerItem>
{
  private IContainerItemGetter_Converter _getterConverter;
  public ContainerItem_Converter(IContainerItemGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ContainerItem value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IContainerItemGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ContainerItem Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ContainerItem();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Count":
            retval.Count = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICreateReferenceToObjectGetter_Converter : JsonConverter<ICreateReferenceToObjectGetter>
{
  public override ICreateReferenceToObjectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICreateReferenceToObjectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CreateReferenceToObject");
    writer.WritePropertyName("ALCADataTypeState");
    JsonSerializer.Serialize(writer, value.ALCADataTypeState, options);
    writer.WritePropertyName("AliasIndex");
    JsonSerializer.Serialize(writer, value.AliasIndex, options);
    writer.WritePropertyName("Create");
    JsonSerializer.Serialize(writer, value.Create, options);
    writer.WritePropertyName("Level");
    JsonSerializer.Serialize(writer, value.Level, options);
    writer.WritePropertyName("Object");
    JsonSerializer.Serialize(writer, value.Object, options);
    writer.WriteEndObject();
  }
}
public class CreateReferenceToObject_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CreateReferenceToObject>
{
  private ICreateReferenceToObjectGetter_Converter _getterConverter;
  public CreateReferenceToObject_Converter(ICreateReferenceToObjectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CreateReferenceToObject value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICreateReferenceToObjectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CreateReferenceToObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CreateReferenceToObject();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ALCADataTypeState":
            retval.ALCADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CreateReferenceToObject.ALCADataType>(ref reader, options);
            break;
        case "AliasIndex":
            retval.AliasIndex = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Create":
            retval.Create = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CreateReferenceToObject.CreateEnum>(ref reader, options);
            break;
        case "Level":
            retval.Level = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Level>(ref reader, options);
            break;
        case "Object":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.Object, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICrimeValuesGetter_Converter : JsonConverter<ICrimeValuesGetter>
{
  public override ICrimeValuesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICrimeValuesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CrimeValues");
    writer.WritePropertyName("Arrest");
    JsonSerializer.Serialize(writer, value.Arrest, options);
    writer.WritePropertyName("Assault");
    JsonSerializer.Serialize(writer, value.Assault, options);
    writer.WritePropertyName("AttackOnSight");
    JsonSerializer.Serialize(writer, value.AttackOnSight, options);
    writer.WritePropertyName("Escape");
    JsonSerializer.Serialize(writer, value.Escape, options);
    writer.WritePropertyName("Murder");
    JsonSerializer.Serialize(writer, value.Murder, options);
    writer.WritePropertyName("Pickpocket");
    JsonSerializer.Serialize(writer, value.Pickpocket, options);
    writer.WritePropertyName("StealMult");
    JsonSerializer.Serialize(writer, value.StealMult, options);
    writer.WritePropertyName("Trespass");
    JsonSerializer.Serialize(writer, value.Trespass, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WritePropertyName("Werewolf");
    JsonSerializer.Serialize(writer, value.Werewolf, options);
    writer.WriteEndObject();
  }
}
public class CrimeValues_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CrimeValues>
{
  private ICrimeValuesGetter_Converter _getterConverter;
  public CrimeValues_Converter(ICrimeValuesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CrimeValues value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICrimeValuesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CrimeValues Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CrimeValues();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Arrest":
            retval.Arrest = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Assault":
            retval.Assault = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "AttackOnSight":
            retval.AttackOnSight = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Escape":
            retval.Escape = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Murder":
            retval.Murder = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Pickpocket":
            retval.Pickpocket = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "StealMult":
            retval.StealMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Trespass":
            retval.Trespass = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CrimeValues.VersioningBreaks>(ref reader, options);
            break;
        case "Werewolf":
            retval.Werewolf = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ICriticalDataGetter_Converter : JsonConverter<ICriticalDataGetter>
{
  public override ICriticalDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ICriticalDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "CriticalData");
    writer.WritePropertyName("Damage");
    JsonSerializer.Serialize(writer, value.Damage, options);
    writer.WritePropertyName("Effect");
    JsonSerializer.Serialize(writer, value.Effect, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("PercentMult");
    JsonSerializer.Serialize(writer, value.PercentMult, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WritePropertyName("Unused2");
    JsonSerializer.Serialize(writer, value.Unused2, options);
    writer.WritePropertyName("Unused3");
    JsonSerializer.Serialize(writer, value.Unused3, options);
    writer.WritePropertyName("Unused4");
    JsonSerializer.Serialize(writer, value.Unused4, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class CriticalData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.CriticalData>
{
  private ICriticalDataGetter_Converter _getterConverter;
  public CriticalData_Converter(ICriticalDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.CriticalData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ICriticalDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.CriticalData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.CriticalData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Damage":
            retval.Damage = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Effect":
            ConverterHelpers.ReadFormLink<ISpellGetter>(retval.Effect, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CriticalData.Flag>(ref reader, options);
            break;
        case "PercentMult":
            retval.PercentMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unused":
            retval.Unused = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Unused2":
            break;
        case "Unused3":
            retval.Unused3 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unused4":
            retval.Unused4 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CriticalData.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDebrisGetter_Converter : JsonConverter<IDebrisGetter>
{
  public override IDebrisGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDebrisGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Debris");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.Models != default)
    {
      writer.WritePropertyName("Models");
      writer.WriteStartArray();
      foreach (var itm in value.Models)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Models");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Debris_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Debris>
{
  private IDebrisGetter_Converter _getterConverter;
  public Debris_Converter(IDebrisGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Debris value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDebrisGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Debris Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Debris();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Models":
            ConverterHelpers.ReadExtendedList<DebrisModel>(retval.Models, ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDebrisModelGetter_Converter : JsonConverter<IDebrisModelGetter>
{
  public override IDebrisModelGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDebrisModelGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DebrisModel");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("ModelFilename");
    JsonSerializer.Serialize(writer, value.ModelFilename, options);
    writer.WritePropertyName("Percentage");
    JsonSerializer.Serialize(writer, value.Percentage, options);
    writer.WritePropertyName("TextureFileHashes");
    JsonSerializer.Serialize(writer, value.TextureFileHashes, options);
    writer.WriteEndObject();
  }
}
public class DebrisModel_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DebrisModel>
{
  private IDebrisModelGetter_Converter _getterConverter;
  public DebrisModel_Converter(IDebrisModelGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DebrisModel value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDebrisModelGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DebrisModel Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DebrisModel();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DebrisModel.DATADataType>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DebrisModel.Flag>(ref reader, options);
            break;
        case "ModelFilename":
            retval.ModelFilename = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Percentage":
            retval.Percentage = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "TextureFileHashes":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDecalGetter_Converter : JsonConverter<IDecalGetter>
{
  public override IDecalGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDecalGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Decal");
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("Depth");
    JsonSerializer.Serialize(writer, value.Depth, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("MaxHeight");
    JsonSerializer.Serialize(writer, value.MaxHeight, options);
    writer.WritePropertyName("MaxWidth");
    JsonSerializer.Serialize(writer, value.MaxWidth, options);
    writer.WritePropertyName("MinHeight");
    JsonSerializer.Serialize(writer, value.MinHeight, options);
    writer.WritePropertyName("MinWidth");
    JsonSerializer.Serialize(writer, value.MinWidth, options);
    writer.WritePropertyName("ParallaxPasses");
    JsonSerializer.Serialize(writer, value.ParallaxPasses, options);
    writer.WritePropertyName("ParallaxScale");
    JsonSerializer.Serialize(writer, value.ParallaxScale, options);
    writer.WritePropertyName("Shininess");
    JsonSerializer.Serialize(writer, value.Shininess, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class Decal_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Decal>
{
  private IDecalGetter_Converter _getterConverter;
  public Decal_Converter(IDecalGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Decal value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDecalGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Decal Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Decal();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Color":
            retval.Color = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Depth":
            retval.Depth = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Decal.Flag>(ref reader, options);
            break;
        case "MaxHeight":
            retval.MaxHeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MaxWidth":
            retval.MaxWidth = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MinHeight":
            retval.MinHeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MinWidth":
            retval.MinWidth = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParallaxPasses":
            retval.ParallaxPasses = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "ParallaxScale":
            retval.ParallaxScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Shininess":
            retval.Shininess = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDefaultObjectGetter_Converter : JsonConverter<IDefaultObjectGetter>
{
  public override IDefaultObjectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDefaultObjectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DefaultObject");
    writer.WritePropertyName("Object");
    JsonSerializer.Serialize(writer, value.Object, options);
    writer.WritePropertyName("Use");
    JsonSerializer.Serialize(writer, value.Use, options);
    writer.WriteEndObject();
  }
}
public class DefaultObject_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DefaultObject>
{
  private IDefaultObjectGetter_Converter _getterConverter;
  public DefaultObject_Converter(IDefaultObjectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DefaultObject value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDefaultObjectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DefaultObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DefaultObject();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Object":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.Object, ref reader);
            break;
        case "Use":
            retval.Use = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.RecordType>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDefaultObjectManagerGetter_Converter : JsonConverter<IDefaultObjectManagerGetter>
{
  public override IDefaultObjectManagerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDefaultObjectManagerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DefaultObjectManager");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.Objects != default)
    {
      writer.WritePropertyName("Objects");
      writer.WriteStartArray();
      foreach (var itm in value.Objects)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Objects");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class DefaultObjectManager_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DefaultObjectManager>
{
  private IDefaultObjectManagerGetter_Converter _getterConverter;
  public DefaultObjectManager_Converter(IDefaultObjectManagerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DefaultObjectManager value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDefaultObjectManagerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DefaultObjectManager Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DefaultObjectManager();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Objects":
            ConverterHelpers.ReadExtendedList<DefaultObject>(retval.Objects, ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDestructableDataGetter_Converter : JsonConverter<IDestructableDataGetter>
{
  public override IDestructableDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDestructableDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DestructableData");
    writer.WritePropertyName("DESTCount");
    JsonSerializer.Serialize(writer, value.DESTCount, options);
    writer.WritePropertyName("Health");
    JsonSerializer.Serialize(writer, value.Health, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("VATSTargetable");
    JsonSerializer.Serialize(writer, value.VATSTargetable, options);
    writer.WriteEndObject();
  }
}
public class DestructableData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DestructableData>
{
  private IDestructableDataGetter_Converter _getterConverter;
  public DestructableData_Converter(IDestructableDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DestructableData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDestructableDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DestructableData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DestructableData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DESTCount":
            retval.DESTCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Health":
            retval.Health = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "VATSTargetable":
            retval.VATSTargetable = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDestructibleGetter_Converter : JsonConverter<IDestructibleGetter>
{
  public override IDestructibleGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDestructibleGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Destructible");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    if (value.Stages != default)
    {
      writer.WritePropertyName("Stages");
      writer.WriteStartArray();
      foreach (var itm in value.Stages)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Stages");
    }
    writer.WriteEndObject();
  }
}
public class Destructible_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Destructible>
{
  private IDestructibleGetter_Converter _getterConverter;
  public Destructible_Converter(IDestructibleGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Destructible value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDestructibleGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Destructible Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Destructible();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DestructableData>(ref reader, options);
            break;
        case "Stages":
            ConverterHelpers.ReadExtendedList<DestructionStage>(retval.Stages, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDestructionStageGetter_Converter : JsonConverter<IDestructionStageGetter>
{
  public override IDestructionStageGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDestructionStageGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DestructionStage");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WriteEndObject();
  }
}
public class DestructionStage_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DestructionStage>
{
  private IDestructionStageGetter_Converter _getterConverter;
  public DestructionStage_Converter(IDestructionStageGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DestructionStage value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDestructionStageGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DestructionStage Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DestructionStage();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DestructionStageData>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDestructionStageDataGetter_Converter : JsonConverter<IDestructionStageDataGetter>
{
  public override IDestructionStageDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDestructionStageDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DestructionStageData");
    writer.WritePropertyName("Debris");
    JsonSerializer.Serialize(writer, value.Debris, options);
    writer.WritePropertyName("DebrisCount");
    JsonSerializer.Serialize(writer, value.DebrisCount, options);
    writer.WritePropertyName("Explosion");
    JsonSerializer.Serialize(writer, value.Explosion, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("HealthPercent");
    JsonSerializer.Serialize(writer, value.HealthPercent, options);
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WritePropertyName("ModelDamageStage");
    JsonSerializer.Serialize(writer, value.ModelDamageStage, options);
    writer.WritePropertyName("SelfDamagePerSecond");
    JsonSerializer.Serialize(writer, value.SelfDamagePerSecond, options);
    writer.WriteEndObject();
  }
}
public class DestructionStageData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DestructionStageData>
{
  private IDestructionStageDataGetter_Converter _getterConverter;
  public DestructionStageData_Converter(IDestructionStageDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DestructionStageData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDestructionStageDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DestructionStageData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DestructionStageData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Debris":
            ConverterHelpers.ReadFormLink<IDebrisGetter>(retval.Debris, ref reader);
            break;
        case "DebrisCount":
            retval.DebrisCount = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Explosion":
            ConverterHelpers.ReadFormLink<IExplosionGetter>(retval.Explosion, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DestructionStageData.Flag>(ref reader, options);
            break;
        case "HealthPercent":
            retval.HealthPercent = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Index":
            retval.Index = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "ModelDamageStage":
            retval.ModelDamageStage = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "SelfDamagePerSecond":
            retval.SelfDamagePerSecond = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDialogBranchGetter_Converter : JsonConverter<IDialogBranchGetter>
{
  public override IDialogBranchGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDialogBranchGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DialogBranch");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Quest");
    JsonSerializer.Serialize(writer, value.Quest, options);
    writer.WritePropertyName("StartingTopic");
    JsonSerializer.Serialize(writer, value.StartingTopic, options);
    writer.WritePropertyName("TNAM");
    JsonSerializer.Serialize(writer, value.TNAM, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class DialogBranch_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DialogBranch>
{
  private IDialogBranchGetter_Converter _getterConverter;
  public DialogBranch_Converter(IDialogBranchGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DialogBranch value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDialogBranchGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DialogBranch Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DialogBranch();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Quest":
            ConverterHelpers.ReadFormLink<IQuestGetter>(retval.Quest, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "StartingTopic":
            ConverterHelpers.ReadFormLinkNullable<IDialogTopicGetter>(retval.StartingTopic, ref reader);
            break;
        case "TNAM":
            retval.TNAM = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDialogResponseGetter_Converter : JsonConverter<IDialogResponseGetter>
{
  public override IDialogResponseGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDialogResponseGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DialogResponse");
    writer.WritePropertyName("Edits");
    JsonSerializer.Serialize(writer, value.Edits, options);
    writer.WritePropertyName("Emotion");
    JsonSerializer.Serialize(writer, value.Emotion, options);
    writer.WritePropertyName("EmotionValue");
    JsonSerializer.Serialize(writer, value.EmotionValue, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("ListenerIdleAnimation");
    JsonSerializer.Serialize(writer, value.ListenerIdleAnimation, options);
    writer.WritePropertyName("ResponseNumber");
    JsonSerializer.Serialize(writer, value.ResponseNumber, options);
    writer.WritePropertyName("ScriptNotes");
    JsonSerializer.Serialize(writer, value.ScriptNotes, options);
    writer.WritePropertyName("Sound");
    JsonSerializer.Serialize(writer, value.Sound, options);
    writer.WritePropertyName("SpeakerIdleAnimation");
    JsonSerializer.Serialize(writer, value.SpeakerIdleAnimation, options);
    writer.WritePropertyName("Text");
    JsonSerializer.Serialize(writer, value.Text, options);
    writer.WritePropertyName("TRDTDataTypeState");
    JsonSerializer.Serialize(writer, value.TRDTDataTypeState, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WritePropertyName("Unknown3");
    JsonSerializer.Serialize(writer, value.Unknown3, options);
    writer.WriteEndObject();
  }
}
public class DialogResponse_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DialogResponse>
{
  private IDialogResponseGetter_Converter _getterConverter;
  public DialogResponse_Converter(IDialogResponseGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DialogResponse value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDialogResponseGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DialogResponse Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DialogResponse();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Edits":
            retval.Edits = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emotion":
            retval.Emotion = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Emotion>(ref reader, options);
            break;
        case "EmotionValue":
            retval.EmotionValue = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DialogResponse.Flag>(ref reader, options);
            break;
        case "ListenerIdleAnimation":
            ConverterHelpers.ReadFormLinkNullable<IIdleAnimationGetter>(retval.ListenerIdleAnimation, ref reader);
            break;
        case "ResponseNumber":
            retval.ResponseNumber = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "ScriptNotes":
            retval.ScriptNotes = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Sound":
            ConverterHelpers.ReadFormLink<ISoundDescriptorGetter>(retval.Sound, ref reader);
            break;
        case "SpeakerIdleAnimation":
            ConverterHelpers.ReadFormLinkNullable<IIdleAnimationGetter>(retval.SpeakerIdleAnimation, ref reader);
            break;
        case "Text":
            retval.Text = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "TRDTDataTypeState":
            retval.TRDTDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DialogResponse.TRDTDataType>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown2":
            break;
        case "Unknown3":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDialogResponseFlagsGetter_Converter : JsonConverter<IDialogResponseFlagsGetter>
{
  public override IDialogResponseFlagsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDialogResponseFlagsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DialogResponseFlags");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("ResetHours");
    JsonSerializer.Serialize(writer, value.ResetHours, options);
    writer.WriteEndObject();
  }
}
public class DialogResponseFlags_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DialogResponseFlags>
{
  private IDialogResponseFlagsGetter_Converter _getterConverter;
  public DialogResponseFlags_Converter(IDialogResponseFlagsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DialogResponseFlags value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDialogResponseFlagsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DialogResponseFlags Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DialogResponseFlags();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DialogResponses.Flag>(ref reader, options);
            break;
        case "ResetHours":
            retval.ResetHours = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDialogResponsesGetter_Converter : JsonConverter<IDialogResponsesGetter>
{
  public override IDialogResponsesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDialogResponsesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DialogResponses");
    writer.WritePropertyName("AudioOutputOverride");
    JsonSerializer.Serialize(writer, value.AudioOutputOverride, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("DATA");
    JsonSerializer.Serialize(writer, value.DATA, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FavorLevel");
    JsonSerializer.Serialize(writer, value.FavorLevel, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.LinkTo != default)
    {
      writer.WritePropertyName("LinkTo");
      writer.WriteStartArray();
      foreach (var itm in value.LinkTo)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkTo");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("PreviousDialog");
    JsonSerializer.Serialize(writer, value.PreviousDialog, options);
    writer.WritePropertyName("Prompt");
    JsonSerializer.Serialize(writer, value.Prompt, options);
    writer.WritePropertyName("ResponseData");
    JsonSerializer.Serialize(writer, value.ResponseData, options);
    if (value.Responses != default)
    {
      writer.WritePropertyName("Responses");
      writer.WriteStartArray();
      foreach (var itm in value.Responses)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Responses");
    }
    writer.WritePropertyName("Speaker");
    JsonSerializer.Serialize(writer, value.Speaker, options);
    writer.WritePropertyName("Topic");
    JsonSerializer.Serialize(writer, value.Topic, options);
    if (value.UnknownData != default)
    {
      writer.WritePropertyName("UnknownData");
      writer.WriteStartArray();
      foreach (var itm in value.UnknownData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("UnknownData");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("WalkAwayTopic");
    JsonSerializer.Serialize(writer, value.WalkAwayTopic, options);
    writer.WriteEndObject();
  }
}
public class DialogResponses_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DialogResponses>
{
  private IDialogResponsesGetter_Converter _getterConverter;
  public DialogResponses_Converter(IDialogResponsesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DialogResponses value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDialogResponsesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DialogResponses Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DialogResponses();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AudioOutputOverride":
            ConverterHelpers.ReadFormLinkNullable<ISoundOutputModelGetter>(retval.AudioOutputOverride, ref reader);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "DATA":
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FavorLevel":
            retval.FavorLevel = JsonSerializer.Deserialize<FavorLevel?>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DialogResponseFlags>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LinkTo":
            ConverterHelpers.ReadFormLinkList<IDialogGetter>(retval.LinkTo, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DialogResponses.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "PreviousDialog":
            ConverterHelpers.ReadFormLinkNullable<IDialogResponsesGetter>(retval.PreviousDialog, ref reader);
            break;
        case "Prompt":
            retval.Prompt = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ResponseData":
            ConverterHelpers.ReadFormLinkNullable<IDialogResponsesGetter>(retval.ResponseData, ref reader);
            break;
        case "Responses":
            ConverterHelpers.ReadExtendedList<DialogResponse>(retval.Responses, ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Speaker":
            ConverterHelpers.ReadFormLinkNullable<INpcGetter>(retval.Speaker, ref reader);
            break;
        case "Topic":
            ConverterHelpers.ReadFormLinkNullable<IDialogTopicGetter>(retval.Topic, ref reader);
            break;
        case "UnknownData":
            ConverterHelpers.ReadExtendedList<DialogResponsesUnknownData>(retval.UnknownData, ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DialogResponsesAdapter>(ref reader, options);
            break;
        case "WalkAwayTopic":
            ConverterHelpers.ReadFormLinkNullable<IDialogTopicGetter>(retval.WalkAwayTopic, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDialogResponsesAdapterGetter_Converter : JsonConverter<IDialogResponsesAdapterGetter>
{
  public override IDialogResponsesAdapterGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDialogResponsesAdapterGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DialogResponsesAdapter");
    writer.WritePropertyName("ObjectFormat");
    JsonSerializer.Serialize(writer, value.ObjectFormat, options);
    writer.WritePropertyName("ScriptFragments");
    JsonSerializer.Serialize(writer, value.ScriptFragments, options);
    if (value.Scripts != default)
    {
      writer.WritePropertyName("Scripts");
      writer.WriteStartArray();
      foreach (var itm in value.Scripts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Scripts");
    }
    writer.WritePropertyName("Version");
    JsonSerializer.Serialize(writer, value.Version, options);
    writer.WriteEndObject();
  }
}
public class DialogResponsesAdapter_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DialogResponsesAdapter>
{
  private IDialogResponsesAdapterGetter_Converter _getterConverter;
  public DialogResponsesAdapter_Converter(IDialogResponsesAdapterGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DialogResponsesAdapter value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDialogResponsesAdapterGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DialogResponsesAdapter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DialogResponsesAdapter();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ObjectFormat":
            retval.ObjectFormat = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "ScriptFragments":
            retval.ScriptFragments = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptFragments>(ref reader, options);
            break;
        case "Scripts":
            ConverterHelpers.ReadExtendedList<ScriptEntry>(retval.Scripts, ref reader, options);
            break;
        case "Version":
            retval.Version = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDialogResponsesUnknownDataGetter_Converter : JsonConverter<IDialogResponsesUnknownDataGetter>
{
  public override IDialogResponsesUnknownDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDialogResponsesUnknownDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DialogResponsesUnknownData");
    writer.WritePropertyName("NEXT");
    JsonSerializer.Serialize(writer, value.NEXT, options);
    writer.WritePropertyName("QNAM");
    JsonSerializer.Serialize(writer, value.QNAM, options);
    writer.WritePropertyName("SCHR");
    JsonSerializer.Serialize(writer, value.SCHR, options);
    writer.WriteEndObject();
  }
}
public class DialogResponsesUnknownData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DialogResponsesUnknownData>
{
  private IDialogResponsesUnknownDataGetter_Converter _getterConverter;
  public DialogResponsesUnknownData_Converter(IDialogResponsesUnknownDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DialogResponsesUnknownData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDialogResponsesUnknownDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DialogResponsesUnknownData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DialogResponsesUnknownData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "NEXT":
            retval.NEXT = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "QNAM":
            ConverterHelpers.ReadFormLinkNullable<ISkyrimMajorRecordGetter>(retval.QNAM, ref reader);
            break;
        case "SCHR":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDialogTopicGetter_Converter : JsonConverter<IDialogTopicGetter>
{
  public override IDialogTopicGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDialogTopicGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DialogTopic");
    writer.WritePropertyName("Branch");
    JsonSerializer.Serialize(writer, value.Branch, options);
    writer.WritePropertyName("Category");
    JsonSerializer.Serialize(writer, value.Category, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("Quest");
    JsonSerializer.Serialize(writer, value.Quest, options);
    if (value.Responses != default)
    {
      writer.WritePropertyName("Responses");
      writer.WriteStartArray();
      foreach (var itm in value.Responses)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Responses");
    }
    writer.WritePropertyName("Subtype");
    JsonSerializer.Serialize(writer, value.Subtype, options);
    writer.WritePropertyName("SubtypeName");
    JsonSerializer.Serialize(writer, value.SubtypeName, options);
    writer.WritePropertyName("Timestamp");
    JsonSerializer.Serialize(writer, value.Timestamp, options);
    writer.WritePropertyName("TopicFlags");
    JsonSerializer.Serialize(writer, value.TopicFlags, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class DialogTopic_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DialogTopic>
{
  private IDialogTopicGetter_Converter _getterConverter;
  public DialogTopic_Converter(IDialogTopicGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DialogTopic value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDialogTopicGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DialogTopic Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DialogTopic();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Branch":
            ConverterHelpers.ReadFormLinkNullable<IDialogBranchGetter>(retval.Branch, ref reader);
            break;
        case "Category":
            retval.Category = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DialogTopic.CategoryEnum>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DialogTopic.DATADataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Quest":
            ConverterHelpers.ReadFormLinkNullable<IQuestGetter>(retval.Quest, ref reader);
            break;
        case "Responses":
            ConverterHelpers.ReadExtendedList<DialogResponses>(retval.Responses, ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Subtype":
            retval.Subtype = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DialogTopic.SubtypeEnum>(ref reader, options);
            break;
        case "SubtypeName":
            retval.SubtypeName = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.RecordType>(ref reader, options);
            break;
        case "Timestamp":
            retval.Timestamp = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "TopicFlags":
            retval.TopicFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DialogTopic.TopicFlag>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDialogViewGetter_Converter : JsonConverter<IDialogViewGetter>
{
  public override IDialogViewGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDialogViewGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DialogView");
    if (value.Branches != default)
    {
      writer.WritePropertyName("Branches");
      writer.WriteStartArray();
      foreach (var itm in value.Branches)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Branches");
    }
    writer.WritePropertyName("DNAM");
    JsonSerializer.Serialize(writer, value.DNAM, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("ENAM");
    JsonSerializer.Serialize(writer, value.ENAM, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Quest");
    JsonSerializer.Serialize(writer, value.Quest, options);
    if (value.TNAMs != default)
    {
      writer.WritePropertyName("TNAMs");
      writer.WriteStartArray();
      foreach (var itm in value.TNAMs)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("TNAMs");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class DialogView_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DialogView>
{
  private IDialogViewGetter_Converter _getterConverter;
  public DialogView_Converter(IDialogViewGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DialogView value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDialogViewGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DialogView Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DialogView();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Branches":
            ConverterHelpers.ReadFormLinkList<IDialogBranchGetter>(retval.Branches, ref reader);
            break;
        case "DNAM":
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ENAM":
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Quest":
            ConverterHelpers.ReadFormLink<IQuestGetter>(retval.Quest, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TNAMs":
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDoorGetter_Converter : JsonConverter<IDoorGetter>
{
  public override IDoorGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDoorGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Door");
    writer.WritePropertyName("CloseSound");
    JsonSerializer.Serialize(writer, value.CloseSound, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LoopSound");
    JsonSerializer.Serialize(writer, value.LoopSound, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("OpenSound");
    JsonSerializer.Serialize(writer, value.OpenSound, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class Door_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Door>
{
  private IDoorGetter_Converter _getterConverter;
  public Door_Converter(IDoorGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Door value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDoorGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Door Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Door();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CloseSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.CloseSound, ref reader);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Door.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LoopSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.LoopSound, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Door.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "OpenSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.OpenSound, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDoorTriangleGetter_Converter : JsonConverter<IDoorTriangleGetter>
{
  public override IDoorTriangleGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDoorTriangleGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DoorTriangle");
    writer.WritePropertyName("Door");
    JsonSerializer.Serialize(writer, value.Door, options);
    writer.WritePropertyName("TriangleBeforeDoor");
    JsonSerializer.Serialize(writer, value.TriangleBeforeDoor, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class DoorTriangle_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DoorTriangle>
{
  private IDoorTriangleGetter_Converter _getterConverter;
  public DoorTriangle_Converter(IDoorTriangleGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DoorTriangle value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDoorTriangleGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DoorTriangle Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DoorTriangle();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Door":
            ConverterHelpers.ReadFormLink<IPlacedObjectGetter>(retval.Door, ref reader);
            break;
        case "TriangleBeforeDoor":
            retval.TriangleBeforeDoor = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IDualCastDataGetter_Converter : JsonConverter<IDualCastDataGetter>
{
  public override IDualCastDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IDualCastDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "DualCastData");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EffectShader");
    JsonSerializer.Serialize(writer, value.EffectShader, options);
    writer.WritePropertyName("Explosion");
    JsonSerializer.Serialize(writer, value.Explosion, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HitEffectArt");
    JsonSerializer.Serialize(writer, value.HitEffectArt, options);
    writer.WritePropertyName("ImpactDataSet");
    JsonSerializer.Serialize(writer, value.ImpactDataSet, options);
    writer.WritePropertyName("InheritScale");
    JsonSerializer.Serialize(writer, value.InheritScale, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Projectile");
    JsonSerializer.Serialize(writer, value.Projectile, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class DualCastData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.DualCastData>
{
  private IDualCastDataGetter_Converter _getterConverter;
  public DualCastData_Converter(IDualCastDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.DualCastData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IDualCastDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.DualCastData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.DualCastData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DualCastData.DATADataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EffectShader":
            ConverterHelpers.ReadFormLink<IEffectShaderGetter>(retval.EffectShader, ref reader);
            break;
        case "Explosion":
            ConverterHelpers.ReadFormLink<IExplosionGetter>(retval.Explosion, ref reader);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HitEffectArt":
            ConverterHelpers.ReadFormLink<IArtObjectGetter>(retval.HitEffectArt, ref reader);
            break;
        case "ImpactDataSet":
            ConverterHelpers.ReadFormLink<IImpactDataSetGetter>(retval.ImpactDataSet, ref reader);
            break;
        case "InheritScale":
            retval.InheritScale = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.DualCastData.InheritScaleType>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "Projectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.Projectile, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IEdgeLinkGetter_Converter : JsonConverter<IEdgeLinkGetter>
{
  public override IEdgeLinkGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IEdgeLinkGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "EdgeLink");
    writer.WritePropertyName("Mesh");
    JsonSerializer.Serialize(writer, value.Mesh, options);
    writer.WritePropertyName("TriangleIndex");
    JsonSerializer.Serialize(writer, value.TriangleIndex, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class EdgeLink_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.EdgeLink>
{
  private IEdgeLinkGetter_Converter _getterConverter;
  public EdgeLink_Converter(IEdgeLinkGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.EdgeLink value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IEdgeLinkGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.EdgeLink Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.EdgeLink();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Mesh":
            ConverterHelpers.ReadFormLink<INavigationMeshGetter>(retval.Mesh, ref reader);
            break;
        case "TriangleIndex":
            retval.TriangleIndex = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IEffectGetter_Converter : JsonConverter<IEffectGetter>
{
  public override IEffectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IEffectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Effect");
    writer.WritePropertyName("BaseEffect");
    JsonSerializer.Serialize(writer, value.BaseEffect, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WriteEndObject();
  }
}
public class Effect_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Effect>
{
  private IEffectGetter_Converter _getterConverter;
  public Effect_Converter(IEffectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Effect value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IEffectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Effect Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Effect();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BaseEffect":
            ConverterHelpers.ReadFormLinkNullable<IMagicEffectGetter>(retval.BaseEffect, ref reader);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectData>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IEffectDataGetter_Converter : JsonConverter<IEffectDataGetter>
{
  public override IEffectDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IEffectDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "EffectData");
    writer.WritePropertyName("Area");
    JsonSerializer.Serialize(writer, value.Area, options);
    writer.WritePropertyName("Duration");
    JsonSerializer.Serialize(writer, value.Duration, options);
    writer.WritePropertyName("Magnitude");
    JsonSerializer.Serialize(writer, value.Magnitude, options);
    writer.WriteEndObject();
  }
}
public class EffectData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.EffectData>
{
  private IEffectDataGetter_Converter _getterConverter;
  public EffectData_Converter(IEffectDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.EffectData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IEffectDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.EffectData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.EffectData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Area":
            retval.Area = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Duration":
            retval.Duration = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Magnitude":
            retval.Magnitude = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IEffectShaderGetter_Converter : JsonConverter<IEffectShaderGetter>
{
  public override IEffectShaderGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IEffectShaderGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "EffectShader");
    writer.WritePropertyName("AddonModels");
    JsonSerializer.Serialize(writer, value.AddonModels, options);
    writer.WritePropertyName("AddonModelsFadeInTime");
    JsonSerializer.Serialize(writer, value.AddonModelsFadeInTime, options);
    writer.WritePropertyName("AddonModelsFadeOutTime");
    JsonSerializer.Serialize(writer, value.AddonModelsFadeOutTime, options);
    writer.WritePropertyName("AddonModelsScaleEnd");
    JsonSerializer.Serialize(writer, value.AddonModelsScaleEnd, options);
    writer.WritePropertyName("AddonModelsScaleInTime");
    JsonSerializer.Serialize(writer, value.AddonModelsScaleInTime, options);
    writer.WritePropertyName("AddonModelsScaleOutTime");
    JsonSerializer.Serialize(writer, value.AddonModelsScaleOutTime, options);
    writer.WritePropertyName("AddonModelsScaleStart");
    JsonSerializer.Serialize(writer, value.AddonModelsScaleStart, options);
    writer.WritePropertyName("AmbientSound");
    JsonSerializer.Serialize(writer, value.AmbientSound, options);
    writer.WritePropertyName("BirthPositionOffset");
    JsonSerializer.Serialize(writer, value.BirthPositionOffset, options);
    writer.WritePropertyName("BirthPositionOffsetRangePlusMinus");
    JsonSerializer.Serialize(writer, value.BirthPositionOffsetRangePlusMinus, options);
    writer.WritePropertyName("ColorKey1");
    JsonSerializer.Serialize(writer, value.ColorKey1, options);
    writer.WritePropertyName("ColorKey1Alpha");
    JsonSerializer.Serialize(writer, value.ColorKey1Alpha, options);
    writer.WritePropertyName("ColorKey1Time");
    JsonSerializer.Serialize(writer, value.ColorKey1Time, options);
    writer.WritePropertyName("ColorKey2");
    JsonSerializer.Serialize(writer, value.ColorKey2, options);
    writer.WritePropertyName("ColorKey2Alpha");
    JsonSerializer.Serialize(writer, value.ColorKey2Alpha, options);
    writer.WritePropertyName("ColorKey2Time");
    JsonSerializer.Serialize(writer, value.ColorKey2Time, options);
    writer.WritePropertyName("ColorKey3");
    JsonSerializer.Serialize(writer, value.ColorKey3, options);
    writer.WritePropertyName("ColorKey3Alpha");
    JsonSerializer.Serialize(writer, value.ColorKey3Alpha, options);
    writer.WritePropertyName("ColorKey3Time");
    JsonSerializer.Serialize(writer, value.ColorKey3Time, options);
    writer.WritePropertyName("ColorScale");
    JsonSerializer.Serialize(writer, value.ColorScale, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EdgeColor");
    JsonSerializer.Serialize(writer, value.EdgeColor, options);
    writer.WritePropertyName("EdgeEffectAlphaFadeInTime");
    JsonSerializer.Serialize(writer, value.EdgeEffectAlphaFadeInTime, options);
    writer.WritePropertyName("EdgeEffectAlphaFadeOutTime");
    JsonSerializer.Serialize(writer, value.EdgeEffectAlphaFadeOutTime, options);
    writer.WritePropertyName("EdgeEffectAlphaPulseAmplitude");
    JsonSerializer.Serialize(writer, value.EdgeEffectAlphaPulseAmplitude, options);
    writer.WritePropertyName("EdgeEffectAlphaPulseFrequency");
    JsonSerializer.Serialize(writer, value.EdgeEffectAlphaPulseFrequency, options);
    writer.WritePropertyName("EdgeEffectColor");
    JsonSerializer.Serialize(writer, value.EdgeEffectColor, options);
    writer.WritePropertyName("EdgeEffectFallOff");
    JsonSerializer.Serialize(writer, value.EdgeEffectFallOff, options);
    writer.WritePropertyName("EdgeEffectFullAlphaRatio");
    JsonSerializer.Serialize(writer, value.EdgeEffectFullAlphaRatio, options);
    writer.WritePropertyName("EdgeEffectFullAlphaTime");
    JsonSerializer.Serialize(writer, value.EdgeEffectFullAlphaTime, options);
    writer.WritePropertyName("EdgeEffectPersistentAlphaRatio");
    JsonSerializer.Serialize(writer, value.EdgeEffectPersistentAlphaRatio, options);
    writer.WritePropertyName("EdgeWidth");
    JsonSerializer.Serialize(writer, value.EdgeWidth, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("ExplosionWindSpeed");
    JsonSerializer.Serialize(writer, value.ExplosionWindSpeed, options);
    writer.WritePropertyName("FillAlphaFadeInTime");
    JsonSerializer.Serialize(writer, value.FillAlphaFadeInTime, options);
    writer.WritePropertyName("FillAlphaPulseAmplitude");
    JsonSerializer.Serialize(writer, value.FillAlphaPulseAmplitude, options);
    writer.WritePropertyName("FillAlphaPulseFrequency");
    JsonSerializer.Serialize(writer, value.FillAlphaPulseFrequency, options);
    writer.WritePropertyName("FillColorKey1");
    JsonSerializer.Serialize(writer, value.FillColorKey1, options);
    writer.WritePropertyName("FillColorKey1Scale");
    JsonSerializer.Serialize(writer, value.FillColorKey1Scale, options);
    writer.WritePropertyName("FillColorKey1Time");
    JsonSerializer.Serialize(writer, value.FillColorKey1Time, options);
    writer.WritePropertyName("FillColorKey2");
    JsonSerializer.Serialize(writer, value.FillColorKey2, options);
    writer.WritePropertyName("FillColorKey2Scale");
    JsonSerializer.Serialize(writer, value.FillColorKey2Scale, options);
    writer.WritePropertyName("FillColorKey2Time");
    JsonSerializer.Serialize(writer, value.FillColorKey2Time, options);
    writer.WritePropertyName("FillColorKey3");
    JsonSerializer.Serialize(writer, value.FillColorKey3, options);
    writer.WritePropertyName("FillColorKey3Scale");
    JsonSerializer.Serialize(writer, value.FillColorKey3Scale, options);
    writer.WritePropertyName("FillColorKey3Time");
    JsonSerializer.Serialize(writer, value.FillColorKey3Time, options);
    writer.WritePropertyName("FillFadeOutTime");
    JsonSerializer.Serialize(writer, value.FillFadeOutTime, options);
    writer.WritePropertyName("FillFullAlphaRatio");
    JsonSerializer.Serialize(writer, value.FillFullAlphaRatio, options);
    writer.WritePropertyName("FillFullAlphaTime");
    JsonSerializer.Serialize(writer, value.FillFullAlphaTime, options);
    writer.WritePropertyName("FillPersistentAlphaRatio");
    JsonSerializer.Serialize(writer, value.FillPersistentAlphaRatio, options);
    writer.WritePropertyName("FillTexture");
    JsonSerializer.Serialize(writer, value.FillTexture, options);
    writer.WritePropertyName("FillTextureAnimationSpeedU");
    JsonSerializer.Serialize(writer, value.FillTextureAnimationSpeedU, options);
    writer.WritePropertyName("FillTextureAnimationSpeedV");
    JsonSerializer.Serialize(writer, value.FillTextureAnimationSpeedV, options);
    writer.WritePropertyName("FillTextureScaleU");
    JsonSerializer.Serialize(writer, value.FillTextureScaleU, options);
    writer.WritePropertyName("FillTextureScaleV");
    JsonSerializer.Serialize(writer, value.FillTextureScaleV, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HolesEndTime");
    JsonSerializer.Serialize(writer, value.HolesEndTime, options);
    writer.WritePropertyName("HolesEndValue");
    JsonSerializer.Serialize(writer, value.HolesEndValue, options);
    writer.WritePropertyName("HolesStartTime");
    JsonSerializer.Serialize(writer, value.HolesStartTime, options);
    writer.WritePropertyName("HolesStartValue");
    JsonSerializer.Serialize(writer, value.HolesStartValue, options);
    writer.WritePropertyName("HolesTexture");
    JsonSerializer.Serialize(writer, value.HolesTexture, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MembraneBlendOperation");
    JsonSerializer.Serialize(writer, value.MembraneBlendOperation, options);
    writer.WritePropertyName("MembraneDestBlendMode");
    JsonSerializer.Serialize(writer, value.MembraneDestBlendMode, options);
    writer.WritePropertyName("MembranePaletteTexture");
    JsonSerializer.Serialize(writer, value.MembranePaletteTexture, options);
    writer.WritePropertyName("MembraneSourceBlendMode");
    JsonSerializer.Serialize(writer, value.MembraneSourceBlendMode, options);
    writer.WritePropertyName("MembraneZTest");
    JsonSerializer.Serialize(writer, value.MembraneZTest, options);
    writer.WritePropertyName("ParticleAcceleration1");
    JsonSerializer.Serialize(writer, value.ParticleAcceleration1, options);
    writer.WritePropertyName("ParticleAcceleration2");
    JsonSerializer.Serialize(writer, value.ParticleAcceleration2, options);
    writer.WritePropertyName("ParticleAcceleration3");
    JsonSerializer.Serialize(writer, value.ParticleAcceleration3, options);
    writer.WritePropertyName("ParticleAccelerationAlongNormal");
    JsonSerializer.Serialize(writer, value.ParticleAccelerationAlongNormal, options);
    writer.WritePropertyName("ParticleAnimatedEndFrame");
    JsonSerializer.Serialize(writer, value.ParticleAnimatedEndFrame, options);
    writer.WritePropertyName("ParticleAnimatedFrameCount");
    JsonSerializer.Serialize(writer, value.ParticleAnimatedFrameCount, options);
    writer.WritePropertyName("ParticleAnimatedFrameCountVariation");
    JsonSerializer.Serialize(writer, value.ParticleAnimatedFrameCountVariation, options);
    writer.WritePropertyName("ParticleAnimatedLoopStartFrame");
    JsonSerializer.Serialize(writer, value.ParticleAnimatedLoopStartFrame, options);
    writer.WritePropertyName("ParticleAnimatedLoopStartVariation");
    JsonSerializer.Serialize(writer, value.ParticleAnimatedLoopStartVariation, options);
    writer.WritePropertyName("ParticleAnimatedStartFrame");
    JsonSerializer.Serialize(writer, value.ParticleAnimatedStartFrame, options);
    writer.WritePropertyName("ParticleAnimatedStartFrameVariation");
    JsonSerializer.Serialize(writer, value.ParticleAnimatedStartFrameVariation, options);
    writer.WritePropertyName("ParticleBirthRampDownTime");
    JsonSerializer.Serialize(writer, value.ParticleBirthRampDownTime, options);
    writer.WritePropertyName("ParticleBirthRampUpTime");
    JsonSerializer.Serialize(writer, value.ParticleBirthRampUpTime, options);
    writer.WritePropertyName("ParticleBlendOperation");
    JsonSerializer.Serialize(writer, value.ParticleBlendOperation, options);
    writer.WritePropertyName("ParticleDestBlendMode");
    JsonSerializer.Serialize(writer, value.ParticleDestBlendMode, options);
    writer.WritePropertyName("ParticleFullBirthRatio");
    JsonSerializer.Serialize(writer, value.ParticleFullBirthRatio, options);
    writer.WritePropertyName("ParticleFullBirthTime");
    JsonSerializer.Serialize(writer, value.ParticleFullBirthTime, options);
    writer.WritePropertyName("ParticleInitialRotationDegree");
    JsonSerializer.Serialize(writer, value.ParticleInitialRotationDegree, options);
    writer.WritePropertyName("ParticleInitialRotationDegreePlusMinus");
    JsonSerializer.Serialize(writer, value.ParticleInitialRotationDegreePlusMinus, options);
    writer.WritePropertyName("ParticleInitialSpeedAlongNormal");
    JsonSerializer.Serialize(writer, value.ParticleInitialSpeedAlongNormal, options);
    writer.WritePropertyName("ParticleInitialSpeedAlongNormalPlusMinus");
    JsonSerializer.Serialize(writer, value.ParticleInitialSpeedAlongNormalPlusMinus, options);
    writer.WritePropertyName("ParticleInitialVelocity1");
    JsonSerializer.Serialize(writer, value.ParticleInitialVelocity1, options);
    writer.WritePropertyName("ParticleInitialVelocity2");
    JsonSerializer.Serialize(writer, value.ParticleInitialVelocity2, options);
    writer.WritePropertyName("ParticleInitialVelocity3");
    JsonSerializer.Serialize(writer, value.ParticleInitialVelocity3, options);
    writer.WritePropertyName("ParticleLifetime");
    JsonSerializer.Serialize(writer, value.ParticleLifetime, options);
    writer.WritePropertyName("ParticleLifetimePlusMinus");
    JsonSerializer.Serialize(writer, value.ParticleLifetimePlusMinus, options);
    writer.WritePropertyName("ParticlePaletteTexture");
    JsonSerializer.Serialize(writer, value.ParticlePaletteTexture, options);
    writer.WritePropertyName("ParticlePeristentCount");
    JsonSerializer.Serialize(writer, value.ParticlePeristentCount, options);
    writer.WritePropertyName("ParticleRotationSpeedDegreePerSec");
    JsonSerializer.Serialize(writer, value.ParticleRotationSpeedDegreePerSec, options);
    writer.WritePropertyName("ParticleRotationSpeedDegreePerSecPlusMinus");
    JsonSerializer.Serialize(writer, value.ParticleRotationSpeedDegreePerSecPlusMinus, options);
    writer.WritePropertyName("ParticleScaleKey1");
    JsonSerializer.Serialize(writer, value.ParticleScaleKey1, options);
    writer.WritePropertyName("ParticleScaleKey1Time");
    JsonSerializer.Serialize(writer, value.ParticleScaleKey1Time, options);
    writer.WritePropertyName("ParticleScaleKey2");
    JsonSerializer.Serialize(writer, value.ParticleScaleKey2, options);
    writer.WritePropertyName("ParticleScaleKey2Time");
    JsonSerializer.Serialize(writer, value.ParticleScaleKey2Time, options);
    writer.WritePropertyName("ParticleShaderTexture");
    JsonSerializer.Serialize(writer, value.ParticleShaderTexture, options);
    writer.WritePropertyName("ParticleSourceBlendMode");
    JsonSerializer.Serialize(writer, value.ParticleSourceBlendMode, options);
    writer.WritePropertyName("ParticleZTest");
    JsonSerializer.Serialize(writer, value.ParticleZTest, options);
    writer.WritePropertyName("SceneGraphEmitDepthLimit");
    JsonSerializer.Serialize(writer, value.SceneGraphEmitDepthLimit, options);
    writer.WritePropertyName("TextureCountU");
    JsonSerializer.Serialize(writer, value.TextureCountU, options);
    writer.WritePropertyName("TextureCountV");
    JsonSerializer.Serialize(writer, value.TextureCountV, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class EffectShader_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.EffectShader>
{
  private IEffectShaderGetter_Converter _getterConverter;
  public EffectShader_Converter(IEffectShaderGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.EffectShader value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IEffectShaderGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.EffectShader Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.EffectShader();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AddonModels":
            ConverterHelpers.ReadFormLink<IDebrisGetter>(retval.AddonModels, ref reader);
            break;
        case "AddonModelsFadeInTime":
            retval.AddonModelsFadeInTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AddonModelsFadeOutTime":
            retval.AddonModelsFadeOutTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AddonModelsScaleEnd":
            retval.AddonModelsScaleEnd = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AddonModelsScaleInTime":
            retval.AddonModelsScaleInTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AddonModelsScaleOutTime":
            retval.AddonModelsScaleOutTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AddonModelsScaleStart":
            retval.AddonModelsScaleStart = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AmbientSound":
            ConverterHelpers.ReadFormLink<ISoundGetter>(retval.AmbientSound, ref reader);
            break;
        case "BirthPositionOffset":
            retval.BirthPositionOffset = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BirthPositionOffsetRangePlusMinus":
            retval.BirthPositionOffsetRangePlusMinus = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ColorKey1":
            retval.ColorKey1 = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "ColorKey1Alpha":
            retval.ColorKey1Alpha = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ColorKey1Time":
            retval.ColorKey1Time = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ColorKey2":
            retval.ColorKey2 = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "ColorKey2Alpha":
            retval.ColorKey2Alpha = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ColorKey2Time":
            retval.ColorKey2Time = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ColorKey3":
            retval.ColorKey3 = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "ColorKey3Alpha":
            retval.ColorKey3Alpha = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ColorKey3Time":
            retval.ColorKey3Time = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ColorScale":
            retval.ColorScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectShader.DATADataType>(ref reader, options);
            break;
        case "EdgeColor":
            retval.EdgeColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "EdgeEffectAlphaFadeInTime":
            retval.EdgeEffectAlphaFadeInTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EdgeEffectAlphaFadeOutTime":
            retval.EdgeEffectAlphaFadeOutTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EdgeEffectAlphaPulseAmplitude":
            retval.EdgeEffectAlphaPulseAmplitude = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EdgeEffectAlphaPulseFrequency":
            retval.EdgeEffectAlphaPulseFrequency = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EdgeEffectColor":
            retval.EdgeEffectColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "EdgeEffectFallOff":
            retval.EdgeEffectFallOff = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EdgeEffectFullAlphaRatio":
            retval.EdgeEffectFullAlphaRatio = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EdgeEffectFullAlphaTime":
            retval.EdgeEffectFullAlphaTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EdgeEffectPersistentAlphaRatio":
            retval.EdgeEffectPersistentAlphaRatio = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EdgeWidth":
            retval.EdgeWidth = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ExplosionWindSpeed":
            retval.ExplosionWindSpeed = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillAlphaFadeInTime":
            retval.FillAlphaFadeInTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillAlphaPulseAmplitude":
            retval.FillAlphaPulseAmplitude = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillAlphaPulseFrequency":
            retval.FillAlphaPulseFrequency = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillColorKey1":
            retval.FillColorKey1 = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "FillColorKey1Scale":
            retval.FillColorKey1Scale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillColorKey1Time":
            retval.FillColorKey1Time = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillColorKey2":
            retval.FillColorKey2 = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "FillColorKey2Scale":
            retval.FillColorKey2Scale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillColorKey2Time":
            retval.FillColorKey2Time = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillColorKey3":
            retval.FillColorKey3 = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "FillColorKey3Scale":
            retval.FillColorKey3Scale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillColorKey3Time":
            retval.FillColorKey3Time = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillFadeOutTime":
            retval.FillFadeOutTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillFullAlphaRatio":
            retval.FillFullAlphaRatio = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillFullAlphaTime":
            retval.FillFullAlphaTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillPersistentAlphaRatio":
            retval.FillPersistentAlphaRatio = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillTexture":
            retval.FillTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FillTextureAnimationSpeedU":
            retval.FillTextureAnimationSpeedU = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillTextureAnimationSpeedV":
            retval.FillTextureAnimationSpeedV = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillTextureScaleU":
            retval.FillTextureScaleU = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FillTextureScaleV":
            retval.FillTextureScaleV = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectShader.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HolesEndTime":
            retval.HolesEndTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "HolesEndValue":
            retval.HolesEndValue = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "HolesStartTime":
            retval.HolesStartTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "HolesStartValue":
            retval.HolesStartValue = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "HolesTexture":
            retval.HolesTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MembraneBlendOperation":
            retval.MembraneBlendOperation = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectShader.BlendOperation>(ref reader, options);
            break;
        case "MembraneDestBlendMode":
            retval.MembraneDestBlendMode = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectShader.BlendMode>(ref reader, options);
            break;
        case "MembranePaletteTexture":
            retval.MembranePaletteTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "MembraneSourceBlendMode":
            retval.MembraneSourceBlendMode = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectShader.BlendMode>(ref reader, options);
            break;
        case "MembraneZTest":
            retval.MembraneZTest = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectShader.ZTest>(ref reader, options);
            break;
        case "ParticleAcceleration1":
            retval.ParticleAcceleration1 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleAcceleration2":
            retval.ParticleAcceleration2 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleAcceleration3":
            retval.ParticleAcceleration3 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleAccelerationAlongNormal":
            retval.ParticleAccelerationAlongNormal = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleAnimatedEndFrame":
            retval.ParticleAnimatedEndFrame = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "ParticleAnimatedFrameCount":
            retval.ParticleAnimatedFrameCount = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "ParticleAnimatedFrameCountVariation":
            retval.ParticleAnimatedFrameCountVariation = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "ParticleAnimatedLoopStartFrame":
            retval.ParticleAnimatedLoopStartFrame = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "ParticleAnimatedLoopStartVariation":
            retval.ParticleAnimatedLoopStartVariation = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "ParticleAnimatedStartFrame":
            retval.ParticleAnimatedStartFrame = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "ParticleAnimatedStartFrameVariation":
            retval.ParticleAnimatedStartFrameVariation = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "ParticleBirthRampDownTime":
            retval.ParticleBirthRampDownTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleBirthRampUpTime":
            retval.ParticleBirthRampUpTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleBlendOperation":
            retval.ParticleBlendOperation = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectShader.BlendOperation>(ref reader, options);
            break;
        case "ParticleDestBlendMode":
            retval.ParticleDestBlendMode = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectShader.BlendMode>(ref reader, options);
            break;
        case "ParticleFullBirthRatio":
            retval.ParticleFullBirthRatio = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleFullBirthTime":
            retval.ParticleFullBirthTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleInitialRotationDegree":
            retval.ParticleInitialRotationDegree = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleInitialRotationDegreePlusMinus":
            retval.ParticleInitialRotationDegreePlusMinus = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleInitialSpeedAlongNormal":
            retval.ParticleInitialSpeedAlongNormal = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleInitialSpeedAlongNormalPlusMinus":
            retval.ParticleInitialSpeedAlongNormalPlusMinus = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleInitialVelocity1":
            retval.ParticleInitialVelocity1 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleInitialVelocity2":
            retval.ParticleInitialVelocity2 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleInitialVelocity3":
            retval.ParticleInitialVelocity3 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleLifetime":
            retval.ParticleLifetime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleLifetimePlusMinus":
            retval.ParticleLifetimePlusMinus = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticlePaletteTexture":
            retval.ParticlePaletteTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ParticlePeristentCount":
            retval.ParticlePeristentCount = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleRotationSpeedDegreePerSec":
            retval.ParticleRotationSpeedDegreePerSec = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleRotationSpeedDegreePerSecPlusMinus":
            retval.ParticleRotationSpeedDegreePerSecPlusMinus = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleScaleKey1":
            retval.ParticleScaleKey1 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleScaleKey1Time":
            retval.ParticleScaleKey1Time = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleScaleKey2":
            retval.ParticleScaleKey2 = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleScaleKey2Time":
            retval.ParticleScaleKey2Time = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleShaderTexture":
            retval.ParticleShaderTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ParticleSourceBlendMode":
            retval.ParticleSourceBlendMode = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectShader.BlendMode>(ref reader, options);
            break;
        case "ParticleZTest":
            retval.ParticleZTest = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EffectShader.ZTest>(ref reader, options);
            break;
        case "SceneGraphEmitDepthLimit":
            retval.SceneGraphEmitDepthLimit = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TextureCountU":
            retval.TextureCountU = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "TextureCountV":
            retval.TextureCountV = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IEnableParentGetter_Converter : JsonConverter<IEnableParentGetter>
{
  public override IEnableParentGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IEnableParentGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "EnableParent");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class EnableParent_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.EnableParent>
{
  private IEnableParentGetter_Converter _getterConverter;
  public EnableParent_Converter(IEnableParentGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.EnableParent value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IEnableParentGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.EnableParent Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.EnableParent();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent.Flag>(ref reader, options);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<ILinkedReferenceGetter>(retval.Reference, ref reader);
            break;
        case "Unknown":
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IEncounterZoneGetter_Converter : JsonConverter<IEncounterZoneGetter>
{
  public override IEncounterZoneGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IEncounterZoneGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "EncounterZone");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("Location");
    JsonSerializer.Serialize(writer, value.Location, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MaxLevel");
    JsonSerializer.Serialize(writer, value.MaxLevel, options);
    writer.WritePropertyName("MinLevel");
    JsonSerializer.Serialize(writer, value.MinLevel, options);
    writer.WritePropertyName("Owner");
    JsonSerializer.Serialize(writer, value.Owner, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class EncounterZone_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.EncounterZone>
{
  private IEncounterZoneGetter_Converter _getterConverter;
  public EncounterZone_Converter(IEncounterZoneGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.EncounterZone value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IEncounterZoneGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.EncounterZone Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.EncounterZone();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EncounterZone.DATADataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EncounterZone.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Location":
            ConverterHelpers.ReadFormLink<ILocationGetter>(retval.Location, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MaxLevel":
            retval.MaxLevel = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "MinLevel":
            retval.MinLevel = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "Owner":
            ConverterHelpers.ReadFormLink<IOwnerGetter>(retval.Owner, ref reader);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IEntryPointsGetter_Converter : JsonConverter<IEntryPointsGetter>
{
  public override IEntryPointsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IEntryPointsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "EntryPoints");
    writer.WritePropertyName("Points");
    JsonSerializer.Serialize(writer, value.Points, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class EntryPoints_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.EntryPoints>
{
  private IEntryPointsGetter_Converter _getterConverter;
  public EntryPoints_Converter(IEntryPointsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.EntryPoints value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IEntryPointsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.EntryPoints Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.EntryPoints();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Points":
            retval.Points = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Furniture.Entry>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Furniture.AnimationType>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IEquipTypeGetter_Converter : JsonConverter<IEquipTypeGetter>
{
  public override IEquipTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IEquipTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "EquipType");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.SlotParents != default)
    {
      writer.WritePropertyName("SlotParents");
      writer.WriteStartArray();
      foreach (var itm in value.SlotParents)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("SlotParents");
    }
    writer.WritePropertyName("UseAllParents");
    JsonSerializer.Serialize(writer, value.UseAllParents, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class EquipType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.EquipType>
{
  private IEquipTypeGetter_Converter _getterConverter;
  public EquipType_Converter(IEquipTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.EquipType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IEquipTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.EquipType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.EquipType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SlotParents":
            ConverterHelpers.ReadFormLinkList<IEquipTypeGetter>(retval.SlotParents, ref reader);
            break;
        case "UseAllParents":
            retval.UseAllParents = JsonSerializer.Deserialize<Boolean?>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IExplosionGetter_Converter : JsonConverter<IExplosionGetter>
{
  public override IExplosionGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IExplosionGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Explosion");
    writer.WritePropertyName("Damage");
    JsonSerializer.Serialize(writer, value.Damage, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Force");
    JsonSerializer.Serialize(writer, value.Force, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("ImageSpaceModifier");
    JsonSerializer.Serialize(writer, value.ImageSpaceModifier, options);
    writer.WritePropertyName("ImpactDataSet");
    JsonSerializer.Serialize(writer, value.ImpactDataSet, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("ISRadius");
    JsonSerializer.Serialize(writer, value.ISRadius, options);
    writer.WritePropertyName("Light");
    JsonSerializer.Serialize(writer, value.Light, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("ObjectEffect");
    JsonSerializer.Serialize(writer, value.ObjectEffect, options);
    writer.WritePropertyName("PlacedObject");
    JsonSerializer.Serialize(writer, value.PlacedObject, options);
    writer.WritePropertyName("Radius");
    JsonSerializer.Serialize(writer, value.Radius, options);
    writer.WritePropertyName("Sound1");
    JsonSerializer.Serialize(writer, value.Sound1, options);
    writer.WritePropertyName("Sound2");
    JsonSerializer.Serialize(writer, value.Sound2, options);
    writer.WritePropertyName("SoundLevel");
    JsonSerializer.Serialize(writer, value.SoundLevel, options);
    writer.WritePropertyName("SpawnProjectile");
    JsonSerializer.Serialize(writer, value.SpawnProjectile, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VerticalOffsetMult");
    JsonSerializer.Serialize(writer, value.VerticalOffsetMult, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class Explosion_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Explosion>
{
  private IExplosionGetter_Converter _getterConverter;
  public Explosion_Converter(IExplosionGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Explosion value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IExplosionGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Explosion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Explosion();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Damage":
            retval.Damage = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Explosion.DATADataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Explosion.Flag>(ref reader, options);
            break;
        case "Force":
            retval.Force = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "ImageSpaceModifier":
            ConverterHelpers.ReadFormLinkNullable<IImageSpaceAdapterGetter>(retval.ImageSpaceModifier, ref reader);
            break;
        case "ImpactDataSet":
            ConverterHelpers.ReadFormLink<IImpactDataSetGetter>(retval.ImpactDataSet, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "ISRadius":
            retval.ISRadius = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Light":
            ConverterHelpers.ReadFormLink<ILightGetter>(retval.Light, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "ObjectEffect":
            ConverterHelpers.ReadFormLinkNullable<IEffectRecordGetter>(retval.ObjectEffect, ref reader);
            break;
        case "PlacedObject":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.PlacedObject, ref reader);
            break;
        case "Radius":
            retval.Radius = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Sound1":
            ConverterHelpers.ReadFormLink<ISoundDescriptorGetter>(retval.Sound1, ref reader);
            break;
        case "Sound2":
            ConverterHelpers.ReadFormLink<ISoundDescriptorGetter>(retval.Sound2, ref reader);
            break;
        case "SoundLevel":
            retval.SoundLevel = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundLevel>(ref reader, options);
            break;
        case "SpawnProjectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.SpawnProjectile, ref reader);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VerticalOffsetMult":
            retval.VerticalOffsetMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IExternalAliasReferenceGetter_Converter : JsonConverter<IExternalAliasReferenceGetter>
{
  public override IExternalAliasReferenceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IExternalAliasReferenceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ExternalAliasReference");
    writer.WritePropertyName("AliasIndex");
    JsonSerializer.Serialize(writer, value.AliasIndex, options);
    writer.WritePropertyName("Quest");
    JsonSerializer.Serialize(writer, value.Quest, options);
    writer.WriteEndObject();
  }
}
public class ExternalAliasReference_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ExternalAliasReference>
{
  private IExternalAliasReferenceGetter_Converter _getterConverter;
  public ExternalAliasReference_Converter(IExternalAliasReferenceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ExternalAliasReference value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IExternalAliasReferenceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ExternalAliasReference Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ExternalAliasReference();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AliasIndex":
            retval.AliasIndex = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "Quest":
            ConverterHelpers.ReadFormLinkNullable<IQuestGetter>(retval.Quest, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IExtraDataGetter_Converter : JsonConverter<IExtraDataGetter>
{
  public override IExtraDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IExtraDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ExtraData");
    writer.WritePropertyName("ItemCondition");
    JsonSerializer.Serialize(writer, value.ItemCondition, options);
    writer.WritePropertyName("Owner");
    JsonSerializer.Serialize(writer, value.Owner, options);
    writer.WriteEndObject();
  }
}
public class ExtraData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ExtraData>
{
  private IExtraDataGetter_Converter _getterConverter;
  public ExtraData_Converter(IExtraDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ExtraData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IExtraDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ExtraData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ExtraData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ItemCondition":
            retval.ItemCondition = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Owner":
            retval.Owner = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.OwnerTarget>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IEyesGetter_Converter : JsonConverter<IEyesGetter>
{
  public override IEyesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IEyesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Eyes");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icon");
    JsonSerializer.Serialize(writer, value.Icon, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Eyes_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Eyes>
{
  private IEyesGetter_Converter _getterConverter;
  public Eyes_Converter(IEyesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Eyes value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IEyesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Eyes Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Eyes();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Eyes.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icon":
            retval.Icon = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Eyes.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFaceFxPhonemesGetter_Converter : JsonConverter<IFaceFxPhonemesGetter>
{
  public override IFaceFxPhonemesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFaceFxPhonemesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "FaceFxPhonemes");
    writer.WritePropertyName("Aah_LipBigAah");
    JsonSerializer.Serialize(writer, value.Aah_LipBigAah, options);
    writer.WritePropertyName("BigAah_LipDST");
    JsonSerializer.Serialize(writer, value.BigAah_LipDST, options);
    writer.WritePropertyName("BMP_LipEee");
    JsonSerializer.Serialize(writer, value.BMP_LipEee, options);
    writer.WritePropertyName("ChJSh_LipFV");
    JsonSerializer.Serialize(writer, value.ChJSh_LipFV, options);
    writer.WritePropertyName("DST_LipK");
    JsonSerializer.Serialize(writer, value.DST_LipK, options);
    writer.WritePropertyName("Eee_LipL");
    JsonSerializer.Serialize(writer, value.Eee_LipL, options);
    writer.WritePropertyName("Eh_LipR");
    JsonSerializer.Serialize(writer, value.Eh_LipR, options);
    writer.WritePropertyName("ForceNames");
    JsonSerializer.Serialize(writer, value.ForceNames, options);
    writer.WritePropertyName("FV_LipTh");
    JsonSerializer.Serialize(writer, value.FV_LipTh, options);
    writer.WritePropertyName("I");
    JsonSerializer.Serialize(writer, value.I, options);
    writer.WritePropertyName("K");
    JsonSerializer.Serialize(writer, value.K, options);
    writer.WritePropertyName("N");
    JsonSerializer.Serialize(writer, value.N, options);
    writer.WritePropertyName("Oh");
    JsonSerializer.Serialize(writer, value.Oh, options);
    writer.WritePropertyName("OohQ");
    JsonSerializer.Serialize(writer, value.OohQ, options);
    writer.WritePropertyName("R");
    JsonSerializer.Serialize(writer, value.R, options);
    writer.WritePropertyName("Th");
    JsonSerializer.Serialize(writer, value.Th, options);
    writer.WritePropertyName("W");
    JsonSerializer.Serialize(writer, value.W, options);
    writer.WriteEndObject();
  }
}
public class FaceFxPhonemes_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.FaceFxPhonemes>
{
  private IFaceFxPhonemesGetter_Converter _getterConverter;
  public FaceFxPhonemes_Converter(IFaceFxPhonemesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.FaceFxPhonemes value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFaceFxPhonemesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.FaceFxPhonemes Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.FaceFxPhonemes();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Aah_LipBigAah":
            retval.Aah_LipBigAah = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "BigAah_LipDST":
            retval.BigAah_LipDST = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "BMP_LipEee":
            retval.BMP_LipEee = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "ChJSh_LipFV":
            retval.ChJSh_LipFV = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "DST_LipK":
            retval.DST_LipK = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "Eee_LipL":
            retval.Eee_LipL = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "Eh_LipR":
            retval.Eh_LipR = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "ForceNames":
            retval.ForceNames = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "FV_LipTh":
            retval.FV_LipTh = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "I":
            retval.I = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "K":
            retval.K = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "N":
            retval.N = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "Oh":
            retval.Oh = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "OohQ":
            retval.OohQ = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "R":
            retval.R = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "Th":
            retval.Th = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        case "W":
            retval.W = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Phoneme>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFactionGetter_Converter : JsonConverter<IFactionGetter>
{
  public override IFactionGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFactionGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Faction");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("CrimeValues");
    JsonSerializer.Serialize(writer, value.CrimeValues, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("ExteriorJailMarker");
    JsonSerializer.Serialize(writer, value.ExteriorJailMarker, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FollowerWaitMarker");
    JsonSerializer.Serialize(writer, value.FollowerWaitMarker, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("JailOutfit");
    JsonSerializer.Serialize(writer, value.JailOutfit, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MerchantContainer");
    JsonSerializer.Serialize(writer, value.MerchantContainer, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("PlayerInventoryContainer");
    JsonSerializer.Serialize(writer, value.PlayerInventoryContainer, options);
    if (value.Ranks != default)
    {
      writer.WritePropertyName("Ranks");
      writer.WriteStartArray();
      foreach (var itm in value.Ranks)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Ranks");
    }
    if (value.Relations != default)
    {
      writer.WritePropertyName("Relations");
      writer.WriteStartArray();
      foreach (var itm in value.Relations)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Relations");
    }
    writer.WritePropertyName("SharedCrimeFactionList");
    JsonSerializer.Serialize(writer, value.SharedCrimeFactionList, options);
    writer.WritePropertyName("StolenGoodsContainer");
    JsonSerializer.Serialize(writer, value.StolenGoodsContainer, options);
    writer.WritePropertyName("VendorBuySellList");
    JsonSerializer.Serialize(writer, value.VendorBuySellList, options);
    writer.WritePropertyName("VendorLocation");
    JsonSerializer.Serialize(writer, value.VendorLocation, options);
    writer.WritePropertyName("VendorValues");
    JsonSerializer.Serialize(writer, value.VendorValues, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Faction_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Faction>
{
  private IFactionGetter_Converter _getterConverter;
  public Faction_Converter(IFactionGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Faction value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFactionGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Faction Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Faction();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "CrimeValues":
            retval.CrimeValues = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CrimeValues>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ExteriorJailMarker":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.ExteriorJailMarker, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Faction.FactionFlag>(ref reader, options);
            break;
        case "FollowerWaitMarker":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.FollowerWaitMarker, ref reader);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "JailOutfit":
            ConverterHelpers.ReadFormLinkNullable<IOutfitGetter>(retval.JailOutfit, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MerchantContainer":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MerchantContainer, ref reader);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "PlayerInventoryContainer":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.PlayerInventoryContainer, ref reader);
            break;
        case "Ranks":
            ConverterHelpers.ReadExtendedList<Rank>(retval.Ranks, ref reader, options);
            break;
        case "Relations":
            ConverterHelpers.ReadExtendedList<Relation>(retval.Relations, ref reader, options);
            break;
        case "SharedCrimeFactionList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.SharedCrimeFactionList, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "StolenGoodsContainer":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.StolenGoodsContainer, ref reader);
            break;
        case "VendorBuySellList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.VendorBuySellList, ref reader);
            break;
        case "VendorLocation":
            retval.VendorLocation = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LocationTargetRadius>(ref reader, options);
            break;
        case "VendorValues":
            retval.VendorValues = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VendorValues>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFactionOwnerGetter_Converter : JsonConverter<IFactionOwnerGetter>
{
  public override IFactionOwnerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFactionOwnerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "FactionOwner");
    writer.WritePropertyName("Faction");
    JsonSerializer.Serialize(writer, value.Faction, options);
    writer.WritePropertyName("RequiredRank");
    JsonSerializer.Serialize(writer, value.RequiredRank, options);
    writer.WriteEndObject();
  }
}
public class FactionOwner_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.FactionOwner>
{
  private IFactionOwnerGetter_Converter _getterConverter;
  public FactionOwner_Converter(IFactionOwnerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.FactionOwner value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFactionOwnerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.FactionOwner Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.FactionOwner();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Faction":
            ConverterHelpers.ReadFormLink<IFactionGetter>(retval.Faction, ref reader);
            break;
        case "RequiredRank":
            retval.RequiredRank = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFindMatchingRefFromEventGetter_Converter : JsonConverter<IFindMatchingRefFromEventGetter>
{
  public override IFindMatchingRefFromEventGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFindMatchingRefFromEventGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "FindMatchingRefFromEvent");
    writer.WritePropertyName("EventData");
    JsonSerializer.Serialize(writer, value.EventData, options);
    writer.WritePropertyName("FromEvent");
    JsonSerializer.Serialize(writer, value.FromEvent, options);
    writer.WriteEndObject();
  }
}
public class FindMatchingRefFromEvent_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.FindMatchingRefFromEvent>
{
  private IFindMatchingRefFromEventGetter_Converter _getterConverter;
  public FindMatchingRefFromEvent_Converter(IFindMatchingRefFromEventGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.FindMatchingRefFromEvent value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFindMatchingRefFromEventGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.FindMatchingRefFromEvent Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.FindMatchingRefFromEvent();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EventData":
            break;
        case "FromEvent":
            retval.FromEvent = JsonSerializer.Deserialize<RecordType?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFindMatchingRefNearAliasGetter_Converter : JsonConverter<IFindMatchingRefNearAliasGetter>
{
  public override IFindMatchingRefNearAliasGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFindMatchingRefNearAliasGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "FindMatchingRefNearAlias");
    writer.WritePropertyName("AliasIndex");
    JsonSerializer.Serialize(writer, value.AliasIndex, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class FindMatchingRefNearAlias_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.FindMatchingRefNearAlias>
{
  private IFindMatchingRefNearAliasGetter_Converter _getterConverter;
  public FindMatchingRefNearAlias_Converter(IFindMatchingRefNearAliasGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.FindMatchingRefNearAlias value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFindMatchingRefNearAliasGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.FindMatchingRefNearAlias Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.FindMatchingRefNearAlias();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AliasIndex":
            retval.AliasIndex = JsonSerializer.Deserialize<Int16?>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<TypeEnum?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFloraGetter_Converter : JsonConverter<IFloraGetter>
{
  public override IFloraGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFloraGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Flora");
    writer.WritePropertyName("ActivateTextOverride");
    JsonSerializer.Serialize(writer, value.ActivateTextOverride, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FNAM");
    JsonSerializer.Serialize(writer, value.FNAM, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HarvestSound");
    JsonSerializer.Serialize(writer, value.HarvestSound, options);
    writer.WritePropertyName("Ingredient");
    JsonSerializer.Serialize(writer, value.Ingredient, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PNAM");
    JsonSerializer.Serialize(writer, value.PNAM, options);
    writer.WritePropertyName("Production");
    JsonSerializer.Serialize(writer, value.Production, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class Flora_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Flora>
{
  private IFloraGetter_Converter _getterConverter;
  public Flora_Converter(IFloraGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Flora value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFloraGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Flora Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Flora();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateTextOverride":
            retval.ActivateTextOverride = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FNAM":
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HarvestSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.HarvestSound, ref reader);
            break;
        case "Ingredient":
            ConverterHelpers.ReadFormLinkNullable<IHarvestTargetGetter>(retval.Ingredient, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PNAM":
            break;
        case "Production":
            retval.Production = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SeasonalIngredientProduction>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFootstepGetter_Converter : JsonConverter<IFootstepGetter>
{
  public override IFootstepGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFootstepGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Footstep");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("ImpactDataSet");
    JsonSerializer.Serialize(writer, value.ImpactDataSet, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Tag");
    JsonSerializer.Serialize(writer, value.Tag, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Footstep_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Footstep>
{
  private IFootstepGetter_Converter _getterConverter;
  public Footstep_Converter(IFootstepGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Footstep value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFootstepGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Footstep Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Footstep();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "ImpactDataSet":
            ConverterHelpers.ReadFormLink<IImpactDataSetGetter>(retval.ImpactDataSet, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Tag":
            retval.Tag = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFootstepSetGetter_Converter : JsonConverter<IFootstepSetGetter>
{
  public override IFootstepSetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFootstepSetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "FootstepSet");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.RunForwardAlternateFootsteps != default)
    {
      writer.WritePropertyName("RunForwardAlternateFootsteps");
      writer.WriteStartArray();
      foreach (var itm in value.RunForwardAlternateFootsteps)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RunForwardAlternateFootsteps");
    }
    if (value.RunForwardFootsteps != default)
    {
      writer.WritePropertyName("RunForwardFootsteps");
      writer.WriteStartArray();
      foreach (var itm in value.RunForwardFootsteps)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RunForwardFootsteps");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    if (value.WalkForwardAlternateFootsteps != default)
    {
      writer.WritePropertyName("WalkForwardAlternateFootsteps");
      writer.WriteStartArray();
      foreach (var itm in value.WalkForwardAlternateFootsteps)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("WalkForwardAlternateFootsteps");
    }
    if (value.WalkForwardAlternateFootsteps2 != default)
    {
      writer.WritePropertyName("WalkForwardAlternateFootsteps2");
      writer.WriteStartArray();
      foreach (var itm in value.WalkForwardAlternateFootsteps2)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("WalkForwardAlternateFootsteps2");
    }
    if (value.WalkForwardFootsteps != default)
    {
      writer.WritePropertyName("WalkForwardFootsteps");
      writer.WriteStartArray();
      foreach (var itm in value.WalkForwardFootsteps)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("WalkForwardFootsteps");
    }
    writer.WriteEndObject();
  }
}
public class FootstepSet_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.FootstepSet>
{
  private IFootstepSetGetter_Converter _getterConverter;
  public FootstepSet_Converter(IFootstepSetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.FootstepSet value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFootstepSetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.FootstepSet Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.FootstepSet();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "RunForwardAlternateFootsteps":
            ConverterHelpers.ReadFormLinkList<IFootstepGetter>(retval.RunForwardAlternateFootsteps, ref reader);
            break;
        case "RunForwardFootsteps":
            ConverterHelpers.ReadFormLinkList<IFootstepGetter>(retval.RunForwardFootsteps, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "WalkForwardAlternateFootsteps":
            ConverterHelpers.ReadFormLinkList<IFootstepGetter>(retval.WalkForwardAlternateFootsteps, ref reader);
            break;
        case "WalkForwardAlternateFootsteps2":
            ConverterHelpers.ReadFormLinkList<IFootstepGetter>(retval.WalkForwardAlternateFootsteps2, ref reader);
            break;
        case "WalkForwardFootsteps":
            ConverterHelpers.ReadFormLinkList<IFootstepGetter>(retval.WalkForwardFootsteps, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFormListGetter_Converter : JsonConverter<IFormListGetter>
{
  public override IFormListGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFormListGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "FormList");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Items != default)
    {
      writer.WritePropertyName("Items");
      writer.WriteStartArray();
      foreach (var itm in value.Items)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Items");
    }
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class FormList_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.FormList>
{
  private IFormListGetter_Converter _getterConverter;
  public FormList_Converter(IFormListGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.FormList value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFormListGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.FormList Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.FormList();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Items":
            ConverterHelpers.ReadFormLinkList<ISkyrimMajorRecordGetter>(retval.Items, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFunctionConditionDataGetter_Converter : JsonConverter<IFunctionConditionDataGetter>
{
  public override IFunctionConditionDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFunctionConditionDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "FunctionConditionData");
    writer.WritePropertyName("Function");
    JsonSerializer.Serialize(writer, value.Function, options);
    writer.WritePropertyName("ParameterOneNumber");
    JsonSerializer.Serialize(writer, value.ParameterOneNumber, options);
    writer.WritePropertyName("ParameterOneRecord");
    JsonSerializer.Serialize(writer, value.ParameterOneRecord, options);
    writer.WritePropertyName("ParameterOneString");
    JsonSerializer.Serialize(writer, value.ParameterOneString, options);
    writer.WritePropertyName("ParameterTwoNumber");
    JsonSerializer.Serialize(writer, value.ParameterTwoNumber, options);
    writer.WritePropertyName("ParameterTwoRecord");
    JsonSerializer.Serialize(writer, value.ParameterTwoRecord, options);
    writer.WritePropertyName("ParameterTwoString");
    JsonSerializer.Serialize(writer, value.ParameterTwoString, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WritePropertyName("RunOnType");
    JsonSerializer.Serialize(writer, value.RunOnType, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WritePropertyName("Unknown3");
    JsonSerializer.Serialize(writer, value.Unknown3, options);
    writer.WriteEndObject();
  }
}
public class FunctionConditionData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.FunctionConditionData>
{
  private IFunctionConditionDataGetter_Converter _getterConverter;
  public FunctionConditionData_Converter(IFunctionConditionDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.FunctionConditionData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFunctionConditionDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.FunctionConditionData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.FunctionConditionData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Function":
            retval.Function = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Condition.Function>(ref reader, options);
            break;
        case "ParameterOneNumber":
            retval.ParameterOneNumber = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ParameterOneRecord":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.ParameterOneRecord, ref reader);
            break;
        case "ParameterOneString":
            retval.ParameterOneString = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ParameterTwoNumber":
            retval.ParameterTwoNumber = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ParameterTwoRecord":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.ParameterTwoRecord, ref reader);
            break;
        case "ParameterTwoString":
            retval.ParameterTwoString = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.Reference, ref reader);
            break;
        case "RunOnType":
            retval.RunOnType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Condition.RunOnType>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Unknown3":
            retval.Unknown3 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFurnitureGetter_Converter : JsonConverter<IFurnitureGetter>
{
  public override IFurnitureGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFurnitureGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Furniture");
    writer.WritePropertyName("AssociatedSpell");
    JsonSerializer.Serialize(writer, value.AssociatedSpell, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("InteractionKeyword");
    JsonSerializer.Serialize(writer, value.InteractionKeyword, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.Markers != default)
    {
      writer.WritePropertyName("Markers");
      writer.WriteStartArray();
      foreach (var itm in value.Markers)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Markers");
    }
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("ModelFilename");
    JsonSerializer.Serialize(writer, value.ModelFilename, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PNAM");
    JsonSerializer.Serialize(writer, value.PNAM, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("WorkbenchData");
    JsonSerializer.Serialize(writer, value.WorkbenchData, options);
    writer.WriteEndObject();
  }
}
public class Furniture_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Furniture>
{
  private IFurnitureGetter_Converter _getterConverter;
  public Furniture_Converter(IFurnitureGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Furniture value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFurnitureGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Furniture Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Furniture();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AssociatedSpell":
            ConverterHelpers.ReadFormLinkNullable<ISpellGetter>(retval.AssociatedSpell, ref reader);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "InteractionKeyword":
            ConverterHelpers.ReadFormLinkNullable<IKeywordGetter>(retval.InteractionKeyword, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Furniture.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Markers":
            ConverterHelpers.ReadExtendedList<FurnitureMarker>(retval.Markers, ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "ModelFilename":
            retval.ModelFilename = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PNAM":
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "WorkbenchData":
            retval.WorkbenchData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WorkbenchData>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IFurnitureMarkerGetter_Converter : JsonConverter<IFurnitureMarkerGetter>
{
  public override IFurnitureMarkerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IFurnitureMarkerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "FurnitureMarker");
    writer.WritePropertyName("DisabledEntryPoints");
    JsonSerializer.Serialize(writer, value.DisabledEntryPoints, options);
    writer.WritePropertyName("Enabled");
    JsonSerializer.Serialize(writer, value.Enabled, options);
    writer.WritePropertyName("EntryPoints");
    JsonSerializer.Serialize(writer, value.EntryPoints, options);
    writer.WritePropertyName("MarkerKeyword");
    JsonSerializer.Serialize(writer, value.MarkerKeyword, options);
    writer.WriteEndObject();
  }
}
public class FurnitureMarker_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.FurnitureMarker>
{
  private IFurnitureMarkerGetter_Converter _getterConverter;
  public FurnitureMarker_Converter(IFurnitureMarkerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.FurnitureMarker value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IFurnitureMarkerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.FurnitureMarker Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.FurnitureMarker();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DisabledEntryPoints":
            retval.DisabledEntryPoints = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EntryPoints>(ref reader, options);
            break;
        case "Enabled":
            retval.Enabled = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "EntryPoints":
            retval.EntryPoints = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EntryPoints>(ref reader, options);
            break;
        case "MarkerKeyword":
            ConverterHelpers.ReadFormLinkNullable<IKeywordGetter>(retval.MarkerKeyword, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IGameSettingBoolGetter_Converter : JsonConverter<IGameSettingBoolGetter>
{
  public override IGameSettingBoolGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IGameSettingBoolGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "GameSettingBool");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class GameSettingBool_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.GameSettingBool>
{
  private IGameSettingBoolGetter_Converter _getterConverter;
  public GameSettingBool_Converter(IGameSettingBoolGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.GameSettingBool value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IGameSettingBoolGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.GameSettingBool Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.GameSettingBool();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Boolean?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SettingType":
            retval.SettingType = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.Records.GameSettingType>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IGameSettingFloatGetter_Converter : JsonConverter<IGameSettingFloatGetter>
{
  public override IGameSettingFloatGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IGameSettingFloatGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "GameSettingFloat");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class GameSettingFloat_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.GameSettingFloat>
{
  private IGameSettingFloatGetter_Converter _getterConverter;
  public GameSettingFloat_Converter(IGameSettingFloatGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.GameSettingFloat value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IGameSettingFloatGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.GameSettingFloat Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.GameSettingFloat();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "RawData":
            retval.RawData = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SettingType":
            retval.SettingType = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.Records.GameSettingType>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IGameSettingIntGetter_Converter : JsonConverter<IGameSettingIntGetter>
{
  public override IGameSettingIntGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IGameSettingIntGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "GameSettingInt");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class GameSettingInt_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.GameSettingInt>
{
  private IGameSettingIntGetter_Converter _getterConverter;
  public GameSettingInt_Converter(IGameSettingIntGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.GameSettingInt value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IGameSettingIntGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.GameSettingInt Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.GameSettingInt();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "RawData":
            retval.RawData = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SettingType":
            retval.SettingType = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.Records.GameSettingType>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IGameSettingStringGetter_Converter : JsonConverter<IGameSettingStringGetter>
{
  public override IGameSettingStringGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IGameSettingStringGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "GameSettingString");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class GameSettingString_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.GameSettingString>
{
  private IGameSettingStringGetter_Converter _getterConverter;
  public GameSettingString_Converter(IGameSettingStringGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.GameSettingString value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IGameSettingStringGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.GameSettingString Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.GameSettingString();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SettingType":
            retval.SettingType = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.Records.GameSettingType>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IGetEventDataGetter_Converter : JsonConverter<IGetEventDataGetter>
{
  public override IGetEventDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IGetEventDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "GetEventData");
    writer.WritePropertyName("EventFunction");
    JsonSerializer.Serialize(writer, value.EventFunction, options);
    writer.WritePropertyName("EventMember");
    JsonSerializer.Serialize(writer, value.EventMember, options);
    writer.WritePropertyName("Parameter3");
    JsonSerializer.Serialize(writer, value.Parameter3, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WritePropertyName("RunOnType");
    JsonSerializer.Serialize(writer, value.RunOnType, options);
    writer.WritePropertyName("Unknown3");
    JsonSerializer.Serialize(writer, value.Unknown3, options);
    writer.WriteEndObject();
  }
}
public class GetEventData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.GetEventData>
{
  private IGetEventDataGetter_Converter _getterConverter;
  public GetEventData_Converter(IGetEventDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.GetEventData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IGetEventDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.GetEventData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.GetEventData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EventFunction":
            retval.EventFunction = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "EventMember":
            retval.EventMember = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Parameter3":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.Parameter3, ref reader);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.Reference, ref reader);
            break;
        case "RunOnType":
            retval.RunOnType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Condition.RunOnType>(ref reader, options);
            break;
        case "Unknown3":
            retval.Unknown3 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IGlobalFloatGetter_Converter : JsonConverter<IGlobalFloatGetter>
{
  public override IGlobalFloatGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IGlobalFloatGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "GlobalFloat");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("TypeChar");
    JsonSerializer.Serialize(writer, value.TypeChar, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class GlobalFloat_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.GlobalFloat>
{
  private IGlobalFloatGetter_Converter _getterConverter;
  public GlobalFloat_Converter(IGlobalFloatGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.GlobalFloat value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IGlobalFloatGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.GlobalFloat Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.GlobalFloat();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Global.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "RawFloat":
            retval.RawFloat = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TypeChar":
            retval.TypeChar = JsonSerializer.Deserialize<System.Char>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IGlobalIntGetter_Converter : JsonConverter<IGlobalIntGetter>
{
  public override IGlobalIntGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IGlobalIntGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "GlobalInt");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("TypeChar");
    JsonSerializer.Serialize(writer, value.TypeChar, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class GlobalInt_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.GlobalInt>
{
  private IGlobalIntGetter_Converter _getterConverter;
  public GlobalInt_Converter(IGlobalIntGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.GlobalInt value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IGlobalIntGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.GlobalInt Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.GlobalInt();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Global.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "RawFloat":
            retval.RawFloat = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TypeChar":
            retval.TypeChar = JsonSerializer.Deserialize<System.Char>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IGlobalShortGetter_Converter : JsonConverter<IGlobalShortGetter>
{
  public override IGlobalShortGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IGlobalShortGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "GlobalShort");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("TypeChar");
    JsonSerializer.Serialize(writer, value.TypeChar, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class GlobalShort_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.GlobalShort>
{
  private IGlobalShortGetter_Converter _getterConverter;
  public GlobalShort_Converter(IGlobalShortGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.GlobalShort value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IGlobalShortGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.GlobalShort Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.GlobalShort();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Int16?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Global.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "RawFloat":
            retval.RawFloat = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TypeChar":
            retval.TypeChar = JsonSerializer.Deserialize<System.Char>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IGrassGetter_Converter : JsonConverter<IGrassGetter>
{
  public override IGrassGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IGrassGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Grass");
    writer.WritePropertyName("ColorRange");
    JsonSerializer.Serialize(writer, value.ColorRange, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Density");
    JsonSerializer.Serialize(writer, value.Density, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HeightRange");
    JsonSerializer.Serialize(writer, value.HeightRange, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MaxSlope");
    JsonSerializer.Serialize(writer, value.MaxSlope, options);
    writer.WritePropertyName("MinSlope");
    JsonSerializer.Serialize(writer, value.MinSlope, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PositionRange");
    JsonSerializer.Serialize(writer, value.PositionRange, options);
    writer.WritePropertyName("UnitsFromWater");
    JsonSerializer.Serialize(writer, value.UnitsFromWater, options);
    writer.WritePropertyName("UnitsFromWaterType");
    JsonSerializer.Serialize(writer, value.UnitsFromWaterType, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WritePropertyName("Unknown3");
    JsonSerializer.Serialize(writer, value.Unknown3, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("WavePeriod");
    JsonSerializer.Serialize(writer, value.WavePeriod, options);
    writer.WriteEndObject();
  }
}
public class Grass_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Grass>
{
  private IGrassGetter_Converter _getterConverter;
  public Grass_Converter(IGrassGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Grass value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IGrassGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Grass Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Grass();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ColorRange":
            retval.ColorRange = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Grass.DATADataType>(ref reader, options);
            break;
        case "Density":
            retval.Density = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Grass.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HeightRange":
            retval.HeightRange = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MaxSlope":
            retval.MaxSlope = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "MinSlope":
            retval.MinSlope = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PositionRange":
            retval.PositionRange = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "UnitsFromWater":
            retval.UnitsFromWater = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "UnitsFromWaterType":
            retval.UnitsFromWaterType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Grass.UnitsFromWaterTypeEnum>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Unknown3":
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "WavePeriod":
            retval.WavePeriod = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IHairGetter_Converter : JsonConverter<IHairGetter>
{
  public override IHairGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IHairGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Hair");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Hair_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Hair>
{
  private IHairGetter_Converter _getterConverter;
  public Hair_Converter(IHairGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Hair value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IHairGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Hair Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Hair();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IHazardGetter_Converter : JsonConverter<IHazardGetter>
{
  public override IHazardGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IHazardGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Hazard");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("ImageSpaceModifier");
    JsonSerializer.Serialize(writer, value.ImageSpaceModifier, options);
    writer.WritePropertyName("ImageSpaceRadius");
    JsonSerializer.Serialize(writer, value.ImageSpaceRadius, options);
    writer.WritePropertyName("ImpactDataSet");
    JsonSerializer.Serialize(writer, value.ImpactDataSet, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("Lifetime");
    JsonSerializer.Serialize(writer, value.Lifetime, options);
    writer.WritePropertyName("Light");
    JsonSerializer.Serialize(writer, value.Light, options);
    writer.WritePropertyName("Limit");
    JsonSerializer.Serialize(writer, value.Limit, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Radius");
    JsonSerializer.Serialize(writer, value.Radius, options);
    writer.WritePropertyName("Sound");
    JsonSerializer.Serialize(writer, value.Sound, options);
    writer.WritePropertyName("Spell");
    JsonSerializer.Serialize(writer, value.Spell, options);
    writer.WritePropertyName("TargetInterval");
    JsonSerializer.Serialize(writer, value.TargetInterval, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Hazard_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Hazard>
{
  private IHazardGetter_Converter _getterConverter;
  public Hazard_Converter(IHazardGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Hazard value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IHazardGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Hazard Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Hazard();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Hazard.DATADataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Hazard.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "ImageSpaceModifier":
            ConverterHelpers.ReadFormLinkNullable<IImageSpaceAdapterGetter>(retval.ImageSpaceModifier, ref reader);
            break;
        case "ImageSpaceRadius":
            retval.ImageSpaceRadius = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ImpactDataSet":
            ConverterHelpers.ReadFormLink<IImpactDataSetGetter>(retval.ImpactDataSet, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Lifetime":
            retval.Lifetime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Light":
            ConverterHelpers.ReadFormLink<ILightGetter>(retval.Light, ref reader);
            break;
        case "Limit":
            retval.Limit = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "Radius":
            retval.Radius = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Sound":
            ConverterHelpers.ReadFormLink<ISoundDescriptorGetter>(retval.Sound, ref reader);
            break;
        case "Spell":
            ConverterHelpers.ReadFormLink<IEffectRecordGetter>(retval.Spell, ref reader);
            break;
        case "TargetInterval":
            retval.TargetInterval = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IHeadDataGetter_Converter : JsonConverter<IHeadDataGetter>
{
  public override IHeadDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IHeadDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "HeadData");
    if (value.AvailableHairColors != default)
    {
      writer.WritePropertyName("AvailableHairColors");
      writer.WriteStartArray();
      foreach (var itm in value.AvailableHairColors)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("AvailableHairColors");
    }
    writer.WritePropertyName("AvailableMorphs");
    JsonSerializer.Serialize(writer, value.AvailableMorphs, options);
    writer.WritePropertyName("DefaultFaceTexture");
    JsonSerializer.Serialize(writer, value.DefaultFaceTexture, options);
    if (value.FaceDetails != default)
    {
      writer.WritePropertyName("FaceDetails");
      writer.WriteStartArray();
      foreach (var itm in value.FaceDetails)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("FaceDetails");
    }
    if (value.HeadParts != default)
    {
      writer.WritePropertyName("HeadParts");
      writer.WriteStartArray();
      foreach (var itm in value.HeadParts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HeadParts");
    }
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    if (value.RacePresets != default)
    {
      writer.WritePropertyName("RacePresets");
      writer.WriteStartArray();
      foreach (var itm in value.RacePresets)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RacePresets");
    }
    if (value.TintMasks != default)
    {
      writer.WritePropertyName("TintMasks");
      writer.WriteStartArray();
      foreach (var itm in value.TintMasks)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("TintMasks");
    }
    writer.WriteEndObject();
  }
}
public class HeadData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.HeadData>
{
  private IHeadDataGetter_Converter _getterConverter;
  public HeadData_Converter(IHeadDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.HeadData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IHeadDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.HeadData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.HeadData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AvailableHairColors":
            ConverterHelpers.ReadFormLinkList<IColorRecordGetter>(retval.AvailableHairColors, ref reader);
            break;
        case "AvailableMorphs":
            retval.AvailableMorphs = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AvailableMorphs>(ref reader, options);
            break;
        case "DefaultFaceTexture":
            ConverterHelpers.ReadFormLinkNullable<ITextureSetGetter>(retval.DefaultFaceTexture, ref reader);
            break;
        case "FaceDetails":
            ConverterHelpers.ReadFormLinkList<ITextureSetGetter>(retval.FaceDetails, ref reader);
            break;
        case "HeadParts":
            ConverterHelpers.ReadExtendedList<HeadPartReference>(retval.HeadParts, ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "RacePresets":
            ConverterHelpers.ReadFormLinkList<INpcGetter>(retval.RacePresets, ref reader);
            break;
        case "TintMasks":
            ConverterHelpers.ReadExtendedList<TintAssets>(retval.TintMasks, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IHeadPartGetter_Converter : JsonConverter<IHeadPartGetter>
{
  public override IHeadPartGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IHeadPartGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "HeadPart");
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.ExtraParts != default)
    {
      writer.WritePropertyName("ExtraParts");
      writer.WriteStartArray();
      foreach (var itm in value.ExtraParts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ExtraParts");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    if (value.Parts != default)
    {
      writer.WritePropertyName("Parts");
      writer.WriteStartArray();
      foreach (var itm in value.Parts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Parts");
    }
    writer.WritePropertyName("TextureSet");
    JsonSerializer.Serialize(writer, value.TextureSet, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("ValidRaces");
    JsonSerializer.Serialize(writer, value.ValidRaces, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class HeadPart_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.HeadPart>
{
  private IHeadPartGetter_Converter _getterConverter;
  public HeadPart_Converter(IHeadPartGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.HeadPart value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IHeadPartGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.HeadPart Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.HeadPart();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Color":
            ConverterHelpers.ReadFormLinkNullable<IColorRecordGetter>(retval.Color, ref reader);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ExtraParts":
            ConverterHelpers.ReadFormLinkList<IHeadPartGetter>(retval.ExtraParts, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.HeadPart.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.HeadPart.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Parts":
            ConverterHelpers.ReadExtendedList<Part>(retval.Parts, ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TextureSet":
            ConverterHelpers.ReadFormLinkNullable<ITextureSetGetter>(retval.TextureSet, ref reader);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<TypeEnum?>(ref reader, options);
            break;
        case "ValidRaces":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.ValidRaces, ref reader);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IHeadPartReferenceGetter_Converter : JsonConverter<IHeadPartReferenceGetter>
{
  public override IHeadPartReferenceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IHeadPartReferenceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "HeadPartReference");
    writer.WritePropertyName("Head");
    JsonSerializer.Serialize(writer, value.Head, options);
    writer.WritePropertyName("Number");
    JsonSerializer.Serialize(writer, value.Number, options);
    writer.WriteEndObject();
  }
}
public class HeadPartReference_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.HeadPartReference>
{
  private IHeadPartReferenceGetter_Converter _getterConverter;
  public HeadPartReference_Converter(IHeadPartReferenceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.HeadPartReference value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IHeadPartReferenceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.HeadPartReference Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.HeadPartReference();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Head":
            ConverterHelpers.ReadFormLinkNullable<IHeadPartGetter>(retval.Head, ref reader);
            break;
        case "Number":
            retval.Number = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IIconsGetter_Converter : JsonConverter<IIconsGetter>
{
  public override IIconsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IIconsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Icons");
    writer.WritePropertyName("LargeIconFilename");
    JsonSerializer.Serialize(writer, value.LargeIconFilename, options);
    writer.WritePropertyName("SmallIconFilename");
    JsonSerializer.Serialize(writer, value.SmallIconFilename, options);
    writer.WriteEndObject();
  }
}
public class Icons_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Icons>
{
  private IIconsGetter_Converter _getterConverter;
  public Icons_Converter(IIconsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Icons value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IIconsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Icons Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Icons();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "LargeIconFilename":
            retval.LargeIconFilename = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "SmallIconFilename":
            retval.SmallIconFilename = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IIdleAnimationGetter_Converter : JsonConverter<IIdleAnimationGetter>
{
  public override IIdleAnimationGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IIdleAnimationGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "IdleAnimation");
    writer.WritePropertyName("AnimationEvent");
    JsonSerializer.Serialize(writer, value.AnimationEvent, options);
    writer.WritePropertyName("AnimationGroupSection");
    JsonSerializer.Serialize(writer, value.AnimationGroupSection, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Filename");
    JsonSerializer.Serialize(writer, value.Filename, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LoopingSecondsMax");
    JsonSerializer.Serialize(writer, value.LoopingSecondsMax, options);
    writer.WritePropertyName("LoopingSecondsMin");
    JsonSerializer.Serialize(writer, value.LoopingSecondsMin, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.RelatedIdles != default)
    {
      writer.WritePropertyName("RelatedIdles");
      writer.WriteStartArray();
      foreach (var itm in value.RelatedIdles)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RelatedIdles");
    }
    writer.WritePropertyName("ReplayDelay");
    JsonSerializer.Serialize(writer, value.ReplayDelay, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class IdleAnimation_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.IdleAnimation>
{
  private IIdleAnimationGetter_Converter _getterConverter;
  public IdleAnimation_Converter(IIdleAnimationGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.IdleAnimation value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IIdleAnimationGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.IdleAnimation Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.IdleAnimation();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AnimationEvent":
            retval.AnimationEvent = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "AnimationGroupSection":
            retval.AnimationGroupSection = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.IdleAnimation.DATADataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Filename":
            retval.Filename = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.IdleAnimation.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LoopingSecondsMax":
            retval.LoopingSecondsMax = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "LoopingSecondsMin":
            retval.LoopingSecondsMin = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "RelatedIdles":
            ConverterHelpers.ReadFormLinkList<IIdleRelationGetter>(retval.RelatedIdles, ref reader);
            break;
        case "ReplayDelay":
            retval.ReplayDelay = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IIdleMarkerGetter_Converter : JsonConverter<IIdleMarkerGetter>
{
  public override IIdleMarkerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IIdleMarkerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "IdleMarker");
    if (value.Animations != default)
    {
      writer.WritePropertyName("Animations");
      writer.WriteStartArray();
      foreach (var itm in value.Animations)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Animations");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IdleTimer");
    JsonSerializer.Serialize(writer, value.IdleTimer, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class IdleMarker_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.IdleMarker>
{
  private IIdleMarkerGetter_Converter _getterConverter;
  public IdleMarker_Converter(IIdleMarkerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.IdleMarker value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IIdleMarkerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.IdleMarker Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.IdleMarker();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Animations":
            ConverterHelpers.ReadFormLinkList<IIdleAnimationGetter>(retval.Animations, ref reader);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IdleTimer":
            retval.IdleTimer = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.IdleMarker.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IImageSpaceGetter_Converter : JsonConverter<IImageSpaceGetter>
{
  public override IImageSpaceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IImageSpaceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ImageSpace");
    writer.WritePropertyName("Cinematic");
    JsonSerializer.Serialize(writer, value.Cinematic, options);
    writer.WritePropertyName("DepthOfField");
    JsonSerializer.Serialize(writer, value.DepthOfField, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("ENAM");
    JsonSerializer.Serialize(writer, value.ENAM, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Hdr");
    JsonSerializer.Serialize(writer, value.Hdr, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Tint");
    JsonSerializer.Serialize(writer, value.Tint, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class ImageSpace_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ImageSpace>
{
  private IImageSpaceGetter_Converter _getterConverter;
  public ImageSpace_Converter(IImageSpaceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ImageSpace value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IImageSpaceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ImageSpace Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ImageSpace();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Cinematic":
            retval.Cinematic = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ImageSpaceCinematic>(ref reader, options);
            break;
        case "DepthOfField":
            retval.DepthOfField = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ImageSpaceDepthOfField>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ENAM":
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Hdr":
            retval.Hdr = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ImageSpaceHdr>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Tint":
            retval.Tint = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ImageSpaceTint>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IImageSpaceAdapterGetter_Converter : JsonConverter<IImageSpaceAdapterGetter>
{
  public override IImageSpaceAdapterGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IImageSpaceAdapterGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ImageSpaceAdapter");
    if (value.BlurRadius != default)
    {
      writer.WritePropertyName("BlurRadius");
      writer.WriteStartArray();
      foreach (var itm in value.BlurRadius)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("BlurRadius");
    }
    if (value.CinematicBrightnessAdd != default)
    {
      writer.WritePropertyName("CinematicBrightnessAdd");
      writer.WriteStartArray();
      foreach (var itm in value.CinematicBrightnessAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("CinematicBrightnessAdd");
    }
    if (value.CinematicBrightnessMult != default)
    {
      writer.WritePropertyName("CinematicBrightnessMult");
      writer.WriteStartArray();
      foreach (var itm in value.CinematicBrightnessMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("CinematicBrightnessMult");
    }
    if (value.CinematicContrastAdd != default)
    {
      writer.WritePropertyName("CinematicContrastAdd");
      writer.WriteStartArray();
      foreach (var itm in value.CinematicContrastAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("CinematicContrastAdd");
    }
    if (value.CinematicContrastMult != default)
    {
      writer.WritePropertyName("CinematicContrastMult");
      writer.WriteStartArray();
      foreach (var itm in value.CinematicContrastMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("CinematicContrastMult");
    }
    if (value.CinematicSaturationAdd != default)
    {
      writer.WritePropertyName("CinematicSaturationAdd");
      writer.WriteStartArray();
      foreach (var itm in value.CinematicSaturationAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("CinematicSaturationAdd");
    }
    if (value.CinematicSaturationMult != default)
    {
      writer.WritePropertyName("CinematicSaturationMult");
      writer.WriteStartArray();
      foreach (var itm in value.CinematicSaturationMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("CinematicSaturationMult");
    }
    if (value.DepthOfFieldDistance != default)
    {
      writer.WritePropertyName("DepthOfFieldDistance");
      writer.WriteStartArray();
      foreach (var itm in value.DepthOfFieldDistance)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DepthOfFieldDistance");
    }
    writer.WritePropertyName("DepthOfFieldFlags");
    JsonSerializer.Serialize(writer, value.DepthOfFieldFlags, options);
    if (value.DepthOfFieldRange != default)
    {
      writer.WritePropertyName("DepthOfFieldRange");
      writer.WriteStartArray();
      foreach (var itm in value.DepthOfFieldRange)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DepthOfFieldRange");
    }
    if (value.DepthOfFieldStrength != default)
    {
      writer.WritePropertyName("DepthOfFieldStrength");
      writer.WriteStartArray();
      foreach (var itm in value.DepthOfFieldStrength)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DepthOfFieldStrength");
    }
    writer.WritePropertyName("DNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.DNAMDataTypeState, options);
    if (value.DoubleVisionStrength != default)
    {
      writer.WritePropertyName("DoubleVisionStrength");
      writer.WriteStartArray();
      foreach (var itm in value.DoubleVisionStrength)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DoubleVisionStrength");
    }
    writer.WritePropertyName("Duration");
    JsonSerializer.Serialize(writer, value.Duration, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.FadeColor != default)
    {
      writer.WritePropertyName("FadeColor");
      writer.WriteStartArray();
      foreach (var itm in value.FadeColor)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("FadeColor");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    if (value.HdrBloomBlurRadiusAdd != default)
    {
      writer.WritePropertyName("HdrBloomBlurRadiusAdd");
      writer.WriteStartArray();
      foreach (var itm in value.HdrBloomBlurRadiusAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrBloomBlurRadiusAdd");
    }
    if (value.HdrBloomBlurRadiusMult != default)
    {
      writer.WritePropertyName("HdrBloomBlurRadiusMult");
      writer.WriteStartArray();
      foreach (var itm in value.HdrBloomBlurRadiusMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrBloomBlurRadiusMult");
    }
    if (value.HdrBloomScaleAdd != default)
    {
      writer.WritePropertyName("HdrBloomScaleAdd");
      writer.WriteStartArray();
      foreach (var itm in value.HdrBloomScaleAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrBloomScaleAdd");
    }
    if (value.HdrBloomScaleMult != default)
    {
      writer.WritePropertyName("HdrBloomScaleMult");
      writer.WriteStartArray();
      foreach (var itm in value.HdrBloomScaleMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrBloomScaleMult");
    }
    if (value.HdrBloomThresholdAdd != default)
    {
      writer.WritePropertyName("HdrBloomThresholdAdd");
      writer.WriteStartArray();
      foreach (var itm in value.HdrBloomThresholdAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrBloomThresholdAdd");
    }
    if (value.HdrBloomThresholdMult != default)
    {
      writer.WritePropertyName("HdrBloomThresholdMult");
      writer.WriteStartArray();
      foreach (var itm in value.HdrBloomThresholdMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrBloomThresholdMult");
    }
    if (value.HdrEyeAdaptSpeedAdd != default)
    {
      writer.WritePropertyName("HdrEyeAdaptSpeedAdd");
      writer.WriteStartArray();
      foreach (var itm in value.HdrEyeAdaptSpeedAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrEyeAdaptSpeedAdd");
    }
    if (value.HdrEyeAdaptSpeedMult != default)
    {
      writer.WritePropertyName("HdrEyeAdaptSpeedMult");
      writer.WriteStartArray();
      foreach (var itm in value.HdrEyeAdaptSpeedMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrEyeAdaptSpeedMult");
    }
    if (value.HdrSkyScaleAdd != default)
    {
      writer.WritePropertyName("HdrSkyScaleAdd");
      writer.WriteStartArray();
      foreach (var itm in value.HdrSkyScaleAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrSkyScaleAdd");
    }
    if (value.HdrSkyScaleMult != default)
    {
      writer.WritePropertyName("HdrSkyScaleMult");
      writer.WriteStartArray();
      foreach (var itm in value.HdrSkyScaleMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrSkyScaleMult");
    }
    if (value.HdrSunlightScaleAdd != default)
    {
      writer.WritePropertyName("HdrSunlightScaleAdd");
      writer.WriteStartArray();
      foreach (var itm in value.HdrSunlightScaleAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrSunlightScaleAdd");
    }
    if (value.HdrSunlightScaleMult != default)
    {
      writer.WritePropertyName("HdrSunlightScaleMult");
      writer.WriteStartArray();
      foreach (var itm in value.HdrSunlightScaleMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrSunlightScaleMult");
    }
    if (value.HdrTargetLumMaxAdd != default)
    {
      writer.WritePropertyName("HdrTargetLumMaxAdd");
      writer.WriteStartArray();
      foreach (var itm in value.HdrTargetLumMaxAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrTargetLumMaxAdd");
    }
    if (value.HdrTargetLumMaxMult != default)
    {
      writer.WritePropertyName("HdrTargetLumMaxMult");
      writer.WriteStartArray();
      foreach (var itm in value.HdrTargetLumMaxMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrTargetLumMaxMult");
    }
    if (value.HdrTargetLumMinAdd != default)
    {
      writer.WritePropertyName("HdrTargetLumMinAdd");
      writer.WriteStartArray();
      foreach (var itm in value.HdrTargetLumMinAdd)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrTargetLumMinAdd");
    }
    if (value.HdrTargetLumMinMult != default)
    {
      writer.WritePropertyName("HdrTargetLumMinMult");
      writer.WriteStartArray();
      foreach (var itm in value.HdrTargetLumMinMult)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HdrTargetLumMinMult");
    }
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.MotionBlurStrength != default)
    {
      writer.WritePropertyName("MotionBlurStrength");
      writer.WriteStartArray();
      foreach (var itm in value.MotionBlurStrength)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("MotionBlurStrength");
    }
    writer.WritePropertyName("RadialBlurCenter");
    JsonSerializer.Serialize(writer, value.RadialBlurCenter, options);
    if (value.RadialBlurDownStart != default)
    {
      writer.WritePropertyName("RadialBlurDownStart");
      writer.WriteStartArray();
      foreach (var itm in value.RadialBlurDownStart)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RadialBlurDownStart");
    }
    writer.WritePropertyName("RadialBlurFlags");
    JsonSerializer.Serialize(writer, value.RadialBlurFlags, options);
    if (value.RadialBlurRampDown != default)
    {
      writer.WritePropertyName("RadialBlurRampDown");
      writer.WriteStartArray();
      foreach (var itm in value.RadialBlurRampDown)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RadialBlurRampDown");
    }
    if (value.RadialBlurRampUp != default)
    {
      writer.WritePropertyName("RadialBlurRampUp");
      writer.WriteStartArray();
      foreach (var itm in value.RadialBlurRampUp)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RadialBlurRampUp");
    }
    if (value.RadialBlurStart != default)
    {
      writer.WritePropertyName("RadialBlurStart");
      writer.WriteStartArray();
      foreach (var itm in value.RadialBlurStart)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RadialBlurStart");
    }
    if (value.RadialBlurStrength != default)
    {
      writer.WritePropertyName("RadialBlurStrength");
      writer.WriteStartArray();
      foreach (var itm in value.RadialBlurStrength)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RadialBlurStrength");
    }
    if (value.TintColor != default)
    {
      writer.WritePropertyName("TintColor");
      writer.WriteStartArray();
      foreach (var itm in value.TintColor)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("TintColor");
    }
    if (value.Unknown08 != default)
    {
      writer.WritePropertyName("Unknown08");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown08)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown08");
    }
    if (value.Unknown09 != default)
    {
      writer.WritePropertyName("Unknown09");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown09)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown09");
    }
    if (value.Unknown0A != default)
    {
      writer.WritePropertyName("Unknown0A");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown0A)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown0A");
    }
    if (value.Unknown0B != default)
    {
      writer.WritePropertyName("Unknown0B");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown0B)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown0B");
    }
    if (value.Unknown0C != default)
    {
      writer.WritePropertyName("Unknown0C");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown0C)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown0C");
    }
    if (value.Unknown0D != default)
    {
      writer.WritePropertyName("Unknown0D");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown0D)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown0D");
    }
    if (value.Unknown0E != default)
    {
      writer.WritePropertyName("Unknown0E");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown0E)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown0E");
    }
    if (value.Unknown0F != default)
    {
      writer.WritePropertyName("Unknown0F");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown0F)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown0F");
    }
    if (value.Unknown10 != default)
    {
      writer.WritePropertyName("Unknown10");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown10)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown10");
    }
    if (value.Unknown14 != default)
    {
      writer.WritePropertyName("Unknown14");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown14)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown14");
    }
    if (value.Unknown48 != default)
    {
      writer.WritePropertyName("Unknown48");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown48)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown48");
    }
    if (value.Unknown49 != default)
    {
      writer.WritePropertyName("Unknown49");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown49)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown49");
    }
    if (value.Unknown4A != default)
    {
      writer.WritePropertyName("Unknown4A");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown4A)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown4A");
    }
    if (value.Unknown4B != default)
    {
      writer.WritePropertyName("Unknown4B");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown4B)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown4B");
    }
    if (value.Unknown4C != default)
    {
      writer.WritePropertyName("Unknown4C");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown4C)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown4C");
    }
    if (value.Unknown4D != default)
    {
      writer.WritePropertyName("Unknown4D");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown4D)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown4D");
    }
    if (value.Unknown4E != default)
    {
      writer.WritePropertyName("Unknown4E");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown4E)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown4E");
    }
    if (value.Unknown4F != default)
    {
      writer.WritePropertyName("Unknown4F");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown4F)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown4F");
    }
    if (value.Unknown50 != default)
    {
      writer.WritePropertyName("Unknown50");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown50)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown50");
    }
    if (value.Unknown54 != default)
    {
      writer.WritePropertyName("Unknown54");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown54)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown54");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class ImageSpaceAdapter_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ImageSpaceAdapter>
{
  private IImageSpaceAdapterGetter_Converter _getterConverter;
  public ImageSpaceAdapter_Converter(IImageSpaceAdapterGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ImageSpaceAdapter value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IImageSpaceAdapterGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ImageSpaceAdapter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ImageSpaceAdapter();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BlurRadius":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.BlurRadius, ref reader, options);
            break;
        case "CinematicBrightnessAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.CinematicBrightnessAdd, ref reader, options);
            break;
        case "CinematicBrightnessMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.CinematicBrightnessMult, ref reader, options);
            break;
        case "CinematicContrastAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.CinematicContrastAdd, ref reader, options);
            break;
        case "CinematicContrastMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.CinematicContrastMult, ref reader, options);
            break;
        case "CinematicSaturationAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.CinematicSaturationAdd, ref reader, options);
            break;
        case "CinematicSaturationMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.CinematicSaturationMult, ref reader, options);
            break;
        case "DepthOfFieldDistance":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.DepthOfFieldDistance, ref reader, options);
            break;
        case "DepthOfFieldFlags":
            retval.DepthOfFieldFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ImageSpaceAdapter.DepthOfFieldFlag>(ref reader, options);
            break;
        case "DepthOfFieldRange":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.DepthOfFieldRange, ref reader, options);
            break;
        case "DepthOfFieldStrength":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.DepthOfFieldStrength, ref reader, options);
            break;
        case "DNAMDataTypeState":
            retval.DNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ImageSpaceAdapter.DNAMDataType>(ref reader, options);
            break;
        case "DoubleVisionStrength":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.DoubleVisionStrength, ref reader, options);
            break;
        case "Duration":
            retval.Duration = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FadeColor":
            ConverterHelpers.ReadExtendedList<ColorFrame>(retval.FadeColor, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ImageSpaceAdapter.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HdrBloomBlurRadiusAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrBloomBlurRadiusAdd, ref reader, options);
            break;
        case "HdrBloomBlurRadiusMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrBloomBlurRadiusMult, ref reader, options);
            break;
        case "HdrBloomScaleAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrBloomScaleAdd, ref reader, options);
            break;
        case "HdrBloomScaleMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrBloomScaleMult, ref reader, options);
            break;
        case "HdrBloomThresholdAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrBloomThresholdAdd, ref reader, options);
            break;
        case "HdrBloomThresholdMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrBloomThresholdMult, ref reader, options);
            break;
        case "HdrEyeAdaptSpeedAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrEyeAdaptSpeedAdd, ref reader, options);
            break;
        case "HdrEyeAdaptSpeedMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrEyeAdaptSpeedMult, ref reader, options);
            break;
        case "HdrSkyScaleAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrSkyScaleAdd, ref reader, options);
            break;
        case "HdrSkyScaleMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrSkyScaleMult, ref reader, options);
            break;
        case "HdrSunlightScaleAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrSunlightScaleAdd, ref reader, options);
            break;
        case "HdrSunlightScaleMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrSunlightScaleMult, ref reader, options);
            break;
        case "HdrTargetLumMaxAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrTargetLumMaxAdd, ref reader, options);
            break;
        case "HdrTargetLumMaxMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrTargetLumMaxMult, ref reader, options);
            break;
        case "HdrTargetLumMinAdd":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrTargetLumMinAdd, ref reader, options);
            break;
        case "HdrTargetLumMinMult":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.HdrTargetLumMinMult, ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MotionBlurStrength":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.MotionBlurStrength, ref reader, options);
            break;
        case "RadialBlurCenter":
            retval.RadialBlurCenter = JsonSerializer.Deserialize<Noggog.P2Float>(ref reader, options);
            break;
        case "RadialBlurDownStart":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.RadialBlurDownStart, ref reader, options);
            break;
        case "RadialBlurFlags":
            retval.RadialBlurFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ImageSpaceAdapter.RadialBlurFlag>(ref reader, options);
            break;
        case "RadialBlurRampDown":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.RadialBlurRampDown, ref reader, options);
            break;
        case "RadialBlurRampUp":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.RadialBlurRampUp, ref reader, options);
            break;
        case "RadialBlurStart":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.RadialBlurStart, ref reader, options);
            break;
        case "RadialBlurStrength":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.RadialBlurStrength, ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TintColor":
            ConverterHelpers.ReadExtendedList<ColorFrame>(retval.TintColor, ref reader, options);
            break;
        case "Unknown08":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown08, ref reader, options);
            break;
        case "Unknown09":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown09, ref reader, options);
            break;
        case "Unknown0A":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown0A, ref reader, options);
            break;
        case "Unknown0B":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown0B, ref reader, options);
            break;
        case "Unknown0C":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown0C, ref reader, options);
            break;
        case "Unknown0D":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown0D, ref reader, options);
            break;
        case "Unknown0E":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown0E, ref reader, options);
            break;
        case "Unknown0F":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown0F, ref reader, options);
            break;
        case "Unknown10":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown10, ref reader, options);
            break;
        case "Unknown14":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown14, ref reader, options);
            break;
        case "Unknown48":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown48, ref reader, options);
            break;
        case "Unknown49":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown49, ref reader, options);
            break;
        case "Unknown4A":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown4A, ref reader, options);
            break;
        case "Unknown4B":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown4B, ref reader, options);
            break;
        case "Unknown4C":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown4C, ref reader, options);
            break;
        case "Unknown4D":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown4D, ref reader, options);
            break;
        case "Unknown4E":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown4E, ref reader, options);
            break;
        case "Unknown4F":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown4F, ref reader, options);
            break;
        case "Unknown50":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown50, ref reader, options);
            break;
        case "Unknown54":
            ConverterHelpers.ReadExtendedList<KeyFrame>(retval.Unknown54, ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IImageSpaceCinematicGetter_Converter : JsonConverter<IImageSpaceCinematicGetter>
{
  public override IImageSpaceCinematicGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IImageSpaceCinematicGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ImageSpaceCinematic");
    writer.WritePropertyName("Brightness");
    JsonSerializer.Serialize(writer, value.Brightness, options);
    writer.WritePropertyName("Contrast");
    JsonSerializer.Serialize(writer, value.Contrast, options);
    writer.WritePropertyName("Saturation");
    JsonSerializer.Serialize(writer, value.Saturation, options);
    writer.WriteEndObject();
  }
}
public class ImageSpaceCinematic_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ImageSpaceCinematic>
{
  private IImageSpaceCinematicGetter_Converter _getterConverter;
  public ImageSpaceCinematic_Converter(IImageSpaceCinematicGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ImageSpaceCinematic value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IImageSpaceCinematicGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ImageSpaceCinematic Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ImageSpaceCinematic();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Brightness":
            retval.Brightness = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Contrast":
            retval.Contrast = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Saturation":
            retval.Saturation = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IImageSpaceDepthOfFieldGetter_Converter : JsonConverter<IImageSpaceDepthOfFieldGetter>
{
  public override IImageSpaceDepthOfFieldGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IImageSpaceDepthOfFieldGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ImageSpaceDepthOfField");
    writer.WritePropertyName("BlurRadius");
    JsonSerializer.Serialize(writer, value.BlurRadius, options);
    writer.WritePropertyName("Distance");
    JsonSerializer.Serialize(writer, value.Distance, options);
    writer.WritePropertyName("Range");
    JsonSerializer.Serialize(writer, value.Range, options);
    writer.WritePropertyName("Sky");
    JsonSerializer.Serialize(writer, value.Sky, options);
    writer.WritePropertyName("Strength");
    JsonSerializer.Serialize(writer, value.Strength, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class ImageSpaceDepthOfField_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ImageSpaceDepthOfField>
{
  private IImageSpaceDepthOfFieldGetter_Converter _getterConverter;
  public ImageSpaceDepthOfField_Converter(IImageSpaceDepthOfFieldGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ImageSpaceDepthOfField value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IImageSpaceDepthOfFieldGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ImageSpaceDepthOfField Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ImageSpaceDepthOfField();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BlurRadius":
            retval.BlurRadius = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Distance":
            retval.Distance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Range":
            retval.Range = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Sky":
            retval.Sky = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Strength":
            retval.Strength = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ImageSpaceDepthOfField.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IImageSpaceHdrGetter_Converter : JsonConverter<IImageSpaceHdrGetter>
{
  public override IImageSpaceHdrGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IImageSpaceHdrGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ImageSpaceHdr");
    writer.WritePropertyName("BloomBlurRadius");
    JsonSerializer.Serialize(writer, value.BloomBlurRadius, options);
    writer.WritePropertyName("BloomScale");
    JsonSerializer.Serialize(writer, value.BloomScale, options);
    writer.WritePropertyName("BloomThreshold");
    JsonSerializer.Serialize(writer, value.BloomThreshold, options);
    writer.WritePropertyName("EyeAdaptSpeed");
    JsonSerializer.Serialize(writer, value.EyeAdaptSpeed, options);
    writer.WritePropertyName("EyeAdaptStrength");
    JsonSerializer.Serialize(writer, value.EyeAdaptStrength, options);
    writer.WritePropertyName("ReceiveBloomThreshold");
    JsonSerializer.Serialize(writer, value.ReceiveBloomThreshold, options);
    writer.WritePropertyName("SkyScale");
    JsonSerializer.Serialize(writer, value.SkyScale, options);
    writer.WritePropertyName("SunlightScale");
    JsonSerializer.Serialize(writer, value.SunlightScale, options);
    writer.WritePropertyName("White");
    JsonSerializer.Serialize(writer, value.White, options);
    writer.WriteEndObject();
  }
}
public class ImageSpaceHdr_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ImageSpaceHdr>
{
  private IImageSpaceHdrGetter_Converter _getterConverter;
  public ImageSpaceHdr_Converter(IImageSpaceHdrGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ImageSpaceHdr value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IImageSpaceHdrGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ImageSpaceHdr Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ImageSpaceHdr();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BloomBlurRadius":
            retval.BloomBlurRadius = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BloomScale":
            retval.BloomScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BloomThreshold":
            retval.BloomThreshold = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EyeAdaptSpeed":
            retval.EyeAdaptSpeed = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EyeAdaptStrength":
            retval.EyeAdaptStrength = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ReceiveBloomThreshold":
            retval.ReceiveBloomThreshold = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyScale":
            retval.SkyScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SunlightScale":
            retval.SunlightScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "White":
            retval.White = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IImageSpaceTintGetter_Converter : JsonConverter<IImageSpaceTintGetter>
{
  public override IImageSpaceTintGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IImageSpaceTintGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ImageSpaceTint");
    writer.WritePropertyName("Amount");
    JsonSerializer.Serialize(writer, value.Amount, options);
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WriteEndObject();
  }
}
public class ImageSpaceTint_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ImageSpaceTint>
{
  private IImageSpaceTintGetter_Converter _getterConverter;
  public ImageSpaceTint_Converter(IImageSpaceTintGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ImageSpaceTint value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IImageSpaceTintGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ImageSpaceTint Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ImageSpaceTint();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Amount":
            retval.Amount = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Color":
            retval.Color = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IImpactGetter_Converter : JsonConverter<IImpactGetter>
{
  public override IImpactGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IImpactGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Impact");
    writer.WritePropertyName("AngleThreshold");
    JsonSerializer.Serialize(writer, value.AngleThreshold, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Decal");
    JsonSerializer.Serialize(writer, value.Decal, options);
    writer.WritePropertyName("Duration");
    JsonSerializer.Serialize(writer, value.Duration, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Hazard");
    JsonSerializer.Serialize(writer, value.Hazard, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Orientation");
    JsonSerializer.Serialize(writer, value.Orientation, options);
    writer.WritePropertyName("PlacementRadius");
    JsonSerializer.Serialize(writer, value.PlacementRadius, options);
    writer.WritePropertyName("Result");
    JsonSerializer.Serialize(writer, value.Result, options);
    writer.WritePropertyName("SecondaryTextureSet");
    JsonSerializer.Serialize(writer, value.SecondaryTextureSet, options);
    writer.WritePropertyName("Sound1");
    JsonSerializer.Serialize(writer, value.Sound1, options);
    writer.WritePropertyName("Sound2");
    JsonSerializer.Serialize(writer, value.Sound2, options);
    writer.WritePropertyName("SoundLevel");
    JsonSerializer.Serialize(writer, value.SoundLevel, options);
    writer.WritePropertyName("TextureSet");
    JsonSerializer.Serialize(writer, value.TextureSet, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Impact_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Impact>
{
  private IImpactGetter_Converter _getterConverter;
  public Impact_Converter(IImpactGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Impact value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IImpactGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Impact Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Impact();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AngleThreshold":
            retval.AngleThreshold = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Impact.DATADataType>(ref reader, options);
            break;
        case "Decal":
            retval.Decal = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Decal>(ref reader, options);
            break;
        case "Duration":
            retval.Duration = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Impact.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Hazard":
            ConverterHelpers.ReadFormLinkNullable<IHazardGetter>(retval.Hazard, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Orientation":
            retval.Orientation = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Impact.OrientationType>(ref reader, options);
            break;
        case "PlacementRadius":
            retval.PlacementRadius = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Result":
            retval.Result = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Impact.ResultType>(ref reader, options);
            break;
        case "SecondaryTextureSet":
            ConverterHelpers.ReadFormLinkNullable<ITextureSetGetter>(retval.SecondaryTextureSet, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Sound1":
            ConverterHelpers.ReadFormLinkNullable<ISoundGetter>(retval.Sound1, ref reader);
            break;
        case "Sound2":
            ConverterHelpers.ReadFormLinkNullable<ISoundGetter>(retval.Sound2, ref reader);
            break;
        case "SoundLevel":
            retval.SoundLevel = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundLevel>(ref reader, options);
            break;
        case "TextureSet":
            ConverterHelpers.ReadFormLinkNullable<ITextureSetGetter>(retval.TextureSet, ref reader);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IImpactDataGetter_Converter : JsonConverter<IImpactDataGetter>
{
  public override IImpactDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IImpactDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ImpactData");
    writer.WritePropertyName("Impact");
    JsonSerializer.Serialize(writer, value.Impact, options);
    writer.WritePropertyName("Material");
    JsonSerializer.Serialize(writer, value.Material, options);
    writer.WriteEndObject();
  }
}
public class ImpactData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ImpactData>
{
  private IImpactDataGetter_Converter _getterConverter;
  public ImpactData_Converter(IImpactDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ImpactData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IImpactDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ImpactData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ImpactData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Impact":
            ConverterHelpers.ReadFormLink<IImpactGetter>(retval.Impact, ref reader);
            break;
        case "Material":
            ConverterHelpers.ReadFormLink<IMaterialTypeGetter>(retval.Material, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IImpactDataSetGetter_Converter : JsonConverter<IImpactDataSetGetter>
{
  public override IImpactDataSetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IImpactDataSetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ImpactDataSet");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    if (value.Impacts != default)
    {
      writer.WritePropertyName("Impacts");
      writer.WriteStartArray();
      foreach (var itm in value.Impacts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Impacts");
    }
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class ImpactDataSet_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ImpactDataSet>
{
  private IImpactDataSetGetter_Converter _getterConverter;
  public ImpactDataSet_Converter(IImpactDataSetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ImpactDataSet value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IImpactDataSetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ImpactDataSet Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ImpactDataSet();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Impacts":
            ConverterHelpers.ReadExtendedList<ImpactData>(retval.Impacts, ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IIndexedScriptFragmentGetter_Converter : JsonConverter<IIndexedScriptFragmentGetter>
{
  public override IIndexedScriptFragmentGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IIndexedScriptFragmentGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "IndexedScriptFragment");
    writer.WritePropertyName("FragmentIndex");
    JsonSerializer.Serialize(writer, value.FragmentIndex, options);
    writer.WritePropertyName("FragmentName");
    JsonSerializer.Serialize(writer, value.FragmentName, options);
    writer.WritePropertyName("ScriptName");
    JsonSerializer.Serialize(writer, value.ScriptName, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class IndexedScriptFragment_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.IndexedScriptFragment>
{
  private IIndexedScriptFragmentGetter_Converter _getterConverter;
  public IndexedScriptFragment_Converter(IIndexedScriptFragmentGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.IndexedScriptFragment value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IIndexedScriptFragmentGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.IndexedScriptFragment Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.IndexedScriptFragment();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FragmentIndex":
            retval.FragmentIndex = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "FragmentName":
            retval.FragmentName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ScriptName":
            retval.ScriptName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IIngestibleGetter_Converter : JsonConverter<IIngestibleGetter>
{
  public override IIngestibleGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IIngestibleGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Ingestible");
    writer.WritePropertyName("Addiction");
    JsonSerializer.Serialize(writer, value.Addiction, options);
    writer.WritePropertyName("AddictionChance");
    JsonSerializer.Serialize(writer, value.AddictionChance, options);
    writer.WritePropertyName("ConsumeSound");
    JsonSerializer.Serialize(writer, value.ConsumeSound, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.Effects != default)
    {
      writer.WritePropertyName("Effects");
      writer.WriteStartArray();
      foreach (var itm in value.Effects)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Effects");
    }
    writer.WritePropertyName("ENITDataTypeState");
    JsonSerializer.Serialize(writer, value.ENITDataTypeState, options);
    writer.WritePropertyName("EquipmentType");
    JsonSerializer.Serialize(writer, value.EquipmentType, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class Ingestible_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Ingestible>
{
  private IIngestibleGetter_Converter _getterConverter;
  public Ingestible_Converter(IIngestibleGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Ingestible value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IIngestibleGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Ingestible Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Ingestible();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Addiction":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.Addiction, ref reader);
            break;
        case "AddictionChance":
            retval.AddictionChance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ConsumeSound":
            ConverterHelpers.ReadFormLink<ISoundDescriptorGetter>(retval.ConsumeSound, ref reader);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Effects":
            ConverterHelpers.ReadExtendedList<Effect>(retval.Effects, ref reader, options);
            break;
        case "ENITDataTypeState":
            retval.ENITDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ingestible.ENITDataType>(ref reader, options);
            break;
        case "EquipmentType":
            ConverterHelpers.ReadFormLinkNullable<IEquipTypeGetter>(retval.EquipmentType, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ingestible.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ingestible.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IIngredientGetter_Converter : JsonConverter<IIngredientGetter>
{
  public override IIngredientGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IIngredientGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Ingredient");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.Effects != default)
    {
      writer.WritePropertyName("Effects");
      writer.WriteStartArray();
      foreach (var itm in value.Effects)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Effects");
    }
    writer.WritePropertyName("ENITDataTypeState");
    JsonSerializer.Serialize(writer, value.ENITDataTypeState, options);
    writer.WritePropertyName("EquipType");
    JsonSerializer.Serialize(writer, value.EquipType, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("IngredientValue");
    JsonSerializer.Serialize(writer, value.IngredientValue, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class Ingredient_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Ingredient>
{
  private IIngredientGetter_Converter _getterConverter;
  public Ingredient_Converter(IIngredientGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Ingredient value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IIngredientGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Ingredient Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Ingredient();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ingredient.DATADataType>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Effects":
            ConverterHelpers.ReadExtendedList<Effect>(retval.Effects, ref reader, options);
            break;
        case "ENITDataTypeState":
            retval.ENITDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ingredient.ENITDataType>(ref reader, options);
            break;
        case "EquipType":
            ConverterHelpers.ReadFormLinkNullable<IEquipTypeGetter>(retval.EquipType, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ingredient.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "IngredientValue":
            retval.IngredientValue = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IInt16MinMaxGetter_Converter : JsonConverter<IInt16MinMaxGetter>
{
  public override IInt16MinMaxGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IInt16MinMaxGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Int16MinMax");
    writer.WritePropertyName("Max");
    JsonSerializer.Serialize(writer, value.Max, options);
    writer.WritePropertyName("Min");
    JsonSerializer.Serialize(writer, value.Min, options);
    writer.WriteEndObject();
  }
}
public class Int16MinMax_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Int16MinMax>
{
  private IInt16MinMaxGetter_Converter _getterConverter;
  public Int16MinMax_Converter(IInt16MinMaxGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Int16MinMax value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IInt16MinMaxGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Int16MinMax Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Int16MinMax();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Max":
            retval.Max = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Min":
            retval.Min = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IIslandDataGetter_Converter : JsonConverter<IIslandDataGetter>
{
  public override IIslandDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IIslandDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "IslandData");
    writer.WritePropertyName("Max");
    JsonSerializer.Serialize(writer, value.Max, options);
    writer.WritePropertyName("Min");
    JsonSerializer.Serialize(writer, value.Min, options);
    if (value.Triangles != default)
    {
      writer.WritePropertyName("Triangles");
      writer.WriteStartArray();
      foreach (var itm in value.Triangles)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Triangles");
    }
    if (value.Vertices != default)
    {
      writer.WritePropertyName("Vertices");
      writer.WriteStartArray();
      foreach (var itm in value.Vertices)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Vertices");
    }
    writer.WriteEndObject();
  }
}
public class IslandData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.IslandData>
{
  private IIslandDataGetter_Converter _getterConverter;
  public IslandData_Converter(IIslandDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.IslandData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IIslandDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.IslandData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.IslandData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Max":
            retval.Max = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "Min":
            retval.Min = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "Triangles":
            ConverterHelpers.ReadExtendedList<P3Int16>(retval.Triangles, ref reader, options);
            break;
        case "Vertices":
            ConverterHelpers.ReadExtendedList<P3Float>(retval.Vertices, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IKeyGetter_Converter : JsonConverter<IKeyGetter>
{
  public override IKeyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IKeyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Key");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class Key_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Key>
{
  private IKeyGetter_Converter _getterConverter;
  public Key_Converter(IKeyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Key value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IKeyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Key Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Key();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Key.DATADataType>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Key.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IKeyFrameGetter_Converter : JsonConverter<IKeyFrameGetter>
{
  public override IKeyFrameGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IKeyFrameGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "KeyFrame");
    writer.WritePropertyName("Time");
    JsonSerializer.Serialize(writer, value.Time, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WriteEndObject();
  }
}
public class KeyFrame_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.KeyFrame>
{
  private IKeyFrameGetter_Converter _getterConverter;
  public KeyFrame_Converter(IKeyFrameGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.KeyFrame value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IKeyFrameGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.KeyFrame Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.KeyFrame();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Time":
            retval.Time = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IKeywordGetter_Converter : JsonConverter<IKeywordGetter>
{
  public override IKeywordGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IKeywordGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Keyword");
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Keyword_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Keyword>
{
  private IKeywordGetter_Converter _getterConverter;
  public Keyword_Converter(IKeywordGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Keyword value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IKeywordGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Keyword Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Keyword();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Color":
            retval.Color = JsonSerializer.Deserialize<Color?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILandscapeGetter_Converter : JsonConverter<ILandscapeGetter>
{
  public override ILandscapeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILandscapeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Landscape");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Layers != default)
    {
      writer.WritePropertyName("Layers");
      writer.WriteStartArray();
      foreach (var itm in value.Layers)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Layers");
    }
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.Textures != default)
    {
      writer.WritePropertyName("Textures");
      writer.WriteStartArray();
      foreach (var itm in value.Textures)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Textures");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VertexColors");
    JsonSerializer.Serialize(writer, value.VertexColors, options);
    writer.WritePropertyName("VertexHeightMap");
    JsonSerializer.Serialize(writer, value.VertexHeightMap, options);
    writer.WritePropertyName("VertexNormals");
    JsonSerializer.Serialize(writer, value.VertexNormals, options);
    writer.WriteEndObject();
  }
}
public class Landscape_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Landscape>
{
  private ILandscapeGetter_Converter _getterConverter;
  public Landscape_Converter(ILandscapeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Landscape value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILandscapeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Landscape Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Landscape();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Layers":
            ConverterHelpers.ReadExtendedList<BaseLayer>(retval.Layers, ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Textures":
            ConverterHelpers.ReadFormLinkList<ILandscapeTextureGetter>(retval.Textures, ref reader);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VertexColors":
            break;
        case "VertexHeightMap":
            retval.VertexHeightMap = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LandscapeVertexHeightMap>(ref reader, options);
            break;
        case "VertexNormals":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILandscapeTextureGetter_Converter : JsonConverter<ILandscapeTextureGetter>
{
  public override ILandscapeTextureGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILandscapeTextureGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LandscapeTexture");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    if (value.Grasses != default)
    {
      writer.WritePropertyName("Grasses");
      writer.WriteStartArray();
      foreach (var itm in value.Grasses)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Grasses");
    }
    writer.WritePropertyName("HavokFriction");
    JsonSerializer.Serialize(writer, value.HavokFriction, options);
    writer.WritePropertyName("HavokRestitution");
    JsonSerializer.Serialize(writer, value.HavokRestitution, options);
    writer.WritePropertyName("HNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.HNAMDataTypeState, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MaterialType");
    JsonSerializer.Serialize(writer, value.MaterialType, options);
    writer.WritePropertyName("TextureSet");
    JsonSerializer.Serialize(writer, value.TextureSet, options);
    writer.WritePropertyName("TextureSpecularExponent");
    JsonSerializer.Serialize(writer, value.TextureSpecularExponent, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class LandscapeTexture_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LandscapeTexture>
{
  private ILandscapeTextureGetter_Converter _getterConverter;
  public LandscapeTexture_Converter(ILandscapeTextureGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LandscapeTexture value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILandscapeTextureGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LandscapeTexture Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LandscapeTexture();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Grasses":
            ConverterHelpers.ReadFormLinkList<IGrassGetter>(retval.Grasses, ref reader);
            break;
        case "HavokFriction":
            retval.HavokFriction = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "HavokRestitution":
            retval.HavokRestitution = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "HNAMDataTypeState":
            retval.HNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LandscapeTexture.HNAMDataType>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MaterialType":
            ConverterHelpers.ReadFormLink<IMaterialTypeGetter>(retval.MaterialType, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TextureSet":
            ConverterHelpers.ReadFormLinkNullable<ITextureSetGetter>(retval.TextureSet, ref reader);
            break;
        case "TextureSpecularExponent":
            retval.TextureSpecularExponent = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILandscapeVertexHeightMapGetter_Converter : JsonConverter<ILandscapeVertexHeightMapGetter>
{
  public override ILandscapeVertexHeightMapGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILandscapeVertexHeightMapGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LandscapeVertexHeightMap");
    writer.WritePropertyName("HeightMap");
    JsonSerializer.Serialize(writer, value.HeightMap, options);
    writer.WritePropertyName("Offset");
    JsonSerializer.Serialize(writer, value.Offset, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class LandscapeVertexHeightMap_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LandscapeVertexHeightMap>
{
  private ILandscapeVertexHeightMapGetter_Converter _getterConverter;
  public LandscapeVertexHeightMap_Converter(ILandscapeVertexHeightMapGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LandscapeVertexHeightMap value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILandscapeVertexHeightMapGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LandscapeVertexHeightMap Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LandscapeVertexHeightMap();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "HeightMap":
            break;
        case "Offset":
            retval.Offset = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<Noggog.P3UInt8>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILayerHeaderGetter_Converter : JsonConverter<ILayerHeaderGetter>
{
  public override ILayerHeaderGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILayerHeaderGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LayerHeader");
    writer.WritePropertyName("LayerNumber");
    JsonSerializer.Serialize(writer, value.LayerNumber, options);
    writer.WritePropertyName("Quadrant");
    JsonSerializer.Serialize(writer, value.Quadrant, options);
    writer.WritePropertyName("Texture");
    JsonSerializer.Serialize(writer, value.Texture, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WriteEndObject();
  }
}
public class LayerHeader_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LayerHeader>
{
  private ILayerHeaderGetter_Converter _getterConverter;
  public LayerHeader_Converter(ILayerHeaderGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LayerHeader value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILayerHeaderGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LayerHeader Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LayerHeader();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "LayerNumber":
            retval.LayerNumber = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Quadrant":
            retval.Quadrant = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.Records.Quadrant>(ref reader, options);
            break;
        case "Texture":
            ConverterHelpers.ReadFormLink<ILandscapeTextureGetter>(retval.Texture, ref reader);
            break;
        case "Unused":
            retval.Unused = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILensFlareGetter_Converter : JsonConverter<ILensFlareGetter>
{
  public override ILensFlareGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILensFlareGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LensFlare");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class LensFlare_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LensFlare>
{
  private ILensFlareGetter_Converter _getterConverter;
  public LensFlare_Converter(ILensFlareGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LensFlare value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILensFlareGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LensFlare Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LensFlare();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILeveledItemGetter_Converter : JsonConverter<ILeveledItemGetter>
{
  public override ILeveledItemGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILeveledItemGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LeveledItem");
    writer.WritePropertyName("ChanceNone");
    JsonSerializer.Serialize(writer, value.ChanceNone, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.Entries != default)
    {
      writer.WritePropertyName("Entries");
      writer.WriteStartArray();
      foreach (var itm in value.Entries)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Entries");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Global");
    JsonSerializer.Serialize(writer, value.Global, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class LeveledItem_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LeveledItem>
{
  private ILeveledItemGetter_Converter _getterConverter;
  public LeveledItem_Converter(ILeveledItemGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LeveledItem value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILeveledItemGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LeveledItem Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LeveledItem();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ChanceNone":
            retval.ChanceNone = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Entries":
            ConverterHelpers.ReadExtendedList<LeveledItemEntry>(retval.Entries, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LeveledItem.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Global":
            ConverterHelpers.ReadFormLinkNullable<IGlobalGetter>(retval.Global, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILeveledItemEntryGetter_Converter : JsonConverter<ILeveledItemEntryGetter>
{
  public override ILeveledItemEntryGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILeveledItemEntryGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LeveledItemEntry");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("ExtraData");
    JsonSerializer.Serialize(writer, value.ExtraData, options);
    writer.WriteEndObject();
  }
}
public class LeveledItemEntry_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LeveledItemEntry>
{
  private ILeveledItemEntryGetter_Converter _getterConverter;
  public LeveledItemEntry_Converter(ILeveledItemEntryGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LeveledItemEntry value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILeveledItemEntryGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LeveledItemEntry Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LeveledItemEntry();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LeveledItemEntryData>(ref reader, options);
            break;
        case "ExtraData":
            retval.ExtraData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ExtraData>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILeveledItemEntryDataGetter_Converter : JsonConverter<ILeveledItemEntryDataGetter>
{
  public override ILeveledItemEntryDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILeveledItemEntryDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LeveledItemEntryData");
    writer.WritePropertyName("Count");
    JsonSerializer.Serialize(writer, value.Count, options);
    writer.WritePropertyName("Level");
    JsonSerializer.Serialize(writer, value.Level, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class LeveledItemEntryData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LeveledItemEntryData>
{
  private ILeveledItemEntryDataGetter_Converter _getterConverter;
  public LeveledItemEntryData_Converter(ILeveledItemEntryDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LeveledItemEntryData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILeveledItemEntryDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LeveledItemEntryData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LeveledItemEntryData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Count":
            retval.Count = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Level":
            retval.Level = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<IItemGetter>(retval.Reference, ref reader);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILeveledNpcGetter_Converter : JsonConverter<ILeveledNpcGetter>
{
  public override ILeveledNpcGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILeveledNpcGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LeveledNpc");
    writer.WritePropertyName("ChanceNone");
    JsonSerializer.Serialize(writer, value.ChanceNone, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.Entries != default)
    {
      writer.WritePropertyName("Entries");
      writer.WriteStartArray();
      foreach (var itm in value.Entries)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Entries");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Global");
    JsonSerializer.Serialize(writer, value.Global, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class LeveledNpc_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LeveledNpc>
{
  private ILeveledNpcGetter_Converter _getterConverter;
  public LeveledNpc_Converter(ILeveledNpcGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LeveledNpc value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILeveledNpcGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LeveledNpc Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LeveledNpc();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ChanceNone":
            retval.ChanceNone = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Entries":
            ConverterHelpers.ReadExtendedList<LeveledNpcEntry>(retval.Entries, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LeveledNpc.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Global":
            ConverterHelpers.ReadFormLinkNullable<IGlobalGetter>(retval.Global, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILeveledNpcEntryGetter_Converter : JsonConverter<ILeveledNpcEntryGetter>
{
  public override ILeveledNpcEntryGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILeveledNpcEntryGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LeveledNpcEntry");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("ExtraData");
    JsonSerializer.Serialize(writer, value.ExtraData, options);
    writer.WriteEndObject();
  }
}
public class LeveledNpcEntry_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LeveledNpcEntry>
{
  private ILeveledNpcEntryGetter_Converter _getterConverter;
  public LeveledNpcEntry_Converter(ILeveledNpcEntryGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LeveledNpcEntry value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILeveledNpcEntryGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LeveledNpcEntry Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LeveledNpcEntry();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LeveledNpcEntryData>(ref reader, options);
            break;
        case "ExtraData":
            retval.ExtraData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ExtraData>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILeveledNpcEntryDataGetter_Converter : JsonConverter<ILeveledNpcEntryDataGetter>
{
  public override ILeveledNpcEntryDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILeveledNpcEntryDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LeveledNpcEntryData");
    writer.WritePropertyName("Count");
    JsonSerializer.Serialize(writer, value.Count, options);
    writer.WritePropertyName("Level");
    JsonSerializer.Serialize(writer, value.Level, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class LeveledNpcEntryData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LeveledNpcEntryData>
{
  private ILeveledNpcEntryDataGetter_Converter _getterConverter;
  public LeveledNpcEntryData_Converter(ILeveledNpcEntryDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LeveledNpcEntryData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILeveledNpcEntryDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LeveledNpcEntryData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LeveledNpcEntryData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Count":
            retval.Count = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Level":
            retval.Level = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<INpcSpawnGetter>(retval.Reference, ref reader);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILeveledSpellGetter_Converter : JsonConverter<ILeveledSpellGetter>
{
  public override ILeveledSpellGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILeveledSpellGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LeveledSpell");
    writer.WritePropertyName("ChanceNone");
    JsonSerializer.Serialize(writer, value.ChanceNone, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.Entries != default)
    {
      writer.WritePropertyName("Entries");
      writer.WriteStartArray();
      foreach (var itm in value.Entries)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Entries");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class LeveledSpell_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LeveledSpell>
{
  private ILeveledSpellGetter_Converter _getterConverter;
  public LeveledSpell_Converter(ILeveledSpellGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LeveledSpell value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILeveledSpellGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LeveledSpell Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LeveledSpell();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ChanceNone":
            retval.ChanceNone = JsonSerializer.Deserialize<Byte?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Entries":
            ConverterHelpers.ReadExtendedList<LeveledSpellEntry>(retval.Entries, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LeveledSpell.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILeveledSpellEntryGetter_Converter : JsonConverter<ILeveledSpellEntryGetter>
{
  public override ILeveledSpellEntryGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILeveledSpellEntryGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LeveledSpellEntry");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("ExtraData");
    JsonSerializer.Serialize(writer, value.ExtraData, options);
    writer.WriteEndObject();
  }
}
public class LeveledSpellEntry_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LeveledSpellEntry>
{
  private ILeveledSpellEntryGetter_Converter _getterConverter;
  public LeveledSpellEntry_Converter(ILeveledSpellEntryGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LeveledSpellEntry value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILeveledSpellEntryGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LeveledSpellEntry Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LeveledSpellEntry();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LeveledSpellEntryData>(ref reader, options);
            break;
        case "ExtraData":
            retval.ExtraData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ExtraData>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILeveledSpellEntryDataGetter_Converter : JsonConverter<ILeveledSpellEntryDataGetter>
{
  public override ILeveledSpellEntryDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILeveledSpellEntryDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LeveledSpellEntryData");
    writer.WritePropertyName("Count");
    JsonSerializer.Serialize(writer, value.Count, options);
    writer.WritePropertyName("Level");
    JsonSerializer.Serialize(writer, value.Level, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class LeveledSpellEntryData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LeveledSpellEntryData>
{
  private ILeveledSpellEntryDataGetter_Converter _getterConverter;
  public LeveledSpellEntryData_Converter(ILeveledSpellEntryDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LeveledSpellEntryData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILeveledSpellEntryDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LeveledSpellEntryData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LeveledSpellEntryData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Count":
            retval.Count = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Level":
            retval.Level = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<ISpellRecordGetter>(retval.Reference, ref reader);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILightGetter_Converter : JsonConverter<ILightGetter>
{
  public override ILightGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILightGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Light");
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FadeValue");
    JsonSerializer.Serialize(writer, value.FadeValue, options);
    writer.WritePropertyName("FalloffExponent");
    JsonSerializer.Serialize(writer, value.FalloffExponent, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FlickerIntensityAmplitude");
    JsonSerializer.Serialize(writer, value.FlickerIntensityAmplitude, options);
    writer.WritePropertyName("FlickerMovementAmplitude");
    JsonSerializer.Serialize(writer, value.FlickerMovementAmplitude, options);
    writer.WritePropertyName("FlickerPeriod");
    JsonSerializer.Serialize(writer, value.FlickerPeriod, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("FOV");
    JsonSerializer.Serialize(writer, value.FOV, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("NearClip");
    JsonSerializer.Serialize(writer, value.NearClip, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Radius");
    JsonSerializer.Serialize(writer, value.Radius, options);
    writer.WritePropertyName("Sound");
    JsonSerializer.Serialize(writer, value.Sound, options);
    writer.WritePropertyName("Time");
    JsonSerializer.Serialize(writer, value.Time, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class Light_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Light>
{
  private ILightGetter_Converter _getterConverter;
  public Light_Converter(ILightGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Light value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILightGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Light Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Light();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Color":
            retval.Color = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Light.DATADataType>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FadeValue":
            retval.FadeValue = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FalloffExponent":
            retval.FalloffExponent = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Light.Flag>(ref reader, options);
            break;
        case "FlickerIntensityAmplitude":
            retval.FlickerIntensityAmplitude = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FlickerMovementAmplitude":
            retval.FlickerMovementAmplitude = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FlickerPeriod":
            retval.FlickerPeriod = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "FOV":
            retval.FOV = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Light.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "NearClip":
            retval.NearClip = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "Radius":
            retval.Radius = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Sound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.Sound, ref reader);
            break;
        case "Time":
            retval.Time = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILightDataGetter_Converter : JsonConverter<ILightDataGetter>
{
  public override ILightDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILightDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LightData");
    writer.WritePropertyName("EndDistanceCap");
    JsonSerializer.Serialize(writer, value.EndDistanceCap, options);
    writer.WritePropertyName("FadeOffset");
    JsonSerializer.Serialize(writer, value.FadeOffset, options);
    writer.WritePropertyName("FovOffset");
    JsonSerializer.Serialize(writer, value.FovOffset, options);
    writer.WritePropertyName("ShadowDepthBias");
    JsonSerializer.Serialize(writer, value.ShadowDepthBias, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class LightData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LightData>
{
  private ILightDataGetter_Converter _getterConverter;
  public LightData_Converter(ILightDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LightData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILightDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LightData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LightData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EndDistanceCap":
            retval.EndDistanceCap = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FadeOffset":
            retval.FadeOffset = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FovOffset":
            retval.FovOffset = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ShadowDepthBias":
            retval.ShadowDepthBias = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LightData.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILightingTemplateGetter_Converter : JsonConverter<ILightingTemplateGetter>
{
  public override ILightingTemplateGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILightingTemplateGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LightingTemplate");
    writer.WritePropertyName("AmbientColor");
    JsonSerializer.Serialize(writer, value.AmbientColor, options);
    writer.WritePropertyName("AmbientDirectionalXMinus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalXMinus, options);
    writer.WritePropertyName("AmbientDirectionalXPlus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalXPlus, options);
    writer.WritePropertyName("AmbientDirectionalYMinus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalYMinus, options);
    writer.WritePropertyName("AmbientDirectionalYPlus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalYPlus, options);
    writer.WritePropertyName("AmbientDirectionalZMinus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalZMinus, options);
    writer.WritePropertyName("AmbientDirectionalZPlus");
    JsonSerializer.Serialize(writer, value.AmbientDirectionalZPlus, options);
    writer.WritePropertyName("AmbientScale");
    JsonSerializer.Serialize(writer, value.AmbientScale, options);
    writer.WritePropertyName("AmbientSpecular");
    JsonSerializer.Serialize(writer, value.AmbientSpecular, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("DirectionalAmbientColors");
    JsonSerializer.Serialize(writer, value.DirectionalAmbientColors, options);
    writer.WritePropertyName("DirectionalColor");
    JsonSerializer.Serialize(writer, value.DirectionalColor, options);
    writer.WritePropertyName("DirectionalFade");
    JsonSerializer.Serialize(writer, value.DirectionalFade, options);
    writer.WritePropertyName("DirectionalRotationXY");
    JsonSerializer.Serialize(writer, value.DirectionalRotationXY, options);
    writer.WritePropertyName("DirectionalRotationZ");
    JsonSerializer.Serialize(writer, value.DirectionalRotationZ, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FogClipDistance");
    JsonSerializer.Serialize(writer, value.FogClipDistance, options);
    writer.WritePropertyName("FogFar");
    JsonSerializer.Serialize(writer, value.FogFar, options);
    writer.WritePropertyName("FogFarColor");
    JsonSerializer.Serialize(writer, value.FogFarColor, options);
    writer.WritePropertyName("FogMax");
    JsonSerializer.Serialize(writer, value.FogMax, options);
    writer.WritePropertyName("FogNear");
    JsonSerializer.Serialize(writer, value.FogNear, options);
    writer.WritePropertyName("FogNearColor");
    JsonSerializer.Serialize(writer, value.FogNearColor, options);
    writer.WritePropertyName("FogPower");
    JsonSerializer.Serialize(writer, value.FogPower, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LightFadeEndDistance");
    JsonSerializer.Serialize(writer, value.LightFadeEndDistance, options);
    writer.WritePropertyName("LightFadeStartDistance");
    JsonSerializer.Serialize(writer, value.LightFadeStartDistance, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class LightingTemplate_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LightingTemplate>
{
  private ILightingTemplateGetter_Converter _getterConverter;
  public LightingTemplate_Converter(ILightingTemplateGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LightingTemplate value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILightingTemplateGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LightingTemplate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LightingTemplate();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AmbientColor":
            retval.AmbientColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalXMinus":
            retval.AmbientDirectionalXMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalXPlus":
            retval.AmbientDirectionalXPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalYMinus":
            retval.AmbientDirectionalYMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalYPlus":
            retval.AmbientDirectionalYPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalZMinus":
            retval.AmbientDirectionalZMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientDirectionalZPlus":
            retval.AmbientDirectionalZPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "AmbientScale":
            retval.AmbientScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AmbientSpecular":
            retval.AmbientSpecular = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LightingTemplate.DATADataType>(ref reader, options);
            break;
        case "DirectionalAmbientColors":
            retval.DirectionalAmbientColors = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AmbientColors>(ref reader, options);
            break;
        case "DirectionalColor":
            retval.DirectionalColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalFade":
            retval.DirectionalFade = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DirectionalRotationXY":
            retval.DirectionalRotationXY = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "DirectionalRotationZ":
            retval.DirectionalRotationZ = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "DirectionalXMinus":
            retval.DirectionalXMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalXPlus":
            retval.DirectionalXPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalYMinus":
            retval.DirectionalYMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalYPlus":
            retval.DirectionalYPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalZMinus":
            retval.DirectionalZMinus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DirectionalZPlus":
            retval.DirectionalZPlus = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FogClipDistance":
            retval.FogClipDistance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogFar":
            retval.FogFar = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogFarColor":
            retval.FogFarColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "FogMax":
            retval.FogMax = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogNear":
            retval.FogNear = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogNearColor":
            retval.FogNearColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "FogPower":
            retval.FogPower = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LightFadeEndDistance":
            retval.LightFadeEndDistance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "LightFadeStartDistance":
            retval.LightFadeStartDistance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Specular":
            retval.Specular = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILinkedDoorGetter_Converter : JsonConverter<ILinkedDoorGetter>
{
  public override ILinkedDoorGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILinkedDoorGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LinkedDoor");
    writer.WritePropertyName("Door");
    JsonSerializer.Serialize(writer, value.Door, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class LinkedDoor_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LinkedDoor>
{
  private ILinkedDoorGetter_Converter _getterConverter;
  public LinkedDoor_Converter(ILinkedDoorGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LinkedDoor value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILinkedDoorGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LinkedDoor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LinkedDoor();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Door":
            ConverterHelpers.ReadFormLink<IPlacedObjectGetter>(retval.Door, ref reader);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILinkedReferenceColorGetter_Converter : JsonConverter<ILinkedReferenceColorGetter>
{
  public override ILinkedReferenceColorGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILinkedReferenceColorGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LinkedReferenceColor");
    writer.WritePropertyName("End");
    JsonSerializer.Serialize(writer, value.End, options);
    writer.WritePropertyName("Start");
    JsonSerializer.Serialize(writer, value.Start, options);
    writer.WriteEndObject();
  }
}
public class LinkedReferenceColor_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LinkedReferenceColor>
{
  private ILinkedReferenceColorGetter_Converter _getterConverter;
  public LinkedReferenceColor_Converter(ILinkedReferenceColorGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LinkedReferenceColor value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILinkedReferenceColorGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LinkedReferenceColor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LinkedReferenceColor();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "End":
            retval.End = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Start":
            retval.Start = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILinkedReferencesGetter_Converter : JsonConverter<ILinkedReferencesGetter>
{
  public override ILinkedReferencesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILinkedReferencesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LinkedReferences");
    writer.WritePropertyName("KeywordOrReference");
    JsonSerializer.Serialize(writer, value.KeywordOrReference, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class LinkedReferences_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LinkedReferences>
{
  private ILinkedReferencesGetter_Converter _getterConverter;
  public LinkedReferences_Converter(ILinkedReferencesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LinkedReferences value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILinkedReferencesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LinkedReferences Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LinkedReferences();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "KeywordOrReference":
            ConverterHelpers.ReadFormLink<IKeywordLinkedReferenceGetter>(retval.KeywordOrReference, ref reader);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<ILinkedReferenceGetter>(retval.Reference, ref reader);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LinkedReferences.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILoadScreenGetter_Converter : JsonConverter<ILoadScreenGetter>
{
  public override ILoadScreenGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILoadScreenGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LoadScreen");
    writer.WritePropertyName("CameraPath");
    JsonSerializer.Serialize(writer, value.CameraPath, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("InitialRotation");
    JsonSerializer.Serialize(writer, value.InitialRotation, options);
    writer.WritePropertyName("InitialScale");
    JsonSerializer.Serialize(writer, value.InitialScale, options);
    writer.WritePropertyName("InitialTranslationOffset");
    JsonSerializer.Serialize(writer, value.InitialTranslationOffset, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LoadingScreenNif");
    JsonSerializer.Serialize(writer, value.LoadingScreenNif, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("RotationOffsetConstraints");
    JsonSerializer.Serialize(writer, value.RotationOffsetConstraints, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class LoadScreen_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LoadScreen>
{
  private ILoadScreenGetter_Converter _getterConverter;
  public LoadScreen_Converter(ILoadScreenGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LoadScreen value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILoadScreenGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LoadScreen Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LoadScreen();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CameraPath":
            retval.CameraPath = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "InitialRotation":
            retval.InitialRotation = JsonSerializer.Deserialize<P3Int16?>(ref reader, options);
            break;
        case "InitialScale":
            retval.InitialScale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "InitialTranslationOffset":
            retval.InitialTranslationOffset = JsonSerializer.Deserialize<P3Float?>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LoadingScreenNif":
            ConverterHelpers.ReadFormLink<IStaticGetter>(retval.LoadingScreenNif, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LoadScreen.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "RotationOffsetConstraints":
            retval.RotationOffsetConstraints = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Int16MinMax>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationGetter_Converter : JsonConverter<ILocationGetter>
{
  public override ILocationGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Location");
    if (value.ActorCellEnablePoint != default)
    {
      writer.WritePropertyName("ActorCellEnablePoint");
      writer.WriteStartArray();
      foreach (var itm in value.ActorCellEnablePoint)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ActorCellEnablePoint");
    }
    if (value.ActorCellEncounterCell != default)
    {
      writer.WritePropertyName("ActorCellEncounterCell");
      writer.WriteStartArray();
      foreach (var itm in value.ActorCellEncounterCell)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ActorCellEncounterCell");
    }
    if (value.ActorCellMarkerReference != default)
    {
      writer.WritePropertyName("ActorCellMarkerReference");
      writer.WriteStartArray();
      foreach (var itm in value.ActorCellMarkerReference)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ActorCellMarkerReference");
    }
    if (value.ActorCellPersistentReferences != default)
    {
      writer.WritePropertyName("ActorCellPersistentReferences");
      writer.WriteStartArray();
      foreach (var itm in value.ActorCellPersistentReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ActorCellPersistentReferences");
    }
    if (value.ActorCellStaticReferences != default)
    {
      writer.WritePropertyName("ActorCellStaticReferences");
      writer.WriteStartArray();
      foreach (var itm in value.ActorCellStaticReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ActorCellStaticReferences");
    }
    if (value.ActorCellUniques != default)
    {
      writer.WritePropertyName("ActorCellUniques");
      writer.WriteStartArray();
      foreach (var itm in value.ActorCellUniques)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ActorCellUniques");
    }
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HorseMarkerRef");
    JsonSerializer.Serialize(writer, value.HorseMarkerRef, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    if (value.LocationCellEnablePoint != default)
    {
      writer.WritePropertyName("LocationCellEnablePoint");
      writer.WriteStartArray();
      foreach (var itm in value.LocationCellEnablePoint)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationCellEnablePoint");
    }
    if (value.LocationCellEncounterCell != default)
    {
      writer.WritePropertyName("LocationCellEncounterCell");
      writer.WriteStartArray();
      foreach (var itm in value.LocationCellEncounterCell)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationCellEncounterCell");
    }
    if (value.LocationCellMarkerReference != default)
    {
      writer.WritePropertyName("LocationCellMarkerReference");
      writer.WriteStartArray();
      foreach (var itm in value.LocationCellMarkerReference)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationCellMarkerReference");
    }
    if (value.LocationCellPersistentReferences != default)
    {
      writer.WritePropertyName("LocationCellPersistentReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LocationCellPersistentReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationCellPersistentReferences");
    }
    if (value.LocationCellStaticReferences != default)
    {
      writer.WritePropertyName("LocationCellStaticReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LocationCellStaticReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationCellStaticReferences");
    }
    if (value.LocationCellUniques != default)
    {
      writer.WritePropertyName("LocationCellUniques");
      writer.WriteStartArray();
      foreach (var itm in value.LocationCellUniques)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationCellUniques");
    }
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Music");
    JsonSerializer.Serialize(writer, value.Music, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ParentLocation");
    JsonSerializer.Serialize(writer, value.ParentLocation, options);
    if (value.ReferenceCellEncounterCell != default)
    {
      writer.WritePropertyName("ReferenceCellEncounterCell");
      writer.WriteStartArray();
      foreach (var itm in value.ReferenceCellEncounterCell)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ReferenceCellEncounterCell");
    }
    if (value.ReferenceCellPersistentReferences != default)
    {
      writer.WritePropertyName("ReferenceCellPersistentReferences");
      writer.WriteStartArray();
      foreach (var itm in value.ReferenceCellPersistentReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ReferenceCellPersistentReferences");
    }
    if (value.ReferenceCellStaticReferences != default)
    {
      writer.WritePropertyName("ReferenceCellStaticReferences");
      writer.WriteStartArray();
      foreach (var itm in value.ReferenceCellStaticReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ReferenceCellStaticReferences");
    }
    if (value.ReferenceCellUnique != default)
    {
      writer.WritePropertyName("ReferenceCellUnique");
      writer.WriteStartArray();
      foreach (var itm in value.ReferenceCellUnique)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ReferenceCellUnique");
    }
    writer.WritePropertyName("UnreportedCrimeFaction");
    JsonSerializer.Serialize(writer, value.UnreportedCrimeFaction, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("WorldLocationMarkerRef");
    JsonSerializer.Serialize(writer, value.WorldLocationMarkerRef, options);
    writer.WritePropertyName("WorldLocationRadius");
    JsonSerializer.Serialize(writer, value.WorldLocationRadius, options);
    writer.WriteEndObject();
  }
}
public class Location_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Location>
{
  private ILocationGetter_Converter _getterConverter;
  public Location_Converter(ILocationGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Location value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Location Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Location();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorCellEnablePoint":
            ConverterHelpers.ReadExtendedList<LocationCellEnablePoint>(retval.ActorCellEnablePoint, ref reader, options);
            break;
        case "ActorCellEncounterCell":
            ConverterHelpers.ReadExtendedList<LocationCoordinate>(retval.ActorCellEncounterCell, ref reader, options);
            break;
        case "ActorCellMarkerReference":
            ConverterHelpers.ReadFormLinkList<IPlacedGetter>(retval.ActorCellMarkerReference, ref reader);
            break;
        case "ActorCellPersistentReferences":
            ConverterHelpers.ReadExtendedList<LocationReference>(retval.ActorCellPersistentReferences, ref reader, options);
            break;
        case "ActorCellStaticReferences":
            ConverterHelpers.ReadExtendedList<LocationCellStaticReference>(retval.ActorCellStaticReferences, ref reader, options);
            break;
        case "ActorCellUniques":
            ConverterHelpers.ReadExtendedList<LocationCellUnique>(retval.ActorCellUniques, ref reader, options);
            break;
        case "Color":
            retval.Color = JsonSerializer.Deserialize<Color?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HorseMarkerRef":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.HorseMarkerRef, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "LocationCellEnablePoint":
            ConverterHelpers.ReadExtendedList<LocationCellEnablePoint>(retval.LocationCellEnablePoint, ref reader, options);
            break;
        case "LocationCellEncounterCell":
            ConverterHelpers.ReadExtendedList<LocationCoordinate>(retval.LocationCellEncounterCell, ref reader, options);
            break;
        case "LocationCellMarkerReference":
            ConverterHelpers.ReadFormLinkList<IPlacedGetter>(retval.LocationCellMarkerReference, ref reader);
            break;
        case "LocationCellPersistentReferences":
            ConverterHelpers.ReadExtendedList<LocationReference>(retval.LocationCellPersistentReferences, ref reader, options);
            break;
        case "LocationCellStaticReferences":
            ConverterHelpers.ReadExtendedList<LocationCellStaticReference>(retval.LocationCellStaticReferences, ref reader, options);
            break;
        case "LocationCellUniques":
            ConverterHelpers.ReadExtendedList<LocationCellUnique>(retval.LocationCellUniques, ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Music":
            ConverterHelpers.ReadFormLinkNullable<IMusicTypeGetter>(retval.Music, ref reader);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ParentLocation":
            ConverterHelpers.ReadFormLinkNullable<ILocationGetter>(retval.ParentLocation, ref reader);
            break;
        case "ReferenceCellEncounterCell":
            ConverterHelpers.ReadExtendedList<LocationCoordinate>(retval.ReferenceCellEncounterCell, ref reader, options);
            break;
        case "ReferenceCellPersistentReferences":
            ConverterHelpers.ReadFormLinkList<IPlacedSimpleGetter>(retval.ReferenceCellPersistentReferences, ref reader);
            break;
        case "ReferenceCellStaticReferences":
            ConverterHelpers.ReadFormLinkList<IPlacedSimpleGetter>(retval.ReferenceCellStaticReferences, ref reader);
            break;
        case "ReferenceCellUnique":
            ConverterHelpers.ReadFormLinkList<INpcGetter>(retval.ReferenceCellUnique, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "UnreportedCrimeFaction":
            ConverterHelpers.ReadFormLinkNullable<IFactionGetter>(retval.UnreportedCrimeFaction, ref reader);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "WorldLocationMarkerRef":
            ConverterHelpers.ReadFormLinkNullable<IPlacedSimpleGetter>(retval.WorldLocationMarkerRef, ref reader);
            break;
        case "WorldLocationRadius":
            retval.WorldLocationRadius = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationAliasReferenceGetter_Converter : JsonConverter<ILocationAliasReferenceGetter>
{
  public override ILocationAliasReferenceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationAliasReferenceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationAliasReference");
    writer.WritePropertyName("AliasIndex");
    JsonSerializer.Serialize(writer, value.AliasIndex, options);
    writer.WritePropertyName("Keyword");
    JsonSerializer.Serialize(writer, value.Keyword, options);
    writer.WritePropertyName("RefType");
    JsonSerializer.Serialize(writer, value.RefType, options);
    writer.WriteEndObject();
  }
}
public class LocationAliasReference_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationAliasReference>
{
  private ILocationAliasReferenceGetter_Converter _getterConverter;
  public LocationAliasReference_Converter(ILocationAliasReferenceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationAliasReference value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationAliasReferenceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationAliasReference Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationAliasReference();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AliasIndex":
            retval.AliasIndex = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "Keyword":
            ConverterHelpers.ReadFormLinkNullable<IKeywordGetter>(retval.Keyword, ref reader);
            break;
        case "RefType":
            ConverterHelpers.ReadFormLinkNullable<ILocationReferenceTypeGetter>(retval.RefType, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationCellGetter_Converter : JsonConverter<ILocationCellGetter>
{
  public override ILocationCellGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationCellGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationCell");
    writer.WritePropertyName("Link");
    JsonSerializer.Serialize(writer, value.Link, options);
    writer.WriteEndObject();
  }
}
public class LocationCell_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationCell>
{
  private ILocationCellGetter_Converter _getterConverter;
  public LocationCell_Converter(ILocationCellGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationCell value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationCellGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationCell Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationCell();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Link":
            ConverterHelpers.ReadFormLink<ICellGetter>(retval.Link, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationCellEnablePointGetter_Converter : JsonConverter<ILocationCellEnablePointGetter>
{
  public override ILocationCellEnablePointGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationCellEnablePointGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationCellEnablePoint");
    writer.WritePropertyName("Actor");
    JsonSerializer.Serialize(writer, value.Actor, options);
    writer.WritePropertyName("Grid");
    JsonSerializer.Serialize(writer, value.Grid, options);
    writer.WritePropertyName("Ref");
    JsonSerializer.Serialize(writer, value.Ref, options);
    writer.WriteEndObject();
  }
}
public class LocationCellEnablePoint_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationCellEnablePoint>
{
  private ILocationCellEnablePointGetter_Converter _getterConverter;
  public LocationCellEnablePoint_Converter(ILocationCellEnablePointGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationCellEnablePoint value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationCellEnablePointGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationCellEnablePoint Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationCellEnablePoint();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Actor":
            ConverterHelpers.ReadFormLink<IPlacedGetter>(retval.Actor, ref reader);
            break;
        case "Grid":
            retval.Grid = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        case "Ref":
            ConverterHelpers.ReadFormLink<IPlacedGetter>(retval.Ref, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationCellStaticReferenceGetter_Converter : JsonConverter<ILocationCellStaticReferenceGetter>
{
  public override ILocationCellStaticReferenceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationCellStaticReferenceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationCellStaticReference");
    writer.WritePropertyName("Grid");
    JsonSerializer.Serialize(writer, value.Grid, options);
    writer.WritePropertyName("Location");
    JsonSerializer.Serialize(writer, value.Location, options);
    writer.WritePropertyName("LocationRefType");
    JsonSerializer.Serialize(writer, value.LocationRefType, options);
    writer.WritePropertyName("Marker");
    JsonSerializer.Serialize(writer, value.Marker, options);
    writer.WriteEndObject();
  }
}
public class LocationCellStaticReference_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationCellStaticReference>
{
  private ILocationCellStaticReferenceGetter_Converter _getterConverter;
  public LocationCellStaticReference_Converter(ILocationCellStaticReferenceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationCellStaticReference value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationCellStaticReferenceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationCellStaticReference Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationCellStaticReference();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Grid":
            retval.Grid = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        case "Location":
            ConverterHelpers.ReadFormLink<IComplexLocationGetter>(retval.Location, ref reader);
            break;
        case "LocationRefType":
            ConverterHelpers.ReadFormLink<ILocationReferenceTypeGetter>(retval.LocationRefType, ref reader);
            break;
        case "Marker":
            ConverterHelpers.ReadFormLink<ILinkedReferenceGetter>(retval.Marker, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationCellUniqueGetter_Converter : JsonConverter<ILocationCellUniqueGetter>
{
  public override ILocationCellUniqueGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationCellUniqueGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationCellUnique");
    writer.WritePropertyName("Actor");
    JsonSerializer.Serialize(writer, value.Actor, options);
    writer.WritePropertyName("Location");
    JsonSerializer.Serialize(writer, value.Location, options);
    writer.WritePropertyName("Ref");
    JsonSerializer.Serialize(writer, value.Ref, options);
    writer.WriteEndObject();
  }
}
public class LocationCellUnique_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationCellUnique>
{
  private ILocationCellUniqueGetter_Converter _getterConverter;
  public LocationCellUnique_Converter(ILocationCellUniqueGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationCellUnique value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationCellUniqueGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationCellUnique Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationCellUnique();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Actor":
            ConverterHelpers.ReadFormLink<INpcGetter>(retval.Actor, ref reader);
            break;
        case "Location":
            ConverterHelpers.ReadFormLink<ILocationGetter>(retval.Location, ref reader);
            break;
        case "Ref":
            ConverterHelpers.ReadFormLink<IPlacedNpcGetter>(retval.Ref, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationCoordinateGetter_Converter : JsonConverter<ILocationCoordinateGetter>
{
  public override ILocationCoordinateGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationCoordinateGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationCoordinate");
    if (value.Coordinates != default)
    {
      writer.WritePropertyName("Coordinates");
      writer.WriteStartArray();
      foreach (var itm in value.Coordinates)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Coordinates");
    }
    writer.WritePropertyName("Location");
    JsonSerializer.Serialize(writer, value.Location, options);
    writer.WriteEndObject();
  }
}
public class LocationCoordinate_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationCoordinate>
{
  private ILocationCoordinateGetter_Converter _getterConverter;
  public LocationCoordinate_Converter(ILocationCoordinateGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationCoordinate value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationCoordinateGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationCoordinate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationCoordinate();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Coordinates":
            ConverterHelpers.ReadExtendedList<P2Int16>(retval.Coordinates, ref reader, options);
            break;
        case "Location":
            ConverterHelpers.ReadFormLink<IComplexLocationGetter>(retval.Location, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationFallbackGetter_Converter : JsonConverter<ILocationFallbackGetter>
{
  public override ILocationFallbackGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationFallbackGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationFallback");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class LocationFallback_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationFallback>
{
  private ILocationFallbackGetter_Converter _getterConverter;
  public LocationFallback_Converter(ILocationFallbackGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationFallback value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationFallbackGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationFallback Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationFallback();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LocationTargetRadius.LocationType>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationKeywordGetter_Converter : JsonConverter<ILocationKeywordGetter>
{
  public override ILocationKeywordGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationKeywordGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationKeyword");
    writer.WritePropertyName("Link");
    JsonSerializer.Serialize(writer, value.Link, options);
    writer.WriteEndObject();
  }
}
public class LocationKeyword_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationKeyword>
{
  private ILocationKeywordGetter_Converter _getterConverter;
  public LocationKeyword_Converter(ILocationKeywordGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationKeyword value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationKeywordGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationKeyword Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationKeyword();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Link":
            ConverterHelpers.ReadFormLink<IKeywordGetter>(retval.Link, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationObjectIdGetter_Converter : JsonConverter<ILocationObjectIdGetter>
{
  public override ILocationObjectIdGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationObjectIdGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationObjectId");
    writer.WritePropertyName("Link");
    JsonSerializer.Serialize(writer, value.Link, options);
    writer.WriteEndObject();
  }
}
public class LocationObjectId_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationObjectId>
{
  private ILocationObjectIdGetter_Converter _getterConverter;
  public LocationObjectId_Converter(ILocationObjectIdGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationObjectId value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationObjectIdGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationObjectId Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationObjectId();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Link":
            ConverterHelpers.ReadFormLink<IObjectIdGetter>(retval.Link, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationObjectTypeGetter_Converter : JsonConverter<ILocationObjectTypeGetter>
{
  public override ILocationObjectTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationObjectTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationObjectType");
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class LocationObjectType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationObjectType>
{
  private ILocationObjectTypeGetter_Converter _getterConverter;
  public LocationObjectType_Converter(ILocationObjectTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationObjectType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationObjectTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationObjectType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationObjectType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.TargetObjectType>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationReferenceGetter_Converter : JsonConverter<ILocationReferenceGetter>
{
  public override ILocationReferenceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationReferenceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationReference");
    writer.WritePropertyName("Actor");
    JsonSerializer.Serialize(writer, value.Actor, options);
    writer.WritePropertyName("Grid");
    JsonSerializer.Serialize(writer, value.Grid, options);
    writer.WritePropertyName("Location");
    JsonSerializer.Serialize(writer, value.Location, options);
    writer.WriteEndObject();
  }
}
public class LocationReference_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationReference>
{
  private ILocationReferenceGetter_Converter _getterConverter;
  public LocationReference_Converter(ILocationReferenceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationReference value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationReferenceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationReference Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationReference();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Actor":
            ConverterHelpers.ReadFormLink<ILinkedReferenceGetter>(retval.Actor, ref reader);
            break;
        case "Grid":
            retval.Grid = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        case "Location":
            ConverterHelpers.ReadFormLink<IComplexLocationGetter>(retval.Location, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationReferenceTypeGetter_Converter : JsonConverter<ILocationReferenceTypeGetter>
{
  public override ILocationReferenceTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationReferenceTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationReferenceType");
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class LocationReferenceType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationReferenceType>
{
  private ILocationReferenceTypeGetter_Converter _getterConverter;
  public LocationReferenceType_Converter(ILocationReferenceTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationReferenceType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationReferenceTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationReferenceType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationReferenceType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Color":
            retval.Color = JsonSerializer.Deserialize<Color?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationTargetGetter_Converter : JsonConverter<ILocationTargetGetter>
{
  public override ILocationTargetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationTargetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationTarget");
    writer.WritePropertyName("Link");
    JsonSerializer.Serialize(writer, value.Link, options);
    writer.WriteEndObject();
  }
}
public class LocationTarget_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationTarget>
{
  private ILocationTargetGetter_Converter _getterConverter;
  public LocationTarget_Converter(ILocationTargetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationTarget value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationTargetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationTarget Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationTarget();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Link":
            ConverterHelpers.ReadFormLink<ILocationTargetableGetter>(retval.Link, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILocationTargetRadiusGetter_Converter : JsonConverter<ILocationTargetRadiusGetter>
{
  public override ILocationTargetRadiusGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILocationTargetRadiusGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LocationTargetRadius");
    writer.WritePropertyName("Radius");
    JsonSerializer.Serialize(writer, value.Radius, options);
    writer.WritePropertyName("Target");
    JsonSerializer.Serialize(writer, value.Target, options);
    writer.WriteEndObject();
  }
}
public class LocationTargetRadius_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LocationTargetRadius>
{
  private ILocationTargetRadiusGetter_Converter _getterConverter;
  public LocationTargetRadius_Converter(ILocationTargetRadiusGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LocationTargetRadius value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILocationTargetRadiusGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LocationTargetRadius Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LocationTargetRadius();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Radius":
            retval.Radius = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Target":
            retval.Target = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ALocationTarget>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILockDataGetter_Converter : JsonConverter<ILockDataGetter>
{
  public override ILockDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILockDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "LockData");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Key");
    JsonSerializer.Serialize(writer, value.Key, options);
    writer.WritePropertyName("Level");
    JsonSerializer.Serialize(writer, value.Level, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WritePropertyName("Unused2");
    JsonSerializer.Serialize(writer, value.Unused2, options);
    writer.WriteEndObject();
  }
}
public class LockData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.LockData>
{
  private ILockDataGetter_Converter _getterConverter;
  public LockData_Converter(ILockDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.LockData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILockDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.LockData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.LockData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LockData.Flag>(ref reader, options);
            break;
        case "Key":
            ConverterHelpers.ReadFormLink<IKeyGetter>(retval.Key, ref reader);
            break;
        case "Level":
            retval.Level = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LockLevel>(ref reader, options);
            break;
        case "Unused":
            break;
        case "Unused2":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ILodGetter_Converter : JsonConverter<ILodGetter>
{
  public override ILodGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ILodGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Lod");
    writer.WritePropertyName("Level0");
    JsonSerializer.Serialize(writer, value.Level0, options);
    writer.WritePropertyName("Level0Extra");
    JsonSerializer.Serialize(writer, value.Level0Extra, options);
    writer.WritePropertyName("Level1");
    JsonSerializer.Serialize(writer, value.Level1, options);
    writer.WritePropertyName("Level1Extra");
    JsonSerializer.Serialize(writer, value.Level1Extra, options);
    writer.WritePropertyName("Level2");
    JsonSerializer.Serialize(writer, value.Level2, options);
    writer.WritePropertyName("Level2Extra");
    JsonSerializer.Serialize(writer, value.Level2Extra, options);
    writer.WritePropertyName("Level3");
    JsonSerializer.Serialize(writer, value.Level3, options);
    writer.WritePropertyName("Level3Extra");
    JsonSerializer.Serialize(writer, value.Level3Extra, options);
    writer.WriteEndObject();
  }
}
public class Lod_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Lod>
{
  private ILodGetter_Converter _getterConverter;
  public Lod_Converter(ILodGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Lod value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ILodGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Lod Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Lod();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Level0":
            retval.Level0 = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Level0Extra":
            break;
        case "Level1":
            retval.Level1 = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Level1Extra":
            break;
        case "Level2":
            retval.Level2 = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Level2Extra":
            break;
        case "Level3":
            retval.Level3 = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Level3Extra":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectGetter_Converter : JsonConverter<IMagicEffectGetter>
{
  public override IMagicEffectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffect");
    writer.WritePropertyName("Archetype");
    JsonSerializer.Serialize(writer, value.Archetype, options);
    writer.WritePropertyName("BaseCost");
    JsonSerializer.Serialize(writer, value.BaseCost, options);
    writer.WritePropertyName("CastingArt");
    JsonSerializer.Serialize(writer, value.CastingArt, options);
    writer.WritePropertyName("CastingLight");
    JsonSerializer.Serialize(writer, value.CastingLight, options);
    writer.WritePropertyName("CastingSoundLevel");
    JsonSerializer.Serialize(writer, value.CastingSoundLevel, options);
    writer.WritePropertyName("CastType");
    JsonSerializer.Serialize(writer, value.CastType, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    if (value.CounterEffects != default)
    {
      writer.WritePropertyName("CounterEffects");
      writer.WriteStartArray();
      foreach (var itm in value.CounterEffects)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("CounterEffects");
    }
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("DualCastArt");
    JsonSerializer.Serialize(writer, value.DualCastArt, options);
    writer.WritePropertyName("DualCastScale");
    JsonSerializer.Serialize(writer, value.DualCastScale, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EnchantArt");
    JsonSerializer.Serialize(writer, value.EnchantArt, options);
    writer.WritePropertyName("EnchantShader");
    JsonSerializer.Serialize(writer, value.EnchantShader, options);
    writer.WritePropertyName("EnchantVisuals");
    JsonSerializer.Serialize(writer, value.EnchantVisuals, options);
    writer.WritePropertyName("EquipAbility");
    JsonSerializer.Serialize(writer, value.EquipAbility, options);
    writer.WritePropertyName("Explosion");
    JsonSerializer.Serialize(writer, value.Explosion, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HitEffectArt");
    JsonSerializer.Serialize(writer, value.HitEffectArt, options);
    writer.WritePropertyName("HitShader");
    JsonSerializer.Serialize(writer, value.HitShader, options);
    writer.WritePropertyName("HitVisuals");
    JsonSerializer.Serialize(writer, value.HitVisuals, options);
    writer.WritePropertyName("ImageSpaceModifier");
    JsonSerializer.Serialize(writer, value.ImageSpaceModifier, options);
    writer.WritePropertyName("ImpactData");
    JsonSerializer.Serialize(writer, value.ImpactData, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MagicSkill");
    JsonSerializer.Serialize(writer, value.MagicSkill, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MenuDisplayObject");
    JsonSerializer.Serialize(writer, value.MenuDisplayObject, options);
    writer.WritePropertyName("MinimumSkillLevel");
    JsonSerializer.Serialize(writer, value.MinimumSkillLevel, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("PerkToApply");
    JsonSerializer.Serialize(writer, value.PerkToApply, options);
    writer.WritePropertyName("Projectile");
    JsonSerializer.Serialize(writer, value.Projectile, options);
    writer.WritePropertyName("ResistValue");
    JsonSerializer.Serialize(writer, value.ResistValue, options);
    writer.WritePropertyName("ScriptEffectAIDelayTime");
    JsonSerializer.Serialize(writer, value.ScriptEffectAIDelayTime, options);
    writer.WritePropertyName("ScriptEffectAIScore");
    JsonSerializer.Serialize(writer, value.ScriptEffectAIScore, options);
    writer.WritePropertyName("SecondActorValue");
    JsonSerializer.Serialize(writer, value.SecondActorValue, options);
    writer.WritePropertyName("SecondActorValueWeight");
    JsonSerializer.Serialize(writer, value.SecondActorValueWeight, options);
    writer.WritePropertyName("SkillUsageMultiplier");
    JsonSerializer.Serialize(writer, value.SkillUsageMultiplier, options);
    if (value.Sounds != default)
    {
      writer.WritePropertyName("Sounds");
      writer.WriteStartArray();
      foreach (var itm in value.Sounds)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Sounds");
    }
    writer.WritePropertyName("SpellmakingArea");
    JsonSerializer.Serialize(writer, value.SpellmakingArea, options);
    writer.WritePropertyName("SpellmakingCastingTime");
    JsonSerializer.Serialize(writer, value.SpellmakingCastingTime, options);
    writer.WritePropertyName("TaperCurve");
    JsonSerializer.Serialize(writer, value.TaperCurve, options);
    writer.WritePropertyName("TaperDuration");
    JsonSerializer.Serialize(writer, value.TaperDuration, options);
    writer.WritePropertyName("TaperWeight");
    JsonSerializer.Serialize(writer, value.TaperWeight, options);
    writer.WritePropertyName("TargetType");
    JsonSerializer.Serialize(writer, value.TargetType, options);
    writer.WritePropertyName("Unknown1");
    JsonSerializer.Serialize(writer, value.Unknown1, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class MagicEffect_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffect>
{
  private IMagicEffectGetter_Converter _getterConverter;
  public MagicEffect_Converter(IMagicEffectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffect value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffect Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffect();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Archetype":
            retval.Archetype = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype>(ref reader, options);
            break;
        case "BaseCost":
            retval.BaseCost = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CastingArt":
            ConverterHelpers.ReadFormLink<IArtObjectGetter>(retval.CastingArt, ref reader);
            break;
        case "CastingLight":
            ConverterHelpers.ReadFormLink<ILightGetter>(retval.CastingLight, ref reader);
            break;
        case "CastingSoundLevel":
            retval.CastingSoundLevel = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundLevel>(ref reader, options);
            break;
        case "CastType":
            retval.CastType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CastType>(ref reader, options);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "CounterEffects":
            ConverterHelpers.ReadFormLinkList<IMagicEffectGetter>(retval.CounterEffects, ref reader);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffect.DATADataType>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "DualCastArt":
            ConverterHelpers.ReadFormLink<IDualCastDataGetter>(retval.DualCastArt, ref reader);
            break;
        case "DualCastScale":
            retval.DualCastScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EnchantArt":
            ConverterHelpers.ReadFormLink<IArtObjectGetter>(retval.EnchantArt, ref reader);
            break;
        case "EnchantShader":
            ConverterHelpers.ReadFormLink<IEffectShaderGetter>(retval.EnchantShader, ref reader);
            break;
        case "EnchantVisuals":
            ConverterHelpers.ReadFormLink<IVisualEffectGetter>(retval.EnchantVisuals, ref reader);
            break;
        case "EquipAbility":
            ConverterHelpers.ReadFormLink<ISpellGetter>(retval.EquipAbility, ref reader);
            break;
        case "Explosion":
            ConverterHelpers.ReadFormLink<IExplosionGetter>(retval.Explosion, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffect.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HitEffectArt":
            ConverterHelpers.ReadFormLink<IArtObjectGetter>(retval.HitEffectArt, ref reader);
            break;
        case "HitShader":
            ConverterHelpers.ReadFormLink<IEffectShaderGetter>(retval.HitShader, ref reader);
            break;
        case "HitVisuals":
            ConverterHelpers.ReadFormLink<IVisualEffectGetter>(retval.HitVisuals, ref reader);
            break;
        case "ImageSpaceModifier":
            ConverterHelpers.ReadFormLink<IImageSpaceAdapterGetter>(retval.ImageSpaceModifier, ref reader);
            break;
        case "ImpactData":
            ConverterHelpers.ReadFormLink<IImpactDataSetGetter>(retval.ImpactData, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MagicSkill":
            retval.MagicSkill = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MenuDisplayObject":
            ConverterHelpers.ReadFormLinkNullable<IStaticGetter>(retval.MenuDisplayObject, ref reader);
            break;
        case "MinimumSkillLevel":
            retval.MinimumSkillLevel = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "PerkToApply":
            ConverterHelpers.ReadFormLink<IPerkGetter>(retval.PerkToApply, ref reader);
            break;
        case "Projectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.Projectile, ref reader);
            break;
        case "ResistValue":
            retval.ResistValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "ScriptEffectAIDelayTime":
            retval.ScriptEffectAIDelayTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ScriptEffectAIScore":
            retval.ScriptEffectAIScore = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SecondActorValue":
            retval.SecondActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "SecondActorValueWeight":
            retval.SecondActorValueWeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkillUsageMultiplier":
            retval.SkillUsageMultiplier = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Sounds":
            ConverterHelpers.ReadExtendedList<MagicEffectSound>(retval.Sounds, ref reader, options);
            break;
        case "SpellmakingArea":
            retval.SpellmakingArea = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "SpellmakingCastingTime":
            retval.SpellmakingCastingTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "TaperCurve":
            retval.TaperCurve = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "TaperDuration":
            retval.TaperDuration = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "TaperWeight":
            retval.TaperWeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "TargetType":
            retval.TargetType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.TargetType>(ref reader, options);
            break;
        case "Unknown1":
            retval.Unknown1 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectArchetypeGetter_Converter : JsonConverter<IMagicEffectArchetypeGetter>
{
  public override IMagicEffectArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectArchetype>
{
  private IMagicEffectArchetypeGetter_Converter _getterConverter;
  public MagicEffectArchetype_Converter(IMagicEffectArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectBoundArchetypeGetter_Converter : JsonConverter<IMagicEffectBoundArchetypeGetter>
{
  public override IMagicEffectBoundArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectBoundArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectBoundArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("Association");
    JsonSerializer.Serialize(writer, value.Association, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectBoundArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectBoundArchetype>
{
  private IMagicEffectBoundArchetypeGetter_Converter _getterConverter;
  public MagicEffectBoundArchetype_Converter(IMagicEffectBoundArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectBoundArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectBoundArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectBoundArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectBoundArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Association":
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectCloakArchetypeGetter_Converter : JsonConverter<IMagicEffectCloakArchetypeGetter>
{
  public override IMagicEffectCloakArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectCloakArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectCloakArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("Association");
    JsonSerializer.Serialize(writer, value.Association, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectCloakArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectCloakArchetype>
{
  private IMagicEffectCloakArchetypeGetter_Converter _getterConverter;
  public MagicEffectCloakArchetype_Converter(IMagicEffectCloakArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectCloakArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectCloakArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectCloakArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectCloakArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Association":
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectEnhanceWeaponArchetypeGetter_Converter : JsonConverter<IMagicEffectEnhanceWeaponArchetypeGetter>
{
  public override IMagicEffectEnhanceWeaponArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectEnhanceWeaponArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectEnhanceWeaponArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("Association");
    JsonSerializer.Serialize(writer, value.Association, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectEnhanceWeaponArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectEnhanceWeaponArchetype>
{
  private IMagicEffectEnhanceWeaponArchetypeGetter_Converter _getterConverter;
  public MagicEffectEnhanceWeaponArchetype_Converter(IMagicEffectEnhanceWeaponArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectEnhanceWeaponArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectEnhanceWeaponArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectEnhanceWeaponArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectEnhanceWeaponArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Association":
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectGuideArchetypeGetter_Converter : JsonConverter<IMagicEffectGuideArchetypeGetter>
{
  public override IMagicEffectGuideArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectGuideArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectGuideArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("Association");
    JsonSerializer.Serialize(writer, value.Association, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectGuideArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectGuideArchetype>
{
  private IMagicEffectGuideArchetypeGetter_Converter _getterConverter;
  public MagicEffectGuideArchetype_Converter(IMagicEffectGuideArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectGuideArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectGuideArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectGuideArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectGuideArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Association":
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectLightArchetypeGetter_Converter : JsonConverter<IMagicEffectLightArchetypeGetter>
{
  public override IMagicEffectLightArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectLightArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectLightArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("Association");
    JsonSerializer.Serialize(writer, value.Association, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectLightArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectLightArchetype>
{
  private IMagicEffectLightArchetypeGetter_Converter _getterConverter;
  public MagicEffectLightArchetype_Converter(IMagicEffectLightArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectLightArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectLightArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectLightArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectLightArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Association":
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectPeakValueModArchetypeGetter_Converter : JsonConverter<IMagicEffectPeakValueModArchetypeGetter>
{
  public override IMagicEffectPeakValueModArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectPeakValueModArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectPeakValueModArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("Association");
    JsonSerializer.Serialize(writer, value.Association, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectPeakValueModArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectPeakValueModArchetype>
{
  private IMagicEffectPeakValueModArchetypeGetter_Converter _getterConverter;
  public MagicEffectPeakValueModArchetype_Converter(IMagicEffectPeakValueModArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectPeakValueModArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectPeakValueModArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectPeakValueModArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectPeakValueModArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Association":
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectSoundGetter_Converter : JsonConverter<IMagicEffectSoundGetter>
{
  public override IMagicEffectSoundGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectSoundGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectSound");
    writer.WritePropertyName("Sound");
    JsonSerializer.Serialize(writer, value.Sound, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectSound_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectSound>
{
  private IMagicEffectSoundGetter_Converter _getterConverter;
  public MagicEffectSound_Converter(IMagicEffectSoundGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectSound value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectSoundGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectSound Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectSound();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Sound":
            ConverterHelpers.ReadFormLink<ISoundDescriptorGetter>(retval.Sound, ref reader);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffect.SoundType>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectSpawnHazardArchetypeGetter_Converter : JsonConverter<IMagicEffectSpawnHazardArchetypeGetter>
{
  public override IMagicEffectSpawnHazardArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectSpawnHazardArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectSpawnHazardArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("Association");
    JsonSerializer.Serialize(writer, value.Association, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectSpawnHazardArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectSpawnHazardArchetype>
{
  private IMagicEffectSpawnHazardArchetypeGetter_Converter _getterConverter;
  public MagicEffectSpawnHazardArchetype_Converter(IMagicEffectSpawnHazardArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectSpawnHazardArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectSpawnHazardArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectSpawnHazardArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectSpawnHazardArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Association":
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectSummonCreatureArchetypeGetter_Converter : JsonConverter<IMagicEffectSummonCreatureArchetypeGetter>
{
  public override IMagicEffectSummonCreatureArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectSummonCreatureArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectSummonCreatureArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("Association");
    JsonSerializer.Serialize(writer, value.Association, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectSummonCreatureArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectSummonCreatureArchetype>
{
  private IMagicEffectSummonCreatureArchetypeGetter_Converter _getterConverter;
  public MagicEffectSummonCreatureArchetype_Converter(IMagicEffectSummonCreatureArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectSummonCreatureArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectSummonCreatureArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectSummonCreatureArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectSummonCreatureArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Association":
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectVampireArchetypeGetter_Converter : JsonConverter<IMagicEffectVampireArchetypeGetter>
{
  public override IMagicEffectVampireArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectVampireArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectVampireArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("Association");
    JsonSerializer.Serialize(writer, value.Association, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectVampireArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectVampireArchetype>
{
  private IMagicEffectVampireArchetypeGetter_Converter _getterConverter;
  public MagicEffectVampireArchetype_Converter(IMagicEffectVampireArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectVampireArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectVampireArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectVampireArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectVampireArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Association":
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMagicEffectWerewolfArchetypeGetter_Converter : JsonConverter<IMagicEffectWerewolfArchetypeGetter>
{
  public override IMagicEffectWerewolfArchetypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMagicEffectWerewolfArchetypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MagicEffectWerewolfArchetype");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    writer.WritePropertyName("Association");
    JsonSerializer.Serialize(writer, value.Association, options);
    writer.WritePropertyName("AssociationKey");
    JsonSerializer.Serialize(writer, value.AssociationKey, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MagicEffectWerewolfArchetype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MagicEffectWerewolfArchetype>
{
  private IMagicEffectWerewolfArchetypeGetter_Converter _getterConverter;
  public MagicEffectWerewolfArchetype_Converter(IMagicEffectWerewolfArchetypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MagicEffectWerewolfArchetype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMagicEffectWerewolfArchetypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MagicEffectWerewolfArchetype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MagicEffectWerewolfArchetype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Association":
            break;
        case "AssociationKey":
            retval.AssociationKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.FormKey>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MagicEffectArchetype.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMapMarkerGetter_Converter : JsonConverter<IMapMarkerGetter>
{
  public override IMapMarkerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMapMarkerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MapMarker");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class MapMarker_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MapMarker>
{
  private IMapMarkerGetter_Converter _getterConverter;
  public MapMarker_Converter(IMapMarkerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MapMarker value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMapMarkerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MapMarker Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MapMarker();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MapMarker.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MapMarker.MarkerType>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMaterialObjectGetter_Converter : JsonConverter<IMaterialObjectGetter>
{
  public override IMaterialObjectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMaterialObjectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MaterialObject");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    if (value.DNAMs != default)
    {
      writer.WritePropertyName("DNAMs");
      writer.WriteStartArray();
      foreach (var itm in value.DNAMs)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DNAMs");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FalloffBias");
    JsonSerializer.Serialize(writer, value.FalloffBias, options);
    writer.WritePropertyName("FalloffScale");
    JsonSerializer.Serialize(writer, value.FalloffScale, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HasSnow");
    JsonSerializer.Serialize(writer, value.HasSnow, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MaterialUvScale");
    JsonSerializer.Serialize(writer, value.MaterialUvScale, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("NoiseUvScale");
    JsonSerializer.Serialize(writer, value.NoiseUvScale, options);
    writer.WritePropertyName("NormalDampener");
    JsonSerializer.Serialize(writer, value.NormalDampener, options);
    writer.WritePropertyName("ProjectionVector");
    JsonSerializer.Serialize(writer, value.ProjectionVector, options);
    writer.WritePropertyName("SinglePassColor");
    JsonSerializer.Serialize(writer, value.SinglePassColor, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class MaterialObject_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MaterialObject>
{
  private IMaterialObjectGetter_Converter _getterConverter;
  public MaterialObject_Converter(IMaterialObjectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MaterialObject value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMaterialObjectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MaterialObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MaterialObject();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MaterialObject.DATADataType>(ref reader, options);
            break;
        case "DNAMs":
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FalloffBias":
            retval.FalloffBias = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FalloffScale":
            retval.FalloffScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MaterialObject.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HasSnow":
            retval.HasSnow = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MaterialUvScale":
            retval.MaterialUvScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "NoiseUvScale":
            retval.NoiseUvScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NormalDampener":
            retval.NormalDampener = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ProjectionVector":
            retval.ProjectionVector = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "SinglePassColor":
            retval.SinglePassColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMaterialTypeGetter_Converter : JsonConverter<IMaterialTypeGetter>
{
  public override IMaterialTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMaterialTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MaterialType");
    writer.WritePropertyName("Buoyancy");
    JsonSerializer.Serialize(writer, value.Buoyancy, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HavokDisplayColor");
    JsonSerializer.Serialize(writer, value.HavokDisplayColor, options);
    writer.WritePropertyName("HavokImpactDataSet");
    JsonSerializer.Serialize(writer, value.HavokImpactDataSet, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Parent");
    JsonSerializer.Serialize(writer, value.Parent, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class MaterialType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MaterialType>
{
  private IMaterialTypeGetter_Converter _getterConverter;
  public MaterialType_Converter(IMaterialTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MaterialType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMaterialTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MaterialType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MaterialType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Buoyancy":
            retval.Buoyancy = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HavokDisplayColor":
            retval.HavokDisplayColor = JsonSerializer.Deserialize<Color?>(ref reader, options);
            break;
        case "HavokImpactDataSet":
            ConverterHelpers.ReadFormLinkNullable<IImpactDataSetGetter>(retval.HavokImpactDataSet, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Parent":
            ConverterHelpers.ReadFormLinkNullable<IMaterialTypeGetter>(retval.Parent, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMessageGetter_Converter : JsonConverter<IMessageGetter>
{
  public override IMessageGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMessageGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Message");
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("DisplayTime");
    JsonSerializer.Serialize(writer, value.DisplayTime, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("INAM");
    JsonSerializer.Serialize(writer, value.INAM, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.MenuButtons != default)
    {
      writer.WritePropertyName("MenuButtons");
      writer.WriteStartArray();
      foreach (var itm in value.MenuButtons)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("MenuButtons");
    }
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Quest");
    JsonSerializer.Serialize(writer, value.Quest, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Message_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Message>
{
  private IMessageGetter_Converter _getterConverter;
  public Message_Converter(IMessageGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Message value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMessageGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Message Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Message();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "DisplayTime":
            retval.DisplayTime = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Message.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "INAM":
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MenuButtons":
            ConverterHelpers.ReadExtendedList<MessageButton>(retval.MenuButtons, ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Quest":
            ConverterHelpers.ReadFormLinkNullable<IQuestGetter>(retval.Quest, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMessageButtonGetter_Converter : JsonConverter<IMessageButtonGetter>
{
  public override IMessageButtonGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMessageButtonGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MessageButton");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("Text");
    JsonSerializer.Serialize(writer, value.Text, options);
    writer.WriteEndObject();
  }
}
public class MessageButton_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MessageButton>
{
  private IMessageButtonGetter_Converter _getterConverter;
  public MessageButton_Converter(IMessageButtonGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MessageButton value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMessageButtonGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MessageButton Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MessageButton();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "Text":
            retval.Text = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMiscItemGetter_Converter : JsonConverter<IMiscItemGetter>
{
  public override IMiscItemGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMiscItemGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MiscItem");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class MiscItem_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MiscItem>
{
  private IMiscItemGetter_Converter _getterConverter;
  public MiscItem_Converter(IMiscItemGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MiscItem value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMiscItemGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MiscItem Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MiscItem();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MiscItem.DATADataType>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MiscItem.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IModelGetter_Converter : JsonConverter<IModelGetter>
{
  public override IModelGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IModelGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Model");
    if (value.AlternateTextures != default)
    {
      writer.WritePropertyName("AlternateTextures");
      writer.WriteStartArray();
      foreach (var itm in value.AlternateTextures)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("AlternateTextures");
    }
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("File");
    JsonSerializer.Serialize(writer, value.File, options);
    writer.WriteEndObject();
  }
}
public class Model_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Model>
{
  private IModelGetter_Converter _getterConverter;
  public Model_Converter(IModelGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Model value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IModelGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Model Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Model();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AlternateTextures":
            ConverterHelpers.ReadExtendedList<AlternateTexture>(retval.AlternateTextures, ref reader, options);
            break;
        case "Data":
            break;
        case "File":
            retval.File = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IModStatsGetter_Converter : JsonConverter<IModStatsGetter>
{
  public override IModStatsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IModStatsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ModStats");
    writer.WritePropertyName("NextFormID");
    JsonSerializer.Serialize(writer, value.NextFormID, options);
    writer.WritePropertyName("NumRecords");
    JsonSerializer.Serialize(writer, value.NumRecords, options);
    writer.WritePropertyName("Version");
    JsonSerializer.Serialize(writer, value.Version, options);
    writer.WriteEndObject();
  }
}
public class ModStats_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ModStats>
{
  private IModStatsGetter_Converter _getterConverter;
  public ModStats_Converter(IModStatsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ModStats value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IModStatsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ModStats Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ModStats();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "NextFormID":
            retval.NextFormID = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "NumRecords":
            retval.NumRecords = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version":
            retval.Version = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMorphGetter_Converter : JsonConverter<IMorphGetter>
{
  public override IMorphGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMorphGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Morph");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WriteEndObject();
  }
}
public class Morph_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Morph>
{
  private IMorphGetter_Converter _getterConverter;
  public Morph_Converter(IMorphGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Morph value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMorphGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Morph Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Morph();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMountDataGetter_Converter : JsonConverter<IMountDataGetter>
{
  public override IMountDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMountDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MountData");
    writer.WritePropertyName("DismountOffset");
    JsonSerializer.Serialize(writer, value.DismountOffset, options);
    writer.WritePropertyName("MountCameraOffset");
    JsonSerializer.Serialize(writer, value.MountCameraOffset, options);
    writer.WritePropertyName("MountOffset");
    JsonSerializer.Serialize(writer, value.MountOffset, options);
    writer.WriteEndObject();
  }
}
public class MountData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MountData>
{
  private IMountDataGetter_Converter _getterConverter;
  public MountData_Converter(IMountDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MountData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMountDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MountData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MountData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DismountOffset":
            retval.DismountOffset = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "MountCameraOffset":
            retval.MountCameraOffset = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "MountOffset":
            retval.MountOffset = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMoveableStaticGetter_Converter : JsonConverter<IMoveableStaticGetter>
{
  public override IMoveableStaticGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMoveableStaticGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MoveableStatic");
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LoopingSound");
    JsonSerializer.Serialize(writer, value.LoopingSound, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class MoveableStatic_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MoveableStatic>
{
  private IMoveableStaticGetter_Converter _getterConverter;
  public MoveableStatic_Converter(IMoveableStaticGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MoveableStatic value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMoveableStaticGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MoveableStatic Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MoveableStatic();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MoveableStatic.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LoopingSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.LoopingSound, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MoveableStatic.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMovementTypeGetter_Converter : JsonConverter<IMovementTypeGetter>
{
  public override IMovementTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMovementTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MovementType");
    writer.WritePropertyName("AnimationChangeThresholds");
    JsonSerializer.Serialize(writer, value.AnimationChangeThresholds, options);
    writer.WritePropertyName("BackRun");
    JsonSerializer.Serialize(writer, value.BackRun, options);
    writer.WritePropertyName("BackWalk");
    JsonSerializer.Serialize(writer, value.BackWalk, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("ForwardRun");
    JsonSerializer.Serialize(writer, value.ForwardRun, options);
    writer.WritePropertyName("ForwardWalk");
    JsonSerializer.Serialize(writer, value.ForwardWalk, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LeftRun");
    JsonSerializer.Serialize(writer, value.LeftRun, options);
    writer.WritePropertyName("LeftWalk");
    JsonSerializer.Serialize(writer, value.LeftWalk, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("RightRun");
    JsonSerializer.Serialize(writer, value.RightRun, options);
    writer.WritePropertyName("RightWalk");
    JsonSerializer.Serialize(writer, value.RightWalk, options);
    writer.WritePropertyName("RotateInPlaceRun");
    JsonSerializer.Serialize(writer, value.RotateInPlaceRun, options);
    writer.WritePropertyName("RotateInPlaceWalk");
    JsonSerializer.Serialize(writer, value.RotateInPlaceWalk, options);
    writer.WritePropertyName("RotateWhileMovingRun");
    JsonSerializer.Serialize(writer, value.RotateWhileMovingRun, options);
    writer.WritePropertyName("SPEDDataTypeState");
    JsonSerializer.Serialize(writer, value.SPEDDataTypeState, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class MovementType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MovementType>
{
  private IMovementTypeGetter_Converter _getterConverter;
  public MovementType_Converter(IMovementTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MovementType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMovementTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MovementType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MovementType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AnimationChangeThresholds":
            retval.AnimationChangeThresholds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AnimationChangeThresholds>(ref reader, options);
            break;
        case "BackRun":
            retval.BackRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BackWalk":
            retval.BackWalk = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "ForwardRun":
            retval.ForwardRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ForwardWalk":
            retval.ForwardWalk = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LeftRun":
            retval.LeftRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "LeftWalk":
            retval.LeftWalk = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "RightRun":
            retval.RightRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RightWalk":
            retval.RightWalk = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RotateInPlaceRun":
            retval.RotateInPlaceRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RotateInPlaceWalk":
            retval.RotateInPlaceWalk = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RotateWhileMovingRun":
            retval.RotateWhileMovingRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SPEDDataTypeState":
            retval.SPEDDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MovementType.SPEDDataType>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMusicTrackGetter_Converter : JsonConverter<IMusicTrackGetter>
{
  public override IMusicTrackGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMusicTrackGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MusicTrack");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    if (value.CuePoints != default)
    {
      writer.WritePropertyName("CuePoints");
      writer.WriteStartArray();
      foreach (var itm in value.CuePoints)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("CuePoints");
    }
    writer.WritePropertyName("Duration");
    JsonSerializer.Serialize(writer, value.Duration, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FadeOut");
    JsonSerializer.Serialize(writer, value.FadeOut, options);
    writer.WritePropertyName("FinaleFilename");
    JsonSerializer.Serialize(writer, value.FinaleFilename, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LoopData");
    JsonSerializer.Serialize(writer, value.LoopData, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("TrackFilename");
    JsonSerializer.Serialize(writer, value.TrackFilename, options);
    if (value.Tracks != default)
    {
      writer.WritePropertyName("Tracks");
      writer.WriteStartArray();
      foreach (var itm in value.Tracks)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Tracks");
    }
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class MusicTrack_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MusicTrack>
{
  private IMusicTrackGetter_Converter _getterConverter;
  public MusicTrack_Converter(IMusicTrackGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MusicTrack value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMusicTrackGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MusicTrack Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MusicTrack();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "CuePoints":
            ConverterHelpers.ReadExtendedList<Single>(retval.CuePoints, ref reader, options);
            break;
        case "Duration":
            retval.Duration = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FadeOut":
            retval.FadeOut = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FinaleFilename":
            retval.FinaleFilename = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LoopData":
            retval.LoopData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MusicTrackLoopData>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TrackFilename":
            retval.TrackFilename = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Tracks":
            ConverterHelpers.ReadFormLinkList<IMusicTrackGetter>(retval.Tracks, ref reader);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MusicTrack.TypeEnum>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMusicTrackLoopDataGetter_Converter : JsonConverter<IMusicTrackLoopDataGetter>
{
  public override IMusicTrackLoopDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMusicTrackLoopDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MusicTrackLoopData");
    writer.WritePropertyName("Begins");
    JsonSerializer.Serialize(writer, value.Begins, options);
    writer.WritePropertyName("Count");
    JsonSerializer.Serialize(writer, value.Count, options);
    writer.WritePropertyName("Ends");
    JsonSerializer.Serialize(writer, value.Ends, options);
    writer.WriteEndObject();
  }
}
public class MusicTrackLoopData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MusicTrackLoopData>
{
  private IMusicTrackLoopDataGetter_Converter _getterConverter;
  public MusicTrackLoopData_Converter(IMusicTrackLoopDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MusicTrackLoopData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMusicTrackLoopDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MusicTrackLoopData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MusicTrackLoopData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Begins":
            retval.Begins = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Count":
            retval.Count = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Ends":
            retval.Ends = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMusicTypeGetter_Converter : JsonConverter<IMusicTypeGetter>
{
  public override IMusicTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMusicTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MusicType");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FadeDuration");
    JsonSerializer.Serialize(writer, value.FadeDuration, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.Tracks != default)
    {
      writer.WritePropertyName("Tracks");
      writer.WriteStartArray();
      foreach (var itm in value.Tracks)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Tracks");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class MusicType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MusicType>
{
  private IMusicTypeGetter_Converter _getterConverter;
  public MusicType_Converter(IMusicTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MusicType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMusicTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MusicType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MusicType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MusicTypeData>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FadeDuration":
            retval.FadeDuration = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MusicType.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Tracks":
            ConverterHelpers.ReadFormLinkList<IMusicTrackGetter>(retval.Tracks, ref reader);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IMusicTypeDataGetter_Converter : JsonConverter<IMusicTypeDataGetter>
{
  public override IMusicTypeDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IMusicTypeDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "MusicTypeData");
    writer.WritePropertyName("DuckingDecibel");
    JsonSerializer.Serialize(writer, value.DuckingDecibel, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WriteEndObject();
  }
}
public class MusicTypeData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.MusicTypeData>
{
  private IMusicTypeDataGetter_Converter _getterConverter;
  public MusicTypeData_Converter(IMusicTypeDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.MusicTypeData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IMusicTypeDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.MusicTypeData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.MusicTypeData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DuckingDecibel":
            retval.DuckingDecibel = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INavigationDoorLinkGetter_Converter : JsonConverter<INavigationDoorLinkGetter>
{
  public override INavigationDoorLinkGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INavigationDoorLinkGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NavigationDoorLink");
    writer.WritePropertyName("NavMesh");
    JsonSerializer.Serialize(writer, value.NavMesh, options);
    writer.WritePropertyName("NavMeshTriangleIndex");
    JsonSerializer.Serialize(writer, value.NavMeshTriangleIndex, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WriteEndObject();
  }
}
public class NavigationDoorLink_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NavigationDoorLink>
{
  private INavigationDoorLinkGetter_Converter _getterConverter;
  public NavigationDoorLink_Converter(INavigationDoorLinkGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NavigationDoorLink value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INavigationDoorLinkGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NavigationDoorLink Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NavigationDoorLink();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "NavMesh":
            ConverterHelpers.ReadFormLink<INavigationMeshGetter>(retval.NavMesh, ref reader);
            break;
        case "NavMeshTriangleIndex":
            retval.NavMeshTriangleIndex = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Unused":
            retval.Unused = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INavigationMapInfoGetter_Converter : JsonConverter<INavigationMapInfoGetter>
{
  public override INavigationMapInfoGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INavigationMapInfoGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NavigationMapInfo");
    writer.WritePropertyName("Island");
    JsonSerializer.Serialize(writer, value.Island, options);
    if (value.LinkedDoors != default)
    {
      writer.WritePropertyName("LinkedDoors");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedDoors)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedDoors");
    }
    if (value.MergedTo != default)
    {
      writer.WritePropertyName("MergedTo");
      writer.WriteStartArray();
      foreach (var itm in value.MergedTo)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("MergedTo");
    }
    writer.WritePropertyName("NavigationMesh");
    JsonSerializer.Serialize(writer, value.NavigationMesh, options);
    writer.WritePropertyName("ParentCell");
    JsonSerializer.Serialize(writer, value.ParentCell, options);
    writer.WritePropertyName("ParentWorldspace");
    JsonSerializer.Serialize(writer, value.ParentWorldspace, options);
    writer.WritePropertyName("ParentWorldspaceCoord");
    JsonSerializer.Serialize(writer, value.ParentWorldspaceCoord, options);
    writer.WritePropertyName("Point");
    JsonSerializer.Serialize(writer, value.Point, options);
    if (value.PreferredMerges != default)
    {
      writer.WritePropertyName("PreferredMerges");
      writer.WriteStartArray();
      foreach (var itm in value.PreferredMerges)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("PreferredMerges");
    }
    writer.WritePropertyName("PreferredMergesFlag");
    JsonSerializer.Serialize(writer, value.PreferredMergesFlag, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class NavigationMapInfo_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NavigationMapInfo>
{
  private INavigationMapInfoGetter_Converter _getterConverter;
  public NavigationMapInfo_Converter(INavigationMapInfoGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NavigationMapInfo value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INavigationMapInfoGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NavigationMapInfo Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NavigationMapInfo();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Island":
            retval.Island = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.IslandData>(ref reader, options);
            break;
        case "LinkedDoors":
            ConverterHelpers.ReadExtendedList<LinkedDoor>(retval.LinkedDoors, ref reader, options);
            break;
        case "MergedTo":
            ConverterHelpers.ReadFormLinkList<INavigationMeshGetter>(retval.MergedTo, ref reader);
            break;
        case "NavigationMesh":
            ConverterHelpers.ReadFormLink<INavigationMeshGetter>(retval.NavigationMesh, ref reader);
            break;
        case "ParentCell":
            ConverterHelpers.ReadFormLink<ICellGetter>(retval.ParentCell, ref reader);
            break;
        case "ParentWorldspace":
            ConverterHelpers.ReadFormLink<IWorldspaceGetter>(retval.ParentWorldspace, ref reader);
            break;
        case "ParentWorldspaceCoord":
            retval.ParentWorldspaceCoord = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        case "Point":
            retval.Point = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "PreferredMerges":
            ConverterHelpers.ReadFormLinkList<INavigationMeshGetter>(retval.PreferredMerges, ref reader);
            break;
        case "PreferredMergesFlag":
            retval.PreferredMergesFlag = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INavigationMeshGetter_Converter : JsonConverter<INavigationMeshGetter>
{
  public override INavigationMeshGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INavigationMeshGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NavigationMesh");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("NNAM");
    JsonSerializer.Serialize(writer, value.NNAM, options);
    writer.WritePropertyName("ONAM");
    JsonSerializer.Serialize(writer, value.ONAM, options);
    writer.WritePropertyName("PNAM");
    JsonSerializer.Serialize(writer, value.PNAM, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class NavigationMesh_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NavigationMesh>
{
  private INavigationMeshGetter_Converter _getterConverter;
  public NavigationMesh_Converter(INavigationMeshGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NavigationMesh value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INavigationMeshGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NavigationMesh Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NavigationMesh();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.NavigationMeshData>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.NavigationMesh.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "NNAM":
            break;
        case "ONAM":
            break;
        case "PNAM":
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INavigationMeshDataGetter_Converter : JsonConverter<INavigationMeshDataGetter>
{
  public override INavigationMeshDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INavigationMeshDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NavigationMeshData");
    if (value.DoorTriangles != default)
    {
      writer.WritePropertyName("DoorTriangles");
      writer.WriteStartArray();
      foreach (var itm in value.DoorTriangles)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DoorTriangles");
    }
    if (value.EdgeLinks != default)
    {
      writer.WritePropertyName("EdgeLinks");
      writer.WriteStartArray();
      foreach (var itm in value.EdgeLinks)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("EdgeLinks");
    }
    writer.WritePropertyName("Magic");
    JsonSerializer.Serialize(writer, value.Magic, options);
    writer.WritePropertyName("Max");
    JsonSerializer.Serialize(writer, value.Max, options);
    writer.WritePropertyName("MaxDistanceX");
    JsonSerializer.Serialize(writer, value.MaxDistanceX, options);
    writer.WritePropertyName("MaxDistanceY");
    JsonSerializer.Serialize(writer, value.MaxDistanceY, options);
    writer.WritePropertyName("Min");
    JsonSerializer.Serialize(writer, value.Min, options);
    writer.WritePropertyName("NavmeshGrid");
    JsonSerializer.Serialize(writer, value.NavmeshGrid, options);
    writer.WritePropertyName("NavmeshGridDivisor");
    JsonSerializer.Serialize(writer, value.NavmeshGridDivisor, options);
    writer.WritePropertyName("NavmeshVersion");
    JsonSerializer.Serialize(writer, value.NavmeshVersion, options);
    writer.WritePropertyName("Parent");
    JsonSerializer.Serialize(writer, value.Parent, options);
    if (value.Triangles != default)
    {
      writer.WritePropertyName("Triangles");
      writer.WriteStartArray();
      foreach (var itm in value.Triangles)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Triangles");
    }
    if (value.Vertices != default)
    {
      writer.WritePropertyName("Vertices");
      writer.WriteStartArray();
      foreach (var itm in value.Vertices)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Vertices");
    }
    writer.WriteEndObject();
  }
}
public class NavigationMeshData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NavigationMeshData>
{
  private INavigationMeshDataGetter_Converter _getterConverter;
  public NavigationMeshData_Converter(INavigationMeshDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NavigationMeshData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INavigationMeshDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NavigationMeshData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NavigationMeshData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DoorTriangles":
            ConverterHelpers.ReadExtendedList<DoorTriangle>(retval.DoorTriangles, ref reader, options);
            break;
        case "EdgeLinks":
            ConverterHelpers.ReadExtendedList<EdgeLink>(retval.EdgeLinks, ref reader, options);
            break;
        case "Magic":
            retval.Magic = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Max":
            retval.Max = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "MaxDistanceX":
            retval.MaxDistanceX = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MaxDistanceY":
            retval.MaxDistanceY = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Min":
            retval.Min = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "NavmeshGrid":
            break;
        case "NavmeshGridDivisor":
            retval.NavmeshGridDivisor = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "NavmeshVersion":
            retval.NavmeshVersion = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Parent":
            retval.Parent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ANavmeshParent>(ref reader, options);
            break;
        case "Triangles":
            ConverterHelpers.ReadExtendedList<NavmeshTriangle>(retval.Triangles, ref reader, options);
            break;
        case "Vertices":
            ConverterHelpers.ReadExtendedList<P3Float>(retval.Vertices, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INavigationMeshInfoMapGetter_Converter : JsonConverter<INavigationMeshInfoMapGetter>
{
  public override INavigationMeshInfoMapGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INavigationMeshInfoMapGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NavigationMeshInfoMap");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.MapInfos != default)
    {
      writer.WritePropertyName("MapInfos");
      writer.WriteStartArray();
      foreach (var itm in value.MapInfos)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("MapInfos");
    }
    writer.WritePropertyName("NavMeshVersion");
    JsonSerializer.Serialize(writer, value.NavMeshVersion, options);
    writer.WritePropertyName("NVSI");
    JsonSerializer.Serialize(writer, value.NVSI, options);
    writer.WritePropertyName("PreferredPathing");
    JsonSerializer.Serialize(writer, value.PreferredPathing, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class NavigationMeshInfoMap_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NavigationMeshInfoMap>
{
  private INavigationMeshInfoMapGetter_Converter _getterConverter;
  public NavigationMeshInfoMap_Converter(INavigationMeshInfoMapGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NavigationMeshInfoMap value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INavigationMeshInfoMapGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NavigationMeshInfoMap Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NavigationMeshInfoMap();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MapInfos":
            ConverterHelpers.ReadExtendedList<NavigationMapInfo>(retval.MapInfos, ref reader, options);
            break;
        case "NavMeshVersion":
            retval.NavMeshVersion = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "NVSI":
            break;
        case "PreferredPathing":
            retval.PreferredPathing = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PreferredPathing>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INavmeshNodeGetter_Converter : JsonConverter<INavmeshNodeGetter>
{
  public override INavmeshNodeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INavmeshNodeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NavmeshNode");
    writer.WritePropertyName("NavMesh");
    JsonSerializer.Serialize(writer, value.NavMesh, options);
    writer.WritePropertyName("NodeIndex");
    JsonSerializer.Serialize(writer, value.NodeIndex, options);
    writer.WriteEndObject();
  }
}
public class NavmeshNode_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NavmeshNode>
{
  private INavmeshNodeGetter_Converter _getterConverter;
  public NavmeshNode_Converter(INavmeshNodeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NavmeshNode value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INavmeshNodeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NavmeshNode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NavmeshNode();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "NavMesh":
            ConverterHelpers.ReadFormLink<INavigationMeshGetter>(retval.NavMesh, ref reader);
            break;
        case "NodeIndex":
            retval.NodeIndex = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INavmeshSetGetter_Converter : JsonConverter<INavmeshSetGetter>
{
  public override INavmeshSetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INavmeshSetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NavmeshSet");
    if (value.Navmeshes != default)
    {
      writer.WritePropertyName("Navmeshes");
      writer.WriteStartArray();
      foreach (var itm in value.Navmeshes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Navmeshes");
    }
    writer.WriteEndObject();
  }
}
public class NavmeshSet_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NavmeshSet>
{
  private INavmeshSetGetter_Converter _getterConverter;
  public NavmeshSet_Converter(INavmeshSetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NavmeshSet value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INavmeshSetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NavmeshSet Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NavmeshSet();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Navmeshes":
            ConverterHelpers.ReadFormLinkList<INavigationMeshGetter>(retval.Navmeshes, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INavmeshTriangleGetter_Converter : JsonConverter<INavmeshTriangleGetter>
{
  public override INavmeshTriangleGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INavmeshTriangleGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NavmeshTriangle");
    writer.WritePropertyName("CoverFlags");
    JsonSerializer.Serialize(writer, value.CoverFlags, options);
    writer.WritePropertyName("EdgeLink_0_1");
    JsonSerializer.Serialize(writer, value.EdgeLink_0_1, options);
    writer.WritePropertyName("EdgeLink_1_2");
    JsonSerializer.Serialize(writer, value.EdgeLink_1_2, options);
    writer.WritePropertyName("EdgeLink_2_0");
    JsonSerializer.Serialize(writer, value.EdgeLink_2_0, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("IsCover");
    JsonSerializer.Serialize(writer, value.IsCover, options);
    writer.WritePropertyName("Vertices");
    JsonSerializer.Serialize(writer, value.Vertices, options);
    writer.WriteEndObject();
  }
}
public class NavmeshTriangle_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NavmeshTriangle>
{
  private INavmeshTriangleGetter_Converter _getterConverter;
  public NavmeshTriangle_Converter(INavmeshTriangleGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NavmeshTriangle value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INavmeshTriangleGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NavmeshTriangle Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NavmeshTriangle();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CoverFlags":
            retval.CoverFlags = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "EdgeLink_0_1":
            retval.EdgeLink_0_1 = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "EdgeLink_1_2":
            retval.EdgeLink_1_2 = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "EdgeLink_2_0":
            retval.EdgeLink_2_0 = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.NavmeshTriangle.Flag>(ref reader, options);
            break;
        case "IsCover":
            retval.IsCover = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Vertices":
            retval.Vertices = JsonSerializer.Deserialize<Noggog.P3Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INoOwnerGetter_Converter : JsonConverter<INoOwnerGetter>
{
  public override INoOwnerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INoOwnerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NoOwner");
    writer.WritePropertyName("RawOwnerData");
    JsonSerializer.Serialize(writer, value.RawOwnerData, options);
    writer.WritePropertyName("RawVariableData");
    JsonSerializer.Serialize(writer, value.RawVariableData, options);
    writer.WriteEndObject();
  }
}
public class NoOwner_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NoOwner>
{
  private INoOwnerGetter_Converter _getterConverter;
  public NoOwner_Converter(INoOwnerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NoOwner value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INoOwnerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NoOwner Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NoOwner();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "RawOwnerData":
            retval.RawOwnerData = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "RawVariableData":
            retval.RawVariableData = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INpcGetter_Converter : JsonConverter<INpcGetter>
{
  public override INpcGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INpcGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Npc");
    if (value.ActorEffect != default)
    {
      writer.WritePropertyName("ActorEffect");
      writer.WriteStartArray();
      foreach (var itm in value.ActorEffect)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ActorEffect");
    }
    writer.WritePropertyName("AIData");
    JsonSerializer.Serialize(writer, value.AIData, options);
    writer.WritePropertyName("AttackRace");
    JsonSerializer.Serialize(writer, value.AttackRace, options);
    if (value.Attacks != default)
    {
      writer.WritePropertyName("Attacks");
      writer.WriteStartArray();
      foreach (var itm in value.Attacks)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Attacks");
    }
    writer.WritePropertyName("Class");
    JsonSerializer.Serialize(writer, value.Class, options);
    writer.WritePropertyName("CombatOverridePackageList");
    JsonSerializer.Serialize(writer, value.CombatOverridePackageList, options);
    writer.WritePropertyName("CombatStyle");
    JsonSerializer.Serialize(writer, value.CombatStyle, options);
    writer.WritePropertyName("Configuration");
    JsonSerializer.Serialize(writer, value.Configuration, options);
    writer.WritePropertyName("CrimeFaction");
    JsonSerializer.Serialize(writer, value.CrimeFaction, options);
    writer.WritePropertyName("DeathItem");
    JsonSerializer.Serialize(writer, value.DeathItem, options);
    writer.WritePropertyName("DefaultOutfit");
    JsonSerializer.Serialize(writer, value.DefaultOutfit, options);
    writer.WritePropertyName("DefaultPackageList");
    JsonSerializer.Serialize(writer, value.DefaultPackageList, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FaceMorph");
    JsonSerializer.Serialize(writer, value.FaceMorph, options);
    writer.WritePropertyName("FaceParts");
    JsonSerializer.Serialize(writer, value.FaceParts, options);
    if (value.Factions != default)
    {
      writer.WritePropertyName("Factions");
      writer.WriteStartArray();
      foreach (var itm in value.Factions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Factions");
    }
    writer.WritePropertyName("FarAwayModel");
    JsonSerializer.Serialize(writer, value.FarAwayModel, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("GiftFilter");
    JsonSerializer.Serialize(writer, value.GiftFilter, options);
    writer.WritePropertyName("GuardWarnOverridePackageList");
    JsonSerializer.Serialize(writer, value.GuardWarnOverridePackageList, options);
    writer.WritePropertyName("HairColor");
    JsonSerializer.Serialize(writer, value.HairColor, options);
    if (value.HeadParts != default)
    {
      writer.WritePropertyName("HeadParts");
      writer.WriteStartArray();
      foreach (var itm in value.HeadParts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("HeadParts");
    }
    writer.WritePropertyName("HeadTexture");
    JsonSerializer.Serialize(writer, value.HeadTexture, options);
    writer.WritePropertyName("Height");
    JsonSerializer.Serialize(writer, value.Height, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Items != default)
    {
      writer.WritePropertyName("Items");
      writer.WriteStartArray();
      foreach (var itm in value.Items)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Items");
    }
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("NAM5");
    JsonSerializer.Serialize(writer, value.NAM5, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("ObserveDeadBodyOverridePackageList");
    JsonSerializer.Serialize(writer, value.ObserveDeadBodyOverridePackageList, options);
    if (value.Packages != default)
    {
      writer.WritePropertyName("Packages");
      writer.WriteStartArray();
      foreach (var itm in value.Packages)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Packages");
    }
    if (value.Perks != default)
    {
      writer.WritePropertyName("Perks");
      writer.WriteStartArray();
      foreach (var itm in value.Perks)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Perks");
    }
    writer.WritePropertyName("PlayerSkills");
    JsonSerializer.Serialize(writer, value.PlayerSkills, options);
    writer.WritePropertyName("Race");
    JsonSerializer.Serialize(writer, value.Race, options);
    writer.WritePropertyName("ShortName");
    JsonSerializer.Serialize(writer, value.ShortName, options);
    writer.WritePropertyName("SleepingOutfit");
    JsonSerializer.Serialize(writer, value.SleepingOutfit, options);
    writer.WritePropertyName("Sound");
    JsonSerializer.Serialize(writer, value.Sound, options);
    writer.WritePropertyName("SoundLevel");
    JsonSerializer.Serialize(writer, value.SoundLevel, options);
    writer.WritePropertyName("SpectatorOverridePackageList");
    JsonSerializer.Serialize(writer, value.SpectatorOverridePackageList, options);
    writer.WritePropertyName("Template");
    JsonSerializer.Serialize(writer, value.Template, options);
    writer.WritePropertyName("TextureLighting");
    JsonSerializer.Serialize(writer, value.TextureLighting, options);
    if (value.TintLayers != default)
    {
      writer.WritePropertyName("TintLayers");
      writer.WriteStartArray();
      foreach (var itm in value.TintLayers)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("TintLayers");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("Voice");
    JsonSerializer.Serialize(writer, value.Voice, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WritePropertyName("WornArmor");
    JsonSerializer.Serialize(writer, value.WornArmor, options);
    writer.WriteEndObject();
  }
}
public class Npc_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Npc>
{
  private INpcGetter_Converter _getterConverter;
  public Npc_Converter(INpcGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Npc value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INpcGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Npc Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Npc();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorEffect":
            ConverterHelpers.ReadFormLinkList<ISpellRecordGetter>(retval.ActorEffect, ref reader);
            break;
        case "AIData":
            retval.AIData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AIData>(ref reader, options);
            break;
        case "AttackRace":
            ConverterHelpers.ReadFormLinkNullable<IRaceGetter>(retval.AttackRace, ref reader);
            break;
        case "Attacks":
            ConverterHelpers.ReadExtendedList<Attack>(retval.Attacks, ref reader, options);
            break;
        case "Class":
            ConverterHelpers.ReadFormLink<IClassGetter>(retval.Class, ref reader);
            break;
        case "CombatOverridePackageList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.CombatOverridePackageList, ref reader);
            break;
        case "CombatStyle":
            ConverterHelpers.ReadFormLinkNullable<ICombatStyleGetter>(retval.CombatStyle, ref reader);
            break;
        case "Configuration":
            retval.Configuration = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.NpcConfiguration>(ref reader, options);
            break;
        case "CrimeFaction":
            ConverterHelpers.ReadFormLinkNullable<IFactionGetter>(retval.CrimeFaction, ref reader);
            break;
        case "DeathItem":
            ConverterHelpers.ReadFormLinkNullable<ILeveledItemGetter>(retval.DeathItem, ref reader);
            break;
        case "DefaultOutfit":
            ConverterHelpers.ReadFormLinkNullable<IOutfitGetter>(retval.DefaultOutfit, ref reader);
            break;
        case "DefaultPackageList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.DefaultPackageList, ref reader);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FaceMorph":
            retval.FaceMorph = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.NpcFaceMorph>(ref reader, options);
            break;
        case "FaceParts":
            retval.FaceParts = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.NpcFaceParts>(ref reader, options);
            break;
        case "Factions":
            ConverterHelpers.ReadExtendedList<RankPlacement>(retval.Factions, ref reader, options);
            break;
        case "FarAwayModel":
            ConverterHelpers.ReadFormLinkNullable<IArmorGetter>(retval.FarAwayModel, ref reader);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "GiftFilter":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.GiftFilter, ref reader);
            break;
        case "GuardWarnOverridePackageList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.GuardWarnOverridePackageList, ref reader);
            break;
        case "HairColor":
            ConverterHelpers.ReadFormLinkNullable<IColorRecordGetter>(retval.HairColor, ref reader);
            break;
        case "HeadParts":
            ConverterHelpers.ReadFormLinkList<IHeadPartGetter>(retval.HeadParts, ref reader);
            break;
        case "HeadTexture":
            ConverterHelpers.ReadFormLinkNullable<ITextureSetGetter>(retval.HeadTexture, ref reader);
            break;
        case "Height":
            retval.Height = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Items":
            ConverterHelpers.ReadExtendedList<ContainerEntry>(retval.Items, ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Npc.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "NAM5":
            retval.NAM5 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "ObserveDeadBodyOverridePackageList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.ObserveDeadBodyOverridePackageList, ref reader);
            break;
        case "Packages":
            ConverterHelpers.ReadFormLinkList<IPackageGetter>(retval.Packages, ref reader);
            break;
        case "Perks":
            ConverterHelpers.ReadExtendedList<PerkPlacement>(retval.Perks, ref reader, options);
            break;
        case "PlayerSkills":
            retval.PlayerSkills = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PlayerSkills>(ref reader, options);
            break;
        case "Race":
            ConverterHelpers.ReadFormLink<IRaceGetter>(retval.Race, ref reader);
            break;
        case "ShortName":
            retval.ShortName = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SleepingOutfit":
            ConverterHelpers.ReadFormLinkNullable<IOutfitGetter>(retval.SleepingOutfit, ref reader);
            break;
        case "Sound":
            retval.Sound = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ANpcSoundDefinition>(ref reader, options);
            break;
        case "SoundLevel":
            retval.SoundLevel = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundLevel>(ref reader, options);
            break;
        case "SpectatorOverridePackageList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.SpectatorOverridePackageList, ref reader);
            break;
        case "Template":
            ConverterHelpers.ReadFormLinkNullable<INpcSpawnGetter>(retval.Template, ref reader);
            break;
        case "TextureLighting":
            retval.TextureLighting = JsonSerializer.Deserialize<Color?>(ref reader, options);
            break;
        case "TintLayers":
            ConverterHelpers.ReadExtendedList<TintLayer>(retval.TintLayers, ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "Voice":
            ConverterHelpers.ReadFormLinkNullable<IVoiceTypeGetter>(retval.Voice, ref reader);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "WornArmor":
            ConverterHelpers.ReadFormLinkNullable<IArmorGetter>(retval.WornArmor, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INpcConfigurationGetter_Converter : JsonConverter<INpcConfigurationGetter>
{
  public override INpcConfigurationGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INpcConfigurationGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NpcConfiguration");
    writer.WritePropertyName("BleedoutOverride");
    JsonSerializer.Serialize(writer, value.BleedoutOverride, options);
    writer.WritePropertyName("CalcMaxLevel");
    JsonSerializer.Serialize(writer, value.CalcMaxLevel, options);
    writer.WritePropertyName("CalcMinLevel");
    JsonSerializer.Serialize(writer, value.CalcMinLevel, options);
    writer.WritePropertyName("DispositionBase");
    JsonSerializer.Serialize(writer, value.DispositionBase, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("HealthOffset");
    JsonSerializer.Serialize(writer, value.HealthOffset, options);
    writer.WritePropertyName("Level");
    JsonSerializer.Serialize(writer, value.Level, options);
    writer.WritePropertyName("MagickaOffset");
    JsonSerializer.Serialize(writer, value.MagickaOffset, options);
    writer.WritePropertyName("SpeedMultiplier");
    JsonSerializer.Serialize(writer, value.SpeedMultiplier, options);
    writer.WritePropertyName("StaminaOffset");
    JsonSerializer.Serialize(writer, value.StaminaOffset, options);
    writer.WritePropertyName("TemplateFlags");
    JsonSerializer.Serialize(writer, value.TemplateFlags, options);
    writer.WriteEndObject();
  }
}
public class NpcConfiguration_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NpcConfiguration>
{
  private INpcConfigurationGetter_Converter _getterConverter;
  public NpcConfiguration_Converter(INpcConfigurationGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NpcConfiguration value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INpcConfigurationGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NpcConfiguration Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NpcConfiguration();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BleedoutOverride":
            retval.BleedoutOverride = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "CalcMaxLevel":
            retval.CalcMaxLevel = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "CalcMinLevel":
            retval.CalcMinLevel = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "DispositionBase":
            retval.DispositionBase = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.NpcConfiguration.Flag>(ref reader, options);
            break;
        case "HealthOffset":
            retval.HealthOffset = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Level":
            retval.Level = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ANpcLevel>(ref reader, options);
            break;
        case "MagickaOffset":
            retval.MagickaOffset = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "SpeedMultiplier":
            retval.SpeedMultiplier = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "StaminaOffset":
            retval.StaminaOffset = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "TemplateFlags":
            retval.TemplateFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.NpcConfiguration.TemplateFlag>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INpcFaceMorphGetter_Converter : JsonConverter<INpcFaceMorphGetter>
{
  public override INpcFaceMorphGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INpcFaceMorphGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NpcFaceMorph");
    writer.WritePropertyName("BrowsForwardVsBack");
    JsonSerializer.Serialize(writer, value.BrowsForwardVsBack, options);
    writer.WritePropertyName("BrowsInVsOut");
    JsonSerializer.Serialize(writer, value.BrowsInVsOut, options);
    writer.WritePropertyName("BrowsUpVsDown");
    JsonSerializer.Serialize(writer, value.BrowsUpVsDown, options);
    writer.WritePropertyName("CheeksForwardVsBack");
    JsonSerializer.Serialize(writer, value.CheeksForwardVsBack, options);
    writer.WritePropertyName("CheeksUpVsDown");
    JsonSerializer.Serialize(writer, value.CheeksUpVsDown, options);
    writer.WritePropertyName("ChinNarrowVsWide");
    JsonSerializer.Serialize(writer, value.ChinNarrowVsWide, options);
    writer.WritePropertyName("ChinUnderbiteVsOverbite");
    JsonSerializer.Serialize(writer, value.ChinUnderbiteVsOverbite, options);
    writer.WritePropertyName("ChinUpVsDown");
    JsonSerializer.Serialize(writer, value.ChinUpVsDown, options);
    writer.WritePropertyName("EyesForwardVsBack");
    JsonSerializer.Serialize(writer, value.EyesForwardVsBack, options);
    writer.WritePropertyName("EyesInVsOut");
    JsonSerializer.Serialize(writer, value.EyesInVsOut, options);
    writer.WritePropertyName("EyesUpVsDown");
    JsonSerializer.Serialize(writer, value.EyesUpVsDown, options);
    writer.WritePropertyName("JawForwardVsBack");
    JsonSerializer.Serialize(writer, value.JawForwardVsBack, options);
    writer.WritePropertyName("JawNarrowVsWide");
    JsonSerializer.Serialize(writer, value.JawNarrowVsWide, options);
    writer.WritePropertyName("JawUpVsDown");
    JsonSerializer.Serialize(writer, value.JawUpVsDown, options);
    writer.WritePropertyName("LipsInVsOut");
    JsonSerializer.Serialize(writer, value.LipsInVsOut, options);
    writer.WritePropertyName("LipsUpVsDown");
    JsonSerializer.Serialize(writer, value.LipsUpVsDown, options);
    writer.WritePropertyName("NoseLongVsShort");
    JsonSerializer.Serialize(writer, value.NoseLongVsShort, options);
    writer.WritePropertyName("NoseUpVsDown");
    JsonSerializer.Serialize(writer, value.NoseUpVsDown, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class NpcFaceMorph_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NpcFaceMorph>
{
  private INpcFaceMorphGetter_Converter _getterConverter;
  public NpcFaceMorph_Converter(INpcFaceMorphGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NpcFaceMorph value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INpcFaceMorphGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NpcFaceMorph Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NpcFaceMorph();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BrowsForwardVsBack":
            retval.BrowsForwardVsBack = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BrowsInVsOut":
            retval.BrowsInVsOut = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BrowsUpVsDown":
            retval.BrowsUpVsDown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CheeksForwardVsBack":
            retval.CheeksForwardVsBack = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CheeksUpVsDown":
            retval.CheeksUpVsDown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ChinNarrowVsWide":
            retval.ChinNarrowVsWide = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ChinUnderbiteVsOverbite":
            retval.ChinUnderbiteVsOverbite = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ChinUpVsDown":
            retval.ChinUpVsDown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EyesForwardVsBack":
            retval.EyesForwardVsBack = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EyesInVsOut":
            retval.EyesInVsOut = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EyesUpVsDown":
            retval.EyesUpVsDown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "JawForwardVsBack":
            retval.JawForwardVsBack = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "JawNarrowVsWide":
            retval.JawNarrowVsWide = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "JawUpVsDown":
            retval.JawUpVsDown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "LipsInVsOut":
            retval.LipsInVsOut = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "LipsUpVsDown":
            retval.LipsUpVsDown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoseLongVsShort":
            retval.NoseLongVsShort = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoseUpVsDown":
            retval.NoseUpVsDown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INpcFacePartsGetter_Converter : JsonConverter<INpcFacePartsGetter>
{
  public override INpcFacePartsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INpcFacePartsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NpcFaceParts");
    writer.WritePropertyName("Eyes");
    JsonSerializer.Serialize(writer, value.Eyes, options);
    writer.WritePropertyName("Mouth");
    JsonSerializer.Serialize(writer, value.Mouth, options);
    writer.WritePropertyName("Nose");
    JsonSerializer.Serialize(writer, value.Nose, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class NpcFaceParts_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NpcFaceParts>
{
  private INpcFacePartsGetter_Converter _getterConverter;
  public NpcFaceParts_Converter(INpcFacePartsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NpcFaceParts value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INpcFacePartsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NpcFaceParts Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NpcFaceParts();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Eyes":
            retval.Eyes = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Mouth":
            retval.Mouth = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Nose":
            retval.Nose = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INpcInheritSoundGetter_Converter : JsonConverter<INpcInheritSoundGetter>
{
  public override INpcInheritSoundGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INpcInheritSoundGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NpcInheritSound");
    writer.WritePropertyName("InheritsSoundsFrom");
    JsonSerializer.Serialize(writer, value.InheritsSoundsFrom, options);
    writer.WriteEndObject();
  }
}
public class NpcInheritSound_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NpcInheritSound>
{
  private INpcInheritSoundGetter_Converter _getterConverter;
  public NpcInheritSound_Converter(INpcInheritSoundGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NpcInheritSound value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INpcInheritSoundGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NpcInheritSound Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NpcInheritSound();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "InheritsSoundsFrom":
            ConverterHelpers.ReadFormLinkNullable<INpcGetter>(retval.InheritsSoundsFrom, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INpcLevelGetter_Converter : JsonConverter<INpcLevelGetter>
{
  public override INpcLevelGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INpcLevelGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NpcLevel");
    writer.WritePropertyName("Level");
    JsonSerializer.Serialize(writer, value.Level, options);
    writer.WriteEndObject();
  }
}
public class NpcLevel_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NpcLevel>
{
  private INpcLevelGetter_Converter _getterConverter;
  public NpcLevel_Converter(INpcLevelGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NpcLevel value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INpcLevelGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NpcLevel Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NpcLevel();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Level":
            retval.Level = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INpcOwnerGetter_Converter : JsonConverter<INpcOwnerGetter>
{
  public override INpcOwnerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INpcOwnerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NpcOwner");
    writer.WritePropertyName("Global");
    JsonSerializer.Serialize(writer, value.Global, options);
    writer.WritePropertyName("Npc");
    JsonSerializer.Serialize(writer, value.Npc, options);
    writer.WriteEndObject();
  }
}
public class NpcOwner_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NpcOwner>
{
  private INpcOwnerGetter_Converter _getterConverter;
  public NpcOwner_Converter(INpcOwnerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NpcOwner value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INpcOwnerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NpcOwner Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NpcOwner();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Global":
            ConverterHelpers.ReadFormLink<IGlobalGetter>(retval.Global, ref reader);
            break;
        case "Npc":
            ConverterHelpers.ReadFormLink<INpcGetter>(retval.Npc, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INpcSoundGetter_Converter : JsonConverter<INpcSoundGetter>
{
  public override INpcSoundGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INpcSoundGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NpcSound");
    writer.WritePropertyName("Sound");
    JsonSerializer.Serialize(writer, value.Sound, options);
    writer.WritePropertyName("SoundChance");
    JsonSerializer.Serialize(writer, value.SoundChance, options);
    writer.WriteEndObject();
  }
}
public class NpcSound_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NpcSound>
{
  private INpcSoundGetter_Converter _getterConverter;
  public NpcSound_Converter(INpcSoundGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NpcSound value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INpcSoundGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NpcSound Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NpcSound();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Sound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.Sound, ref reader);
            break;
        case "SoundChance":
            retval.SoundChance = JsonSerializer.Deserialize<Byte?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INpcSoundTypeGetter_Converter : JsonConverter<INpcSoundTypeGetter>
{
  public override INpcSoundTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INpcSoundTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NpcSoundType");
    if (value.Sounds != default)
    {
      writer.WritePropertyName("Sounds");
      writer.WriteStartArray();
      foreach (var itm in value.Sounds)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Sounds");
    }
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class NpcSoundType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NpcSoundType>
{
  private INpcSoundTypeGetter_Converter _getterConverter;
  public NpcSoundType_Converter(INpcSoundTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NpcSoundType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INpcSoundTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NpcSoundType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NpcSoundType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Sounds":
            ConverterHelpers.ReadExtendedList<NpcSound>(retval.Sounds, ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<SoundType?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class INpcSoundTypesGetter_Converter : JsonConverter<INpcSoundTypesGetter>
{
  public override INpcSoundTypesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, INpcSoundTypesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "NpcSoundTypes");
    if (value.Types != default)
    {
      writer.WritePropertyName("Types");
      writer.WriteStartArray();
      foreach (var itm in value.Types)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Types");
    }
    writer.WriteEndObject();
  }
}
public class NpcSoundTypes_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.NpcSoundTypes>
{
  private INpcSoundTypesGetter_Converter _getterConverter;
  public NpcSoundTypes_Converter(INpcSoundTypesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.NpcSoundTypes value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (INpcSoundTypesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.NpcSoundTypes Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.NpcSoundTypes();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Types":
            ConverterHelpers.ReadExtendedList<NpcSoundType>(retval.Types, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IObjectBoundsGetter_Converter : JsonConverter<IObjectBoundsGetter>
{
  public override IObjectBoundsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IObjectBoundsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ObjectBounds");
    writer.WritePropertyName("First");
    JsonSerializer.Serialize(writer, value.First, options);
    writer.WritePropertyName("Second");
    JsonSerializer.Serialize(writer, value.Second, options);
    writer.WriteEndObject();
  }
}
public class ObjectBounds_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ObjectBounds>
{
  private IObjectBoundsGetter_Converter _getterConverter;
  public ObjectBounds_Converter(IObjectBoundsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ObjectBounds value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IObjectBoundsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ObjectBounds Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ObjectBounds();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "First":
            retval.First = JsonSerializer.Deserialize<Noggog.P3Int16>(ref reader, options);
            break;
        case "Second":
            retval.Second = JsonSerializer.Deserialize<Noggog.P3Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IObjectEffectGetter_Converter : JsonConverter<IObjectEffectGetter>
{
  public override IObjectEffectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IObjectEffectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ObjectEffect");
    writer.WritePropertyName("BaseEnchantment");
    JsonSerializer.Serialize(writer, value.BaseEnchantment, options);
    writer.WritePropertyName("CastType");
    JsonSerializer.Serialize(writer, value.CastType, options);
    writer.WritePropertyName("ChargeTime");
    JsonSerializer.Serialize(writer, value.ChargeTime, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.Effects != default)
    {
      writer.WritePropertyName("Effects");
      writer.WriteStartArray();
      foreach (var itm in value.Effects)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Effects");
    }
    writer.WritePropertyName("EnchantmentAmount");
    JsonSerializer.Serialize(writer, value.EnchantmentAmount, options);
    writer.WritePropertyName("EnchantmentCost");
    JsonSerializer.Serialize(writer, value.EnchantmentCost, options);
    writer.WritePropertyName("EnchantType");
    JsonSerializer.Serialize(writer, value.EnchantType, options);
    writer.WritePropertyName("ENITDataTypeState");
    JsonSerializer.Serialize(writer, value.ENITDataTypeState, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("TargetType");
    JsonSerializer.Serialize(writer, value.TargetType, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("WornRestrictions");
    JsonSerializer.Serialize(writer, value.WornRestrictions, options);
    writer.WriteEndObject();
  }
}
public class ObjectEffect_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ObjectEffect>
{
  private IObjectEffectGetter_Converter _getterConverter;
  public ObjectEffect_Converter(IObjectEffectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ObjectEffect value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IObjectEffectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ObjectEffect Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ObjectEffect();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BaseEnchantment":
            ConverterHelpers.ReadFormLink<IObjectEffectGetter>(retval.BaseEnchantment, ref reader);
            break;
        case "CastType":
            retval.CastType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CastType>(ref reader, options);
            break;
        case "ChargeTime":
            retval.ChargeTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Effects":
            ConverterHelpers.ReadExtendedList<Effect>(retval.Effects, ref reader, options);
            break;
        case "EnchantmentAmount":
            retval.EnchantmentAmount = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "EnchantmentCost":
            retval.EnchantmentCost = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "EnchantType":
            retval.EnchantType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectEffect.EnchantTypeEnum>(ref reader, options);
            break;
        case "ENITDataTypeState":
            retval.ENITDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectEffect.ENITDataType>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectEffect.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TargetType":
            retval.TargetType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.TargetType>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "WornRestrictions":
            ConverterHelpers.ReadFormLink<IFormListGetter>(retval.WornRestrictions, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IOutfitGetter_Converter : JsonConverter<IOutfitGetter>
{
  public override IOutfitGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IOutfitGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Outfit");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Items != default)
    {
      writer.WritePropertyName("Items");
      writer.WriteStartArray();
      foreach (var itm in value.Items)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Items");
    }
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Outfit_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Outfit>
{
  private IOutfitGetter_Converter _getterConverter;
  public Outfit_Converter(IOutfitGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Outfit value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IOutfitGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Outfit Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Outfit();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Items":
            ConverterHelpers.ReadFormLinkList<IOutfitTargetGetter>(retval.Items, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IOwnershipGetter_Converter : JsonConverter<IOwnershipGetter>
{
  public override IOwnershipGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IOwnershipGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Ownership");
    writer.WritePropertyName("FactionRank");
    JsonSerializer.Serialize(writer, value.FactionRank, options);
    writer.WritePropertyName("Owner");
    JsonSerializer.Serialize(writer, value.Owner, options);
    writer.WriteEndObject();
  }
}
public class Ownership_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Ownership>
{
  private IOwnershipGetter_Converter _getterConverter;
  public Ownership_Converter(IOwnershipGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Ownership value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IOwnershipGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Ownership Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Ownership();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FactionRank":
            retval.FactionRank = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "Owner":
            ConverterHelpers.ReadFormLinkNullable<IOwnerGetter>(retval.Owner, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageGetter_Converter : JsonConverter<IPackageGetter>
{
  public override IPackageGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Package");
    writer.WritePropertyName("CombatStyle");
    JsonSerializer.Serialize(writer, value.CombatStyle, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("DataInputVersion");
    JsonSerializer.Serialize(writer, value.DataInputVersion, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IdleAnimations");
    JsonSerializer.Serialize(writer, value.IdleAnimations, options);
    writer.WritePropertyName("InterruptOverride");
    JsonSerializer.Serialize(writer, value.InterruptOverride, options);
    writer.WritePropertyName("InteruptFlags");
    JsonSerializer.Serialize(writer, value.InteruptFlags, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("OnBegin");
    JsonSerializer.Serialize(writer, value.OnBegin, options);
    writer.WritePropertyName("OnChange");
    JsonSerializer.Serialize(writer, value.OnChange, options);
    writer.WritePropertyName("OnEnd");
    JsonSerializer.Serialize(writer, value.OnEnd, options);
    writer.WritePropertyName("OwnerQuest");
    JsonSerializer.Serialize(writer, value.OwnerQuest, options);
    writer.WritePropertyName("PackageTemplate");
    JsonSerializer.Serialize(writer, value.PackageTemplate, options);
    writer.WritePropertyName("PKDTDataTypeState");
    JsonSerializer.Serialize(writer, value.PKDTDataTypeState, options);
    writer.WritePropertyName("PreferredSpeed");
    JsonSerializer.Serialize(writer, value.PreferredSpeed, options);
    if (value.ProcedureTree != default)
    {
      writer.WritePropertyName("ProcedureTree");
      writer.WriteStartArray();
      foreach (var itm in value.ProcedureTree)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ProcedureTree");
    }
    writer.WritePropertyName("PSDTDataTypeState");
    JsonSerializer.Serialize(writer, value.PSDTDataTypeState, options);
    writer.WritePropertyName("ScheduleDate");
    JsonSerializer.Serialize(writer, value.ScheduleDate, options);
    writer.WritePropertyName("ScheduleDayOfWeek");
    JsonSerializer.Serialize(writer, value.ScheduleDayOfWeek, options);
    writer.WritePropertyName("ScheduleDurationInMinutes");
    JsonSerializer.Serialize(writer, value.ScheduleDurationInMinutes, options);
    writer.WritePropertyName("ScheduleHour");
    JsonSerializer.Serialize(writer, value.ScheduleHour, options);
    writer.WritePropertyName("ScheduleMinute");
    JsonSerializer.Serialize(writer, value.ScheduleMinute, options);
    writer.WritePropertyName("ScheduleMonth");
    JsonSerializer.Serialize(writer, value.ScheduleMonth, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WritePropertyName("Unknown3");
    JsonSerializer.Serialize(writer, value.Unknown3, options);
    writer.WritePropertyName("Unknown4");
    JsonSerializer.Serialize(writer, value.Unknown4, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("XnamMarker");
    JsonSerializer.Serialize(writer, value.XnamMarker, options);
    writer.WriteEndObject();
  }
}
public class Package_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Package>
{
  private IPackageGetter_Converter _getterConverter;
  public Package_Converter(IPackageGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Package value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Package Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Package();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CombatStyle":
            ConverterHelpers.ReadFormLinkNullable<ICombatStyleGetter>(retval.CombatStyle, ref reader);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "Data":
            break;
        case "DataInputVersion":
            retval.DataInputVersion = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IdleAnimations":
            retval.IdleAnimations = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageIdles>(ref reader, options);
            break;
        case "InterruptOverride":
            retval.InterruptOverride = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.Interrupt>(ref reader, options);
            break;
        case "InteruptFlags":
            retval.InteruptFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.InterruptFlag>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "OnBegin":
            retval.OnBegin = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageEvent>(ref reader, options);
            break;
        case "OnChange":
            retval.OnChange = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageEvent>(ref reader, options);
            break;
        case "OnEnd":
            retval.OnEnd = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageEvent>(ref reader, options);
            break;
        case "OwnerQuest":
            ConverterHelpers.ReadFormLinkNullable<IQuestGetter>(retval.OwnerQuest, ref reader);
            break;
        case "PackageTemplate":
            ConverterHelpers.ReadFormLink<IPackageGetter>(retval.PackageTemplate, ref reader);
            break;
        case "PKDTDataTypeState":
            retval.PKDTDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.PKDTDataType>(ref reader, options);
            break;
        case "PreferredSpeed":
            retval.PreferredSpeed = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.Speed>(ref reader, options);
            break;
        case "ProcedureTree":
            ConverterHelpers.ReadExtendedList<PackageBranch>(retval.ProcedureTree, ref reader, options);
            break;
        case "PSDTDataTypeState":
            retval.PSDTDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.PSDTDataType>(ref reader, options);
            break;
        case "ScheduleDate":
            retval.ScheduleDate = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "ScheduleDayOfWeek":
            retval.ScheduleDayOfWeek = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.DayOfWeek>(ref reader, options);
            break;
        case "ScheduleDurationInMinutes":
            retval.ScheduleDurationInMinutes = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ScheduleHour":
            retval.ScheduleHour = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "ScheduleMinute":
            retval.ScheduleMinute = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "ScheduleMonth":
            retval.ScheduleMonth = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.Types>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Unknown3":
            break;
        case "Unknown4":
            retval.Unknown4 = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageAdapter>(ref reader, options);
            break;
        case "XnamMarker":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageAdapterGetter_Converter : JsonConverter<IPackageAdapterGetter>
{
  public override IPackageAdapterGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageAdapterGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageAdapter");
    writer.WritePropertyName("ObjectFormat");
    JsonSerializer.Serialize(writer, value.ObjectFormat, options);
    writer.WritePropertyName("ScriptFragments");
    JsonSerializer.Serialize(writer, value.ScriptFragments, options);
    if (value.Scripts != default)
    {
      writer.WritePropertyName("Scripts");
      writer.WriteStartArray();
      foreach (var itm in value.Scripts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Scripts");
    }
    writer.WritePropertyName("Version");
    JsonSerializer.Serialize(writer, value.Version, options);
    writer.WriteEndObject();
  }
}
public class PackageAdapter_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageAdapter>
{
  private IPackageAdapterGetter_Converter _getterConverter;
  public PackageAdapter_Converter(IPackageAdapterGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageAdapter value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageAdapterGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageAdapter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageAdapter();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ObjectFormat":
            retval.ObjectFormat = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "ScriptFragments":
            retval.ScriptFragments = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageScriptFragments>(ref reader, options);
            break;
        case "Scripts":
            ConverterHelpers.ReadExtendedList<ScriptEntry>(retval.Scripts, ref reader, options);
            break;
        case "Version":
            retval.Version = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageBranchGetter_Converter : JsonConverter<IPackageBranchGetter>
{
  public override IPackageBranchGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageBranchGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageBranch");
    writer.WritePropertyName("BranchType");
    JsonSerializer.Serialize(writer, value.BranchType, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    if (value.DataInputIndices != default)
    {
      writer.WritePropertyName("DataInputIndices");
      writer.WriteStartArray();
      foreach (var itm in value.DataInputIndices)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DataInputIndices");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FlagsOverride");
    JsonSerializer.Serialize(writer, value.FlagsOverride, options);
    writer.WritePropertyName("FlagsOverrideUnused");
    JsonSerializer.Serialize(writer, value.FlagsOverrideUnused, options);
    writer.WritePropertyName("ProcedureType");
    JsonSerializer.Serialize(writer, value.ProcedureType, options);
    writer.WritePropertyName("Root");
    JsonSerializer.Serialize(writer, value.Root, options);
    if (value.Unknown != default)
    {
      writer.WritePropertyName("Unknown");
      writer.WriteStartArray();
      foreach (var itm in value.Unknown)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Unknown");
    }
    writer.WriteEndObject();
  }
}
public class PackageBranch_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageBranch>
{
  private IPackageBranchGetter_Converter _getterConverter;
  public PackageBranch_Converter(IPackageBranchGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageBranch value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageBranchGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageBranch Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageBranch();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BranchType":
            retval.BranchType = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "DataInputIndices":
            ConverterHelpers.ReadExtendedList<Byte>(retval.DataInputIndices, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FlagsOverride":
            retval.FlagsOverride = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageFlagsOverride>(ref reader, options);
            break;
        case "FlagsOverrideUnused":
            retval.FlagsOverrideUnused = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageFlagsOverride>(ref reader, options);
            break;
        case "ProcedureType":
            retval.ProcedureType = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Root":
            retval.Root = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageRoot>(ref reader, options);
            break;
        case "Unknown":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageDataBoolGetter_Converter : JsonConverter<IPackageDataBoolGetter>
{
  public override IPackageDataBoolGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageDataBoolGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageDataBool");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class PackageDataBool_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageDataBool>
{
  private IPackageDataBoolGetter_Converter _getterConverter;
  public PackageDataBool_Converter(IPackageDataBoolGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageDataBool value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageDataBoolGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageDataBool Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageDataBool();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageDataFloatGetter_Converter : JsonConverter<IPackageDataFloatGetter>
{
  public override IPackageDataFloatGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageDataFloatGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageDataFloat");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class PackageDataFloat_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageDataFloat>
{
  private IPackageDataFloatGetter_Converter _getterConverter;
  public PackageDataFloat_Converter(IPackageDataFloatGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageDataFloat value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageDataFloatGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageDataFloat Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageDataFloat();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageDataIntGetter_Converter : JsonConverter<IPackageDataIntGetter>
{
  public override IPackageDataIntGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageDataIntGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageDataInt");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class PackageDataInt_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageDataInt>
{
  private IPackageDataIntGetter_Converter _getterConverter;
  public PackageDataInt_Converter(IPackageDataIntGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageDataInt value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageDataIntGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageDataInt Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageDataInt();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageDataLocationGetter_Converter : JsonConverter<IPackageDataLocationGetter>
{
  public override IPackageDataLocationGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageDataLocationGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageDataLocation");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Location");
    JsonSerializer.Serialize(writer, value.Location, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class PackageDataLocation_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageDataLocation>
{
  private IPackageDataLocationGetter_Converter _getterConverter;
  public PackageDataLocation_Converter(IPackageDataLocationGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageDataLocation value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageDataLocationGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageDataLocation Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageDataLocation();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "Location":
            retval.Location = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LocationTargetRadius>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageDataObjectListGetter_Converter : JsonConverter<IPackageDataObjectListGetter>
{
  public override IPackageDataObjectListGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageDataObjectListGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageDataObjectList");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class PackageDataObjectList_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageDataObjectList>
{
  private IPackageDataObjectListGetter_Converter _getterConverter;
  public PackageDataObjectList_Converter(IPackageDataObjectListGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageDataObjectList value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageDataObjectListGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageDataObjectList Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageDataObjectList();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageDataTargetGetter_Converter : JsonConverter<IPackageDataTargetGetter>
{
  public override IPackageDataTargetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageDataTargetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageDataTarget");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Target");
    JsonSerializer.Serialize(writer, value.Target, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class PackageDataTarget_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageDataTarget>
{
  private IPackageDataTargetGetter_Converter _getterConverter;
  public PackageDataTarget_Converter(IPackageDataTargetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageDataTarget value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageDataTargetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageDataTarget Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageDataTarget();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Target":
            retval.Target = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APackageTarget>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageDataTarget.Types>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageDataTopicGetter_Converter : JsonConverter<IPackageDataTopicGetter>
{
  public override IPackageDataTopicGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageDataTopicGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageDataTopic");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    if (value.Topics != default)
    {
      writer.WritePropertyName("Topics");
      writer.WriteStartArray();
      foreach (var itm in value.Topics)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Topics");
    }
    writer.WritePropertyName("TPIC");
    JsonSerializer.Serialize(writer, value.TPIC, options);
    writer.WriteEndObject();
  }
}
public class PackageDataTopic_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageDataTopic>
{
  private IPackageDataTopicGetter_Converter _getterConverter;
  public PackageDataTopic_Converter(IPackageDataTopicGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageDataTopic value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageDataTopicGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageDataTopic Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageDataTopic();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Topics":
            ConverterHelpers.ReadExtendedList<ATopicReference>(retval.Topics, ref reader, options);
            break;
        case "TPIC":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageEventGetter_Converter : JsonConverter<IPackageEventGetter>
{
  public override IPackageEventGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageEventGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageEvent");
    writer.WritePropertyName("Idle");
    JsonSerializer.Serialize(writer, value.Idle, options);
    writer.WritePropertyName("QNAM");
    JsonSerializer.Serialize(writer, value.QNAM, options);
    writer.WritePropertyName("SCDA");
    JsonSerializer.Serialize(writer, value.SCDA, options);
    writer.WritePropertyName("SCHR");
    JsonSerializer.Serialize(writer, value.SCHR, options);
    writer.WritePropertyName("SCTX");
    JsonSerializer.Serialize(writer, value.SCTX, options);
    writer.WritePropertyName("TNAM");
    JsonSerializer.Serialize(writer, value.TNAM, options);
    if (value.Topics != default)
    {
      writer.WritePropertyName("Topics");
      writer.WriteStartArray();
      foreach (var itm in value.Topics)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Topics");
    }
    writer.WriteEndObject();
  }
}
public class PackageEvent_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageEvent>
{
  private IPackageEventGetter_Converter _getterConverter;
  public PackageEvent_Converter(IPackageEventGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageEvent value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageEventGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageEvent Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageEvent();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Idle":
            ConverterHelpers.ReadFormLinkNullable<IIdleAnimationGetter>(retval.Idle, ref reader);
            break;
        case "QNAM":
            break;
        case "SCDA":
            break;
        case "SCHR":
            break;
        case "SCTX":
            break;
        case "TNAM":
            break;
        case "Topics":
            ConverterHelpers.ReadExtendedList<ATopicReference>(retval.Topics, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageFlagsOverrideGetter_Converter : JsonConverter<IPackageFlagsOverrideGetter>
{
  public override IPackageFlagsOverrideGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageFlagsOverrideGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageFlagsOverride");
    writer.WritePropertyName("ClearFlags");
    JsonSerializer.Serialize(writer, value.ClearFlags, options);
    writer.WritePropertyName("ClearInterruptFlags");
    JsonSerializer.Serialize(writer, value.ClearInterruptFlags, options);
    writer.WritePropertyName("PreferredSpeed");
    JsonSerializer.Serialize(writer, value.PreferredSpeed, options);
    writer.WritePropertyName("SetFlags");
    JsonSerializer.Serialize(writer, value.SetFlags, options);
    writer.WritePropertyName("SetInterruptFlags");
    JsonSerializer.Serialize(writer, value.SetInterruptFlags, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class PackageFlagsOverride_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageFlagsOverride>
{
  private IPackageFlagsOverrideGetter_Converter _getterConverter;
  public PackageFlagsOverride_Converter(IPackageFlagsOverrideGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageFlagsOverride value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageFlagsOverrideGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageFlagsOverride Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageFlagsOverride();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ClearFlags":
            retval.ClearFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.Flag>(ref reader, options);
            break;
        case "ClearInterruptFlags":
            retval.ClearInterruptFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.InterruptFlag>(ref reader, options);
            break;
        case "PreferredSpeed":
            retval.PreferredSpeed = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.Speed>(ref reader, options);
            break;
        case "SetFlags":
            retval.SetFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.Flag>(ref reader, options);
            break;
        case "SetInterruptFlags":
            retval.SetInterruptFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Package.InterruptFlag>(ref reader, options);
            break;
        case "Unknown":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageIdlesGetter_Converter : JsonConverter<IPackageIdlesGetter>
{
  public override IPackageIdlesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageIdlesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageIdles");
    if (value.Animations != default)
    {
      writer.WritePropertyName("Animations");
      writer.WriteStartArray();
      foreach (var itm in value.Animations)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Animations");
    }
    writer.WritePropertyName("TimerSetting");
    JsonSerializer.Serialize(writer, value.TimerSetting, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class PackageIdles_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageIdles>
{
  private IPackageIdlesGetter_Converter _getterConverter;
  public PackageIdles_Converter(IPackageIdlesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageIdles value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageIdlesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageIdles Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageIdles();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Animations":
            ConverterHelpers.ReadFormLinkList<IIdleAnimationGetter>(retval.Animations, ref reader);
            break;
        case "TimerSetting":
            retval.TimerSetting = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageIdles.Types>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageRootGetter_Converter : JsonConverter<IPackageRootGetter>
{
  public override IPackageRootGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageRootGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageRoot");
    writer.WritePropertyName("BranchCount");
    JsonSerializer.Serialize(writer, value.BranchCount, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WriteEndObject();
  }
}
public class PackageRoot_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageRoot>
{
  private IPackageRootGetter_Converter _getterConverter;
  public PackageRoot_Converter(IPackageRootGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageRoot value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageRootGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageRoot Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageRoot();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BranchCount":
            retval.BranchCount = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PackageRoot.Flag>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageScriptFragmentsGetter_Converter : JsonConverter<IPackageScriptFragmentsGetter>
{
  public override IPackageScriptFragmentsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageScriptFragmentsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageScriptFragments");
    writer.WritePropertyName("FileName");
    JsonSerializer.Serialize(writer, value.FileName, options);
    writer.WritePropertyName("OnBegin");
    JsonSerializer.Serialize(writer, value.OnBegin, options);
    writer.WritePropertyName("OnChange");
    JsonSerializer.Serialize(writer, value.OnChange, options);
    writer.WritePropertyName("OnEnd");
    JsonSerializer.Serialize(writer, value.OnEnd, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class PackageScriptFragments_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageScriptFragments>
{
  private IPackageScriptFragmentsGetter_Converter _getterConverter;
  public PackageScriptFragments_Converter(IPackageScriptFragmentsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageScriptFragments value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageScriptFragmentsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageScriptFragments Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageScriptFragments();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FileName":
            retval.FileName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "OnBegin":
            retval.OnBegin = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptFragment>(ref reader, options);
            break;
        case "OnChange":
            retval.OnChange = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptFragment>(ref reader, options);
            break;
        case "OnEnd":
            retval.OnEnd = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptFragment>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageTargetAliasGetter_Converter : JsonConverter<IPackageTargetAliasGetter>
{
  public override IPackageTargetAliasGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageTargetAliasGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageTargetAlias");
    writer.WritePropertyName("Alias");
    JsonSerializer.Serialize(writer, value.Alias, options);
    writer.WritePropertyName("CountOrDistance");
    JsonSerializer.Serialize(writer, value.CountOrDistance, options);
    writer.WriteEndObject();
  }
}
public class PackageTargetAlias_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageTargetAlias>
{
  private IPackageTargetAliasGetter_Converter _getterConverter;
  public PackageTargetAlias_Converter(IPackageTargetAliasGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageTargetAlias value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageTargetAliasGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageTargetAlias Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageTargetAlias();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Alias":
            retval.Alias = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "CountOrDistance":
            retval.CountOrDistance = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageTargetObjectIDGetter_Converter : JsonConverter<IPackageTargetObjectIDGetter>
{
  public override IPackageTargetObjectIDGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageTargetObjectIDGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageTargetObjectID");
    writer.WritePropertyName("CountOrDistance");
    JsonSerializer.Serialize(writer, value.CountOrDistance, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WriteEndObject();
  }
}
public class PackageTargetObjectID_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageTargetObjectID>
{
  private IPackageTargetObjectIDGetter_Converter _getterConverter;
  public PackageTargetObjectID_Converter(IPackageTargetObjectIDGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageTargetObjectID value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageTargetObjectIDGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageTargetObjectID Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageTargetObjectID();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CountOrDistance":
            retval.CountOrDistance = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<IObjectIdGetter>(retval.Reference, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageTargetObjectTypeGetter_Converter : JsonConverter<IPackageTargetObjectTypeGetter>
{
  public override IPackageTargetObjectTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageTargetObjectTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageTargetObjectType");
    writer.WritePropertyName("CountOrDistance");
    JsonSerializer.Serialize(writer, value.CountOrDistance, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class PackageTargetObjectType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageTargetObjectType>
{
  private IPackageTargetObjectTypeGetter_Converter _getterConverter;
  public PackageTargetObjectType_Converter(IPackageTargetObjectTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageTargetObjectType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageTargetObjectTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageTargetObjectType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageTargetObjectType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CountOrDistance":
            retval.CountOrDistance = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.TargetObjectType>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageTargetReferenceGetter_Converter : JsonConverter<IPackageTargetReferenceGetter>
{
  public override IPackageTargetReferenceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageTargetReferenceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageTargetReference");
    writer.WritePropertyName("CountOrDistance");
    JsonSerializer.Serialize(writer, value.CountOrDistance, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WriteEndObject();
  }
}
public class PackageTargetReference_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageTargetReference>
{
  private IPackageTargetReferenceGetter_Converter _getterConverter;
  public PackageTargetReference_Converter(IPackageTargetReferenceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageTargetReference value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageTargetReferenceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageTargetReference Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageTargetReference();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CountOrDistance":
            retval.CountOrDistance = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.Reference, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageTargetSelfGetter_Converter : JsonConverter<IPackageTargetSelfGetter>
{
  public override IPackageTargetSelfGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageTargetSelfGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageTargetSelf");
    writer.WritePropertyName("CountOrDistance");
    JsonSerializer.Serialize(writer, value.CountOrDistance, options);
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WriteEndObject();
  }
}
public class PackageTargetSelf_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageTargetSelf>
{
  private IPackageTargetSelfGetter_Converter _getterConverter;
  public PackageTargetSelf_Converter(IPackageTargetSelfGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageTargetSelf value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageTargetSelfGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageTargetSelf Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageTargetSelf();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CountOrDistance":
            retval.CountOrDistance = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Data":
            retval.Data = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageTargetSpecificReferenceGetter_Converter : JsonConverter<IPackageTargetSpecificReferenceGetter>
{
  public override IPackageTargetSpecificReferenceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageTargetSpecificReferenceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageTargetSpecificReference");
    writer.WritePropertyName("CountOrDistance");
    JsonSerializer.Serialize(writer, value.CountOrDistance, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WriteEndObject();
  }
}
public class PackageTargetSpecificReference_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageTargetSpecificReference>
{
  private IPackageTargetSpecificReferenceGetter_Converter _getterConverter;
  public PackageTargetSpecificReference_Converter(IPackageTargetSpecificReferenceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageTargetSpecificReference value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageTargetSpecificReferenceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageTargetSpecificReference Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageTargetSpecificReference();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CountOrDistance":
            retval.CountOrDistance = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<ILinkedReferenceGetter>(retval.Reference, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPackageTargetUnknownGetter_Converter : JsonConverter<IPackageTargetUnknownGetter>
{
  public override IPackageTargetUnknownGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPackageTargetUnknownGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PackageTargetUnknown");
    writer.WritePropertyName("CountOrDistance");
    JsonSerializer.Serialize(writer, value.CountOrDistance, options);
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WriteEndObject();
  }
}
public class PackageTargetUnknown_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PackageTargetUnknown>
{
  private IPackageTargetUnknownGetter_Converter _getterConverter;
  public PackageTargetUnknown_Converter(IPackageTargetUnknownGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PackageTargetUnknown value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPackageTargetUnknownGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PackageTargetUnknown Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PackageTargetUnknown();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CountOrDistance":
            retval.CountOrDistance = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Data":
            retval.Data = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPartGetter_Converter : JsonConverter<IPartGetter>
{
  public override IPartGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPartGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Part");
    writer.WritePropertyName("FileName");
    JsonSerializer.Serialize(writer, value.FileName, options);
    writer.WritePropertyName("PartType");
    JsonSerializer.Serialize(writer, value.PartType, options);
    writer.WriteEndObject();
  }
}
public class Part_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Part>
{
  private IPartGetter_Converter _getterConverter;
  public Part_Converter(IPartGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Part value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPartGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Part Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Part();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FileName":
            retval.FileName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "PartType":
            retval.PartType = JsonSerializer.Deserialize<PartTypeEnum?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPatrolGetter_Converter : JsonConverter<IPatrolGetter>
{
  public override IPatrolGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPatrolGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Patrol");
    writer.WritePropertyName("Idle");
    JsonSerializer.Serialize(writer, value.Idle, options);
    writer.WritePropertyName("IdleTime");
    JsonSerializer.Serialize(writer, value.IdleTime, options);
    writer.WritePropertyName("SCHR");
    JsonSerializer.Serialize(writer, value.SCHR, options);
    writer.WritePropertyName("SCTX");
    JsonSerializer.Serialize(writer, value.SCTX, options);
    if (value.Topics != default)
    {
      writer.WritePropertyName("Topics");
      writer.WriteStartArray();
      foreach (var itm in value.Topics)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Topics");
    }
    writer.WriteEndObject();
  }
}
public class Patrol_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Patrol>
{
  private IPatrolGetter_Converter _getterConverter;
  public Patrol_Converter(IPatrolGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Patrol value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPatrolGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Patrol Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Patrol();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Idle":
            ConverterHelpers.ReadFormLink<IIdleAnimationGetter>(retval.Idle, ref reader);
            break;
        case "IdleTime":
            retval.IdleTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SCHR":
            break;
        case "SCTX":
            break;
        case "Topics":
            ConverterHelpers.ReadExtendedList<ATopicReference>(retval.Topics, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPcLevelMultGetter_Converter : JsonConverter<IPcLevelMultGetter>
{
  public override IPcLevelMultGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPcLevelMultGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PcLevelMult");
    writer.WritePropertyName("LevelMult");
    JsonSerializer.Serialize(writer, value.LevelMult, options);
    writer.WriteEndObject();
  }
}
public class PcLevelMult_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PcLevelMult>
{
  private IPcLevelMultGetter_Converter _getterConverter;
  public PcLevelMult_Converter(IPcLevelMultGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PcLevelMult value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPcLevelMultGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PcLevelMult Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PcLevelMult();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "LevelMult":
            retval.LevelMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkGetter_Converter : JsonConverter<IPerkGetter>
{
  public override IPerkGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Perk");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.Effects != default)
    {
      writer.WritePropertyName("Effects");
      writer.WriteStartArray();
      foreach (var itm in value.Effects)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Effects");
    }
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Hidden");
    JsonSerializer.Serialize(writer, value.Hidden, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("Level");
    JsonSerializer.Serialize(writer, value.Level, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("NextPerk");
    JsonSerializer.Serialize(writer, value.NextPerk, options);
    writer.WritePropertyName("NumRanks");
    JsonSerializer.Serialize(writer, value.NumRanks, options);
    writer.WritePropertyName("Playable");
    JsonSerializer.Serialize(writer, value.Playable, options);
    writer.WritePropertyName("Trait");
    JsonSerializer.Serialize(writer, value.Trait, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class Perk_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Perk>
{
  private IPerkGetter_Converter _getterConverter;
  public Perk_Converter(IPerkGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Perk value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Perk Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Perk();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Perk.DATADataType>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Effects":
            ConverterHelpers.ReadExtendedList<APerkEffect>(retval.Effects, ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Hidden":
            retval.Hidden = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Level":
            retval.Level = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Perk.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "NextPerk":
            ConverterHelpers.ReadFormLinkNullable<IPerkGetter>(retval.NextPerk, ref reader);
            break;
        case "NumRanks":
            retval.NumRanks = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Playable":
            retval.Playable = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Trait":
            retval.Trait = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PerkAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkAbilityEffectGetter_Converter : JsonConverter<IPerkAbilityEffectGetter>
{
  public override IPerkAbilityEffectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkAbilityEffectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkAbilityEffect");
    writer.WritePropertyName("Ability");
    JsonSerializer.Serialize(writer, value.Ability, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WriteEndObject();
  }
}
public class PerkAbilityEffect_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkAbilityEffect>
{
  private IPerkAbilityEffectGetter_Converter _getterConverter;
  public PerkAbilityEffect_Converter(IPerkAbilityEffectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkAbilityEffect value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkAbilityEffectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkAbilityEffect Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkAbilityEffect();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Ability":
            ConverterHelpers.ReadFormLink<ISpellGetter>(retval.Ability, ref reader);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkAdapterGetter_Converter : JsonConverter<IPerkAdapterGetter>
{
  public override IPerkAdapterGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkAdapterGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkAdapter");
    writer.WritePropertyName("ObjectFormat");
    JsonSerializer.Serialize(writer, value.ObjectFormat, options);
    writer.WritePropertyName("ScriptFragments");
    JsonSerializer.Serialize(writer, value.ScriptFragments, options);
    if (value.Scripts != default)
    {
      writer.WritePropertyName("Scripts");
      writer.WriteStartArray();
      foreach (var itm in value.Scripts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Scripts");
    }
    writer.WritePropertyName("Version");
    JsonSerializer.Serialize(writer, value.Version, options);
    writer.WriteEndObject();
  }
}
public class PerkAdapter_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkAdapter>
{
  private IPerkAdapterGetter_Converter _getterConverter;
  public PerkAdapter_Converter(IPerkAdapterGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkAdapter value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkAdapterGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkAdapter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkAdapter();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ObjectFormat":
            retval.ObjectFormat = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "ScriptFragments":
            retval.ScriptFragments = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PerkScriptFragments>(ref reader, options);
            break;
        case "Scripts":
            ConverterHelpers.ReadExtendedList<ScriptEntry>(retval.Scripts, ref reader, options);
            break;
        case "Version":
            retval.Version = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkConditionGetter_Converter : JsonConverter<IPerkConditionGetter>
{
  public override IPerkConditionGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkConditionGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkCondition");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("RunOnTabIndex");
    JsonSerializer.Serialize(writer, value.RunOnTabIndex, options);
    writer.WriteEndObject();
  }
}
public class PerkCondition_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkCondition>
{
  private IPerkConditionGetter_Converter _getterConverter;
  public PerkCondition_Converter(IPerkConditionGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkCondition value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkConditionGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkCondition Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkCondition();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "RunOnTabIndex":
            retval.RunOnTabIndex = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkEntryPointAbsoluteValueGetter_Converter : JsonConverter<IPerkEntryPointAbsoluteValueGetter>
{
  public override IPerkEntryPointAbsoluteValueGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkEntryPointAbsoluteValueGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkEntryPointAbsoluteValue");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EntryPoint");
    JsonSerializer.Serialize(writer, value.EntryPoint, options);
    writer.WritePropertyName("Negative");
    JsonSerializer.Serialize(writer, value.Negative, options);
    writer.WritePropertyName("PerkConditionTabCount");
    JsonSerializer.Serialize(writer, value.PerkConditionTabCount, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WriteEndObject();
  }
}
public class PerkEntryPointAbsoluteValue_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkEntryPointAbsoluteValue>
{
  private IPerkEntryPointAbsoluteValueGetter_Converter _getterConverter;
  public PerkEntryPointAbsoluteValue_Converter(IPerkEntryPointAbsoluteValueGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkEntryPointAbsoluteValue value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkEntryPointAbsoluteValueGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkEntryPointAbsoluteValue Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkEntryPointAbsoluteValue();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "EntryPoint":
            retval.EntryPoint = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEntryPointEffect.EntryType>(ref reader, options);
            break;
        case "Negative":
            retval.Negative = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "PerkConditionTabCount":
            retval.PerkConditionTabCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkEntryPointAddActivateChoiceGetter_Converter : JsonConverter<IPerkEntryPointAddActivateChoiceGetter>
{
  public override IPerkEntryPointAddActivateChoiceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkEntryPointAddActivateChoiceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkEntryPointAddActivateChoice");
    writer.WritePropertyName("ButtonLabel");
    JsonSerializer.Serialize(writer, value.ButtonLabel, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EntryPoint");
    JsonSerializer.Serialize(writer, value.EntryPoint, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("PerkConditionTabCount");
    JsonSerializer.Serialize(writer, value.PerkConditionTabCount, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WritePropertyName("Spell");
    JsonSerializer.Serialize(writer, value.Spell, options);
    writer.WriteEndObject();
  }
}
public class PerkEntryPointAddActivateChoice_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkEntryPointAddActivateChoice>
{
  private IPerkEntryPointAddActivateChoiceGetter_Converter _getterConverter;
  public PerkEntryPointAddActivateChoice_Converter(IPerkEntryPointAddActivateChoiceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkEntryPointAddActivateChoice value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkEntryPointAddActivateChoiceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkEntryPointAddActivateChoice Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkEntryPointAddActivateChoice();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ButtonLabel":
            retval.ButtonLabel = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "EntryPoint":
            retval.EntryPoint = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEntryPointEffect.EntryType>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PerkScriptFlag>(ref reader, options);
            break;
        case "PerkConditionTabCount":
            retval.PerkConditionTabCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Spell":
            ConverterHelpers.ReadFormLinkNullable<ISpellGetter>(retval.Spell, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkEntryPointAddLeveledItemGetter_Converter : JsonConverter<IPerkEntryPointAddLeveledItemGetter>
{
  public override IPerkEntryPointAddLeveledItemGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkEntryPointAddLeveledItemGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkEntryPointAddLeveledItem");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EntryPoint");
    JsonSerializer.Serialize(writer, value.EntryPoint, options);
    writer.WritePropertyName("PerkConditionTabCount");
    JsonSerializer.Serialize(writer, value.PerkConditionTabCount, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WriteEndObject();
  }
}
public class PerkEntryPointAddLeveledItem_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkEntryPointAddLeveledItem>
{
  private IPerkEntryPointAddLeveledItemGetter_Converter _getterConverter;
  public PerkEntryPointAddLeveledItem_Converter(IPerkEntryPointAddLeveledItemGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkEntryPointAddLeveledItem value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkEntryPointAddLeveledItemGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkEntryPointAddLeveledItem Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkEntryPointAddLeveledItem();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "EntryPoint":
            retval.EntryPoint = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEntryPointEffect.EntryType>(ref reader, options);
            break;
        case "PerkConditionTabCount":
            retval.PerkConditionTabCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkEntryPointAddRangeToValueGetter_Converter : JsonConverter<IPerkEntryPointAddRangeToValueGetter>
{
  public override IPerkEntryPointAddRangeToValueGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkEntryPointAddRangeToValueGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkEntryPointAddRangeToValue");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EntryPoint");
    JsonSerializer.Serialize(writer, value.EntryPoint, options);
    writer.WritePropertyName("From");
    JsonSerializer.Serialize(writer, value.From, options);
    writer.WritePropertyName("PerkConditionTabCount");
    JsonSerializer.Serialize(writer, value.PerkConditionTabCount, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WritePropertyName("To");
    JsonSerializer.Serialize(writer, value.To, options);
    writer.WriteEndObject();
  }
}
public class PerkEntryPointAddRangeToValue_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkEntryPointAddRangeToValue>
{
  private IPerkEntryPointAddRangeToValueGetter_Converter _getterConverter;
  public PerkEntryPointAddRangeToValue_Converter(IPerkEntryPointAddRangeToValueGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkEntryPointAddRangeToValue value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkEntryPointAddRangeToValueGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkEntryPointAddRangeToValue Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkEntryPointAddRangeToValue();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "EntryPoint":
            retval.EntryPoint = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEntryPointEffect.EntryType>(ref reader, options);
            break;
        case "From":
            retval.From = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "PerkConditionTabCount":
            retval.PerkConditionTabCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "To":
            retval.To = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkEntryPointModifyActorValueGetter_Converter : JsonConverter<IPerkEntryPointModifyActorValueGetter>
{
  public override IPerkEntryPointModifyActorValueGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkEntryPointModifyActorValueGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkEntryPointModifyActorValue");
    writer.WritePropertyName("ActorValue");
    JsonSerializer.Serialize(writer, value.ActorValue, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EntryPoint");
    JsonSerializer.Serialize(writer, value.EntryPoint, options);
    writer.WritePropertyName("Modification");
    JsonSerializer.Serialize(writer, value.Modification, options);
    writer.WritePropertyName("PerkConditionTabCount");
    JsonSerializer.Serialize(writer, value.PerkConditionTabCount, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WriteEndObject();
  }
}
public class PerkEntryPointModifyActorValue_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkEntryPointModifyActorValue>
{
  private IPerkEntryPointModifyActorValueGetter_Converter _getterConverter;
  public PerkEntryPointModifyActorValue_Converter(IPerkEntryPointModifyActorValueGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkEntryPointModifyActorValue value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkEntryPointModifyActorValueGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkEntryPointModifyActorValue Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkEntryPointModifyActorValue();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorValue":
            retval.ActorValue = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "EntryPoint":
            retval.EntryPoint = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEntryPointEffect.EntryType>(ref reader, options);
            break;
        case "Modification":
            retval.Modification = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PerkEntryPointModifyActorValue.ModificationType>(ref reader, options);
            break;
        case "PerkConditionTabCount":
            retval.PerkConditionTabCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkEntryPointModifyValueGetter_Converter : JsonConverter<IPerkEntryPointModifyValueGetter>
{
  public override IPerkEntryPointModifyValueGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkEntryPointModifyValueGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkEntryPointModifyValue");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EntryPoint");
    JsonSerializer.Serialize(writer, value.EntryPoint, options);
    writer.WritePropertyName("Modification");
    JsonSerializer.Serialize(writer, value.Modification, options);
    writer.WritePropertyName("PerkConditionTabCount");
    JsonSerializer.Serialize(writer, value.PerkConditionTabCount, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WriteEndObject();
  }
}
public class PerkEntryPointModifyValue_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkEntryPointModifyValue>
{
  private IPerkEntryPointModifyValueGetter_Converter _getterConverter;
  public PerkEntryPointModifyValue_Converter(IPerkEntryPointModifyValueGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkEntryPointModifyValue value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkEntryPointModifyValueGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkEntryPointModifyValue Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkEntryPointModifyValue();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "EntryPoint":
            retval.EntryPoint = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEntryPointEffect.EntryType>(ref reader, options);
            break;
        case "Modification":
            retval.Modification = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PerkEntryPointModifyValue.ModificationType>(ref reader, options);
            break;
        case "PerkConditionTabCount":
            retval.PerkConditionTabCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkEntryPointSelectSpellGetter_Converter : JsonConverter<IPerkEntryPointSelectSpellGetter>
{
  public override IPerkEntryPointSelectSpellGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkEntryPointSelectSpellGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkEntryPointSelectSpell");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EntryPoint");
    JsonSerializer.Serialize(writer, value.EntryPoint, options);
    writer.WritePropertyName("PerkConditionTabCount");
    JsonSerializer.Serialize(writer, value.PerkConditionTabCount, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WritePropertyName("Spell");
    JsonSerializer.Serialize(writer, value.Spell, options);
    writer.WriteEndObject();
  }
}
public class PerkEntryPointSelectSpell_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkEntryPointSelectSpell>
{
  private IPerkEntryPointSelectSpellGetter_Converter _getterConverter;
  public PerkEntryPointSelectSpell_Converter(IPerkEntryPointSelectSpellGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkEntryPointSelectSpell value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkEntryPointSelectSpellGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkEntryPointSelectSpell Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkEntryPointSelectSpell();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "EntryPoint":
            retval.EntryPoint = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEntryPointEffect.EntryType>(ref reader, options);
            break;
        case "PerkConditionTabCount":
            retval.PerkConditionTabCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Spell":
            ConverterHelpers.ReadFormLink<ISpellGetter>(retval.Spell, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkEntryPointSelectTextGetter_Converter : JsonConverter<IPerkEntryPointSelectTextGetter>
{
  public override IPerkEntryPointSelectTextGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkEntryPointSelectTextGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkEntryPointSelectText");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EntryPoint");
    JsonSerializer.Serialize(writer, value.EntryPoint, options);
    writer.WritePropertyName("PerkConditionTabCount");
    JsonSerializer.Serialize(writer, value.PerkConditionTabCount, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WritePropertyName("Text");
    JsonSerializer.Serialize(writer, value.Text, options);
    writer.WriteEndObject();
  }
}
public class PerkEntryPointSelectText_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkEntryPointSelectText>
{
  private IPerkEntryPointSelectTextGetter_Converter _getterConverter;
  public PerkEntryPointSelectText_Converter(IPerkEntryPointSelectTextGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkEntryPointSelectText value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkEntryPointSelectTextGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkEntryPointSelectText Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkEntryPointSelectText();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "EntryPoint":
            retval.EntryPoint = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEntryPointEffect.EntryType>(ref reader, options);
            break;
        case "PerkConditionTabCount":
            retval.PerkConditionTabCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Text":
            retval.Text = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkEntryPointSetTextGetter_Converter : JsonConverter<IPerkEntryPointSetTextGetter>
{
  public override IPerkEntryPointSetTextGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkEntryPointSetTextGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkEntryPointSetText");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EntryPoint");
    JsonSerializer.Serialize(writer, value.EntryPoint, options);
    writer.WritePropertyName("PerkConditionTabCount");
    JsonSerializer.Serialize(writer, value.PerkConditionTabCount, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WritePropertyName("Text");
    JsonSerializer.Serialize(writer, value.Text, options);
    writer.WriteEndObject();
  }
}
public class PerkEntryPointSetText_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkEntryPointSetText>
{
  private IPerkEntryPointSetTextGetter_Converter _getterConverter;
  public PerkEntryPointSetText_Converter(IPerkEntryPointSetTextGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkEntryPointSetText value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkEntryPointSetTextGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkEntryPointSetText Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkEntryPointSetText();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "EntryPoint":
            retval.EntryPoint = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEntryPointEffect.EntryType>(ref reader, options);
            break;
        case "PerkConditionTabCount":
            retval.PerkConditionTabCount = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Text":
            retval.Text = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkPlacementGetter_Converter : JsonConverter<IPerkPlacementGetter>
{
  public override IPerkPlacementGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkPlacementGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkPlacement");
    writer.WritePropertyName("Fluff");
    JsonSerializer.Serialize(writer, value.Fluff, options);
    writer.WritePropertyName("Perk");
    JsonSerializer.Serialize(writer, value.Perk, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WriteEndObject();
  }
}
public class PerkPlacement_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkPlacement>
{
  private IPerkPlacementGetter_Converter _getterConverter;
  public PerkPlacement_Converter(IPerkPlacementGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkPlacement value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkPlacementGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkPlacement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkPlacement();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Fluff":
            break;
        case "Perk":
            ConverterHelpers.ReadFormLink<IPerkGetter>(retval.Perk, ref reader);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkQuestEffectGetter_Converter : JsonConverter<IPerkQuestEffectGetter>
{
  public override IPerkQuestEffectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkQuestEffectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkQuestEffect");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("PRKEDataTypeState");
    JsonSerializer.Serialize(writer, value.PRKEDataTypeState, options);
    writer.WritePropertyName("Quest");
    JsonSerializer.Serialize(writer, value.Quest, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WritePropertyName("Stage");
    JsonSerializer.Serialize(writer, value.Stage, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class PerkQuestEffect_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkQuestEffect>
{
  private IPerkQuestEffectGetter_Converter _getterConverter;
  public PerkQuestEffect_Converter(IPerkQuestEffectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkQuestEffect value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkQuestEffectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkQuestEffect Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkQuestEffect();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<PerkCondition>(retval.Conditions, ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "PRKEDataTypeState":
            retval.PRKEDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APerkEffect.PRKEDataType>(ref reader, options);
            break;
        case "Quest":
            ConverterHelpers.ReadFormLink<IQuestGetter>(retval.Quest, ref reader);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Stage":
            retval.Stage = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Unknown":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkScriptFlagGetter_Converter : JsonConverter<IPerkScriptFlagGetter>
{
  public override IPerkScriptFlagGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkScriptFlagGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkScriptFlag");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FragmentIndex");
    JsonSerializer.Serialize(writer, value.FragmentIndex, options);
    writer.WriteEndObject();
  }
}
public class PerkScriptFlag_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkScriptFlag>
{
  private IPerkScriptFlagGetter_Converter _getterConverter;
  public PerkScriptFlag_Converter(IPerkScriptFlagGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkScriptFlag value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkScriptFlagGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkScriptFlag Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkScriptFlag();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PerkScriptFlag.Flag>(ref reader, options);
            break;
        case "FragmentIndex":
            retval.FragmentIndex = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPerkScriptFragmentsGetter_Converter : JsonConverter<IPerkScriptFragmentsGetter>
{
  public override IPerkScriptFragmentsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPerkScriptFragmentsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PerkScriptFragments");
    writer.WritePropertyName("FileName");
    JsonSerializer.Serialize(writer, value.FileName, options);
    if (value.Fragments != default)
    {
      writer.WritePropertyName("Fragments");
      writer.WriteStartArray();
      foreach (var itm in value.Fragments)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Fragments");
    }
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class PerkScriptFragments_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PerkScriptFragments>
{
  private IPerkScriptFragmentsGetter_Converter _getterConverter;
  public PerkScriptFragments_Converter(IPerkScriptFragmentsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PerkScriptFragments value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPerkScriptFragmentsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PerkScriptFragments Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PerkScriptFragments();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FileName":
            retval.FileName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Fragments":
            ConverterHelpers.ReadExtendedList<IndexedScriptFragment>(retval.Fragments, ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPhonemeGetter_Converter : JsonConverter<IPhonemeGetter>
{
  public override IPhonemeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPhonemeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Phoneme");
    writer.WritePropertyName("AA");
    JsonSerializer.Serialize(writer, value.AA, options);
    writer.WritePropertyName("AE");
    JsonSerializer.Serialize(writer, value.AE, options);
    writer.WritePropertyName("AH");
    JsonSerializer.Serialize(writer, value.AH, options);
    writer.WritePropertyName("AO");
    JsonSerializer.Serialize(writer, value.AO, options);
    writer.WritePropertyName("AW");
    JsonSerializer.Serialize(writer, value.AW, options);
    writer.WritePropertyName("AX");
    JsonSerializer.Serialize(writer, value.AX, options);
    writer.WritePropertyName("AY");
    JsonSerializer.Serialize(writer, value.AY, options);
    writer.WritePropertyName("B");
    JsonSerializer.Serialize(writer, value.B, options);
    writer.WritePropertyName("CH");
    JsonSerializer.Serialize(writer, value.CH, options);
    writer.WritePropertyName("D");
    JsonSerializer.Serialize(writer, value.D, options);
    writer.WritePropertyName("DH");
    JsonSerializer.Serialize(writer, value.DH, options);
    writer.WritePropertyName("EH");
    JsonSerializer.Serialize(writer, value.EH, options);
    writer.WritePropertyName("ER");
    JsonSerializer.Serialize(writer, value.ER, options);
    writer.WritePropertyName("EY");
    JsonSerializer.Serialize(writer, value.EY, options);
    writer.WritePropertyName("F");
    JsonSerializer.Serialize(writer, value.F, options);
    writer.WritePropertyName("FLAP");
    JsonSerializer.Serialize(writer, value.FLAP, options);
    writer.WritePropertyName("G");
    JsonSerializer.Serialize(writer, value.G, options);
    writer.WritePropertyName("HH");
    JsonSerializer.Serialize(writer, value.HH, options);
    writer.WritePropertyName("IH");
    JsonSerializer.Serialize(writer, value.IH, options);
    writer.WritePropertyName("IY");
    JsonSerializer.Serialize(writer, value.IY, options);
    writer.WritePropertyName("JH");
    JsonSerializer.Serialize(writer, value.JH, options);
    writer.WritePropertyName("K");
    JsonSerializer.Serialize(writer, value.K, options);
    writer.WritePropertyName("L");
    JsonSerializer.Serialize(writer, value.L, options);
    writer.WritePropertyName("M");
    JsonSerializer.Serialize(writer, value.M, options);
    writer.WritePropertyName("N");
    JsonSerializer.Serialize(writer, value.N, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("NG");
    JsonSerializer.Serialize(writer, value.NG, options);
    writer.WritePropertyName("OW");
    JsonSerializer.Serialize(writer, value.OW, options);
    writer.WritePropertyName("OY");
    JsonSerializer.Serialize(writer, value.OY, options);
    writer.WritePropertyName("P");
    JsonSerializer.Serialize(writer, value.P, options);
    writer.WritePropertyName("R");
    JsonSerializer.Serialize(writer, value.R, options);
    writer.WritePropertyName("S");
    JsonSerializer.Serialize(writer, value.S, options);
    writer.WritePropertyName("SH");
    JsonSerializer.Serialize(writer, value.SH, options);
    writer.WritePropertyName("SHOTSIL");
    JsonSerializer.Serialize(writer, value.SHOTSIL, options);
    writer.WritePropertyName("SIL");
    JsonSerializer.Serialize(writer, value.SIL, options);
    writer.WritePropertyName("T");
    JsonSerializer.Serialize(writer, value.T, options);
    writer.WritePropertyName("TH");
    JsonSerializer.Serialize(writer, value.TH, options);
    writer.WritePropertyName("UH");
    JsonSerializer.Serialize(writer, value.UH, options);
    writer.WritePropertyName("UW");
    JsonSerializer.Serialize(writer, value.UW, options);
    writer.WritePropertyName("V");
    JsonSerializer.Serialize(writer, value.V, options);
    writer.WritePropertyName("W");
    JsonSerializer.Serialize(writer, value.W, options);
    writer.WritePropertyName("Y");
    JsonSerializer.Serialize(writer, value.Y, options);
    writer.WritePropertyName("Z");
    JsonSerializer.Serialize(writer, value.Z, options);
    writer.WritePropertyName("ZH");
    JsonSerializer.Serialize(writer, value.ZH, options);
    writer.WriteEndObject();
  }
}
public class Phoneme_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Phoneme>
{
  private IPhonemeGetter_Converter _getterConverter;
  public Phoneme_Converter(IPhonemeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Phoneme value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPhonemeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Phoneme Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Phoneme();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AA":
            retval.AA = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AE":
            retval.AE = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AH":
            retval.AH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AO":
            retval.AO = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AW":
            retval.AW = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AX":
            retval.AX = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AY":
            retval.AY = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "B":
            retval.B = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CH":
            retval.CH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "D":
            retval.D = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DH":
            retval.DH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EH":
            retval.EH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ER":
            retval.ER = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "EY":
            retval.EY = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "F":
            retval.F = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FLAP":
            retval.FLAP = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "G":
            retval.G = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "HH":
            retval.HH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "IH":
            retval.IH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "IY":
            retval.IY = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "JH":
            retval.JH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "K":
            retval.K = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "L":
            retval.L = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "M":
            retval.M = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "N":
            retval.N = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "NG":
            retval.NG = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "OW":
            retval.OW = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "OY":
            retval.OY = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "P":
            retval.P = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "R":
            retval.R = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "S":
            retval.S = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SH":
            retval.SH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SHOTSIL":
            retval.SHOTSIL = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SIL":
            retval.SIL = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "T":
            retval.T = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "TH":
            retval.TH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "UH":
            retval.UH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "UW":
            retval.UW = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "V":
            retval.V = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "W":
            retval.W = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Y":
            retval.Y = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Z":
            retval.Z = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ZH":
            retval.ZH = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedArrowGetter_Converter : JsonConverter<IPlacedArrowGetter>
{
  public override IPlacedArrowGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedArrowGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedArrow");
    writer.WritePropertyName("ActivateParents");
    JsonSerializer.Serialize(writer, value.ActivateParents, options);
    if (value.DistantLodData != default)
    {
      writer.WritePropertyName("DistantLodData");
      writer.WriteStartArray();
      foreach (var itm in value.DistantLodData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DistantLodData");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Emittance");
    JsonSerializer.Serialize(writer, value.Emittance, options);
    writer.WritePropertyName("EnableParent");
    JsonSerializer.Serialize(writer, value.EnableParent, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FavorCost");
    JsonSerializer.Serialize(writer, value.FavorCost, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HeadTrackingWeight");
    JsonSerializer.Serialize(writer, value.HeadTrackingWeight, options);
    writer.WritePropertyName("IgnoredBySandbox");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.LinkedReferences != default)
    {
      writer.WritePropertyName("LinkedReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedReferences");
    }
    writer.WritePropertyName("LocationReference");
    JsonSerializer.Serialize(writer, value.LocationReference, options);
    if (value.LocationRefTypes != default)
    {
      writer.WritePropertyName("LocationRefTypes");
      writer.WriteStartArray();
      foreach (var itm in value.LocationRefTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationRefTypes");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MultiBoundReference");
    JsonSerializer.Serialize(writer, value.MultiBoundReference, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    writer.WritePropertyName("Placement");
    JsonSerializer.Serialize(writer, value.Placement, options);
    writer.WritePropertyName("Projectile");
    JsonSerializer.Serialize(writer, value.Projectile, options);
    if (value.Reflections != default)
    {
      writer.WritePropertyName("Reflections");
      writer.WriteStartArray();
      foreach (var itm in value.Reflections)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Reflections");
    }
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class PlacedArrow_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedArrow>
{
  private IPlacedArrowGetter_Converter _getterConverter;
  public PlacedArrow_Converter(IPlacedArrowGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedArrow value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedArrowGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedArrow Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedArrow();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateParents":
            retval.ActivateParents = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents>(ref reader, options);
            break;
        case "DistantLodData":
            ConverterHelpers.ReadExtendedList<Single>(retval.DistantLodData, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emittance":
            ConverterHelpers.ReadFormLinkNullable<IEmittanceGetter>(retval.Emittance, ref reader);
            break;
        case "EnableParent":
            retval.EnableParent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FavorCost":
            retval.FavorCost = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HeadTrackingWeight":
            retval.HeadTrackingWeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IgnoredBySandbox":
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LinkedReferences":
            ConverterHelpers.ReadExtendedList<LinkedReferences>(retval.LinkedReferences, ref reader, options);
            break;
        case "LocationReference":
            ConverterHelpers.ReadFormLinkNullable<ILocationRecordGetter>(retval.LocationReference, ref reader);
            break;
        case "LocationRefTypes":
            ConverterHelpers.ReadFormLinkList<ILocationReferenceTypeGetter>(retval.LocationRefTypes, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APlacedTrap.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MultiBoundReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MultiBoundReference, ref reader);
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Placement":
            retval.Placement = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Placement>(ref reader, options);
            break;
        case "Projectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.Projectile, ref reader);
            break;
        case "Reflections":
            ConverterHelpers.ReadExtendedList<WaterReflection>(retval.Reflections, ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedBarrierGetter_Converter : JsonConverter<IPlacedBarrierGetter>
{
  public override IPlacedBarrierGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedBarrierGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedBarrier");
    writer.WritePropertyName("ActivateParents");
    JsonSerializer.Serialize(writer, value.ActivateParents, options);
    if (value.DistantLodData != default)
    {
      writer.WritePropertyName("DistantLodData");
      writer.WriteStartArray();
      foreach (var itm in value.DistantLodData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DistantLodData");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Emittance");
    JsonSerializer.Serialize(writer, value.Emittance, options);
    writer.WritePropertyName("EnableParent");
    JsonSerializer.Serialize(writer, value.EnableParent, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FavorCost");
    JsonSerializer.Serialize(writer, value.FavorCost, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HeadTrackingWeight");
    JsonSerializer.Serialize(writer, value.HeadTrackingWeight, options);
    writer.WritePropertyName("IgnoredBySandbox");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.LinkedReferences != default)
    {
      writer.WritePropertyName("LinkedReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedReferences");
    }
    writer.WritePropertyName("LocationReference");
    JsonSerializer.Serialize(writer, value.LocationReference, options);
    if (value.LocationRefTypes != default)
    {
      writer.WritePropertyName("LocationRefTypes");
      writer.WriteStartArray();
      foreach (var itm in value.LocationRefTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationRefTypes");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MultiBoundReference");
    JsonSerializer.Serialize(writer, value.MultiBoundReference, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    writer.WritePropertyName("Placement");
    JsonSerializer.Serialize(writer, value.Placement, options);
    writer.WritePropertyName("Projectile");
    JsonSerializer.Serialize(writer, value.Projectile, options);
    if (value.Reflections != default)
    {
      writer.WritePropertyName("Reflections");
      writer.WriteStartArray();
      foreach (var itm in value.Reflections)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Reflections");
    }
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class PlacedBarrier_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedBarrier>
{
  private IPlacedBarrierGetter_Converter _getterConverter;
  public PlacedBarrier_Converter(IPlacedBarrierGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedBarrier value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedBarrierGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedBarrier Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedBarrier();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateParents":
            retval.ActivateParents = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents>(ref reader, options);
            break;
        case "DistantLodData":
            ConverterHelpers.ReadExtendedList<Single>(retval.DistantLodData, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emittance":
            ConverterHelpers.ReadFormLinkNullable<IEmittanceGetter>(retval.Emittance, ref reader);
            break;
        case "EnableParent":
            retval.EnableParent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FavorCost":
            retval.FavorCost = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HeadTrackingWeight":
            retval.HeadTrackingWeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IgnoredBySandbox":
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LinkedReferences":
            ConverterHelpers.ReadExtendedList<LinkedReferences>(retval.LinkedReferences, ref reader, options);
            break;
        case "LocationReference":
            ConverterHelpers.ReadFormLinkNullable<ILocationRecordGetter>(retval.LocationReference, ref reader);
            break;
        case "LocationRefTypes":
            ConverterHelpers.ReadFormLinkList<ILocationReferenceTypeGetter>(retval.LocationRefTypes, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APlacedTrap.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MultiBoundReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MultiBoundReference, ref reader);
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Placement":
            retval.Placement = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Placement>(ref reader, options);
            break;
        case "Projectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.Projectile, ref reader);
            break;
        case "Reflections":
            ConverterHelpers.ReadExtendedList<WaterReflection>(retval.Reflections, ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedBeamGetter_Converter : JsonConverter<IPlacedBeamGetter>
{
  public override IPlacedBeamGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedBeamGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedBeam");
    writer.WritePropertyName("ActivateParents");
    JsonSerializer.Serialize(writer, value.ActivateParents, options);
    if (value.DistantLodData != default)
    {
      writer.WritePropertyName("DistantLodData");
      writer.WriteStartArray();
      foreach (var itm in value.DistantLodData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DistantLodData");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Emittance");
    JsonSerializer.Serialize(writer, value.Emittance, options);
    writer.WritePropertyName("EnableParent");
    JsonSerializer.Serialize(writer, value.EnableParent, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FavorCost");
    JsonSerializer.Serialize(writer, value.FavorCost, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HeadTrackingWeight");
    JsonSerializer.Serialize(writer, value.HeadTrackingWeight, options);
    writer.WritePropertyName("IgnoredBySandbox");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.LinkedReferences != default)
    {
      writer.WritePropertyName("LinkedReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedReferences");
    }
    writer.WritePropertyName("LocationReference");
    JsonSerializer.Serialize(writer, value.LocationReference, options);
    if (value.LocationRefTypes != default)
    {
      writer.WritePropertyName("LocationRefTypes");
      writer.WriteStartArray();
      foreach (var itm in value.LocationRefTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationRefTypes");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MultiBoundReference");
    JsonSerializer.Serialize(writer, value.MultiBoundReference, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    writer.WritePropertyName("Placement");
    JsonSerializer.Serialize(writer, value.Placement, options);
    writer.WritePropertyName("Projectile");
    JsonSerializer.Serialize(writer, value.Projectile, options);
    if (value.Reflections != default)
    {
      writer.WritePropertyName("Reflections");
      writer.WriteStartArray();
      foreach (var itm in value.Reflections)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Reflections");
    }
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class PlacedBeam_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedBeam>
{
  private IPlacedBeamGetter_Converter _getterConverter;
  public PlacedBeam_Converter(IPlacedBeamGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedBeam value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedBeamGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedBeam Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedBeam();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateParents":
            retval.ActivateParents = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents>(ref reader, options);
            break;
        case "DistantLodData":
            ConverterHelpers.ReadExtendedList<Single>(retval.DistantLodData, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emittance":
            ConverterHelpers.ReadFormLinkNullable<IEmittanceGetter>(retval.Emittance, ref reader);
            break;
        case "EnableParent":
            retval.EnableParent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FavorCost":
            retval.FavorCost = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HeadTrackingWeight":
            retval.HeadTrackingWeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IgnoredBySandbox":
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LinkedReferences":
            ConverterHelpers.ReadExtendedList<LinkedReferences>(retval.LinkedReferences, ref reader, options);
            break;
        case "LocationReference":
            ConverterHelpers.ReadFormLinkNullable<ILocationRecordGetter>(retval.LocationReference, ref reader);
            break;
        case "LocationRefTypes":
            ConverterHelpers.ReadFormLinkList<ILocationReferenceTypeGetter>(retval.LocationRefTypes, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APlacedTrap.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MultiBoundReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MultiBoundReference, ref reader);
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Placement":
            retval.Placement = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Placement>(ref reader, options);
            break;
        case "Projectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.Projectile, ref reader);
            break;
        case "Reflections":
            ConverterHelpers.ReadExtendedList<WaterReflection>(retval.Reflections, ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedConeGetter_Converter : JsonConverter<IPlacedConeGetter>
{
  public override IPlacedConeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedConeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedCone");
    writer.WritePropertyName("ActivateParents");
    JsonSerializer.Serialize(writer, value.ActivateParents, options);
    if (value.DistantLodData != default)
    {
      writer.WritePropertyName("DistantLodData");
      writer.WriteStartArray();
      foreach (var itm in value.DistantLodData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DistantLodData");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Emittance");
    JsonSerializer.Serialize(writer, value.Emittance, options);
    writer.WritePropertyName("EnableParent");
    JsonSerializer.Serialize(writer, value.EnableParent, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FavorCost");
    JsonSerializer.Serialize(writer, value.FavorCost, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HeadTrackingWeight");
    JsonSerializer.Serialize(writer, value.HeadTrackingWeight, options);
    writer.WritePropertyName("IgnoredBySandbox");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.LinkedReferences != default)
    {
      writer.WritePropertyName("LinkedReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedReferences");
    }
    writer.WritePropertyName("LocationReference");
    JsonSerializer.Serialize(writer, value.LocationReference, options);
    if (value.LocationRefTypes != default)
    {
      writer.WritePropertyName("LocationRefTypes");
      writer.WriteStartArray();
      foreach (var itm in value.LocationRefTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationRefTypes");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MultiBoundReference");
    JsonSerializer.Serialize(writer, value.MultiBoundReference, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    writer.WritePropertyName("Placement");
    JsonSerializer.Serialize(writer, value.Placement, options);
    writer.WritePropertyName("Projectile");
    JsonSerializer.Serialize(writer, value.Projectile, options);
    if (value.Reflections != default)
    {
      writer.WritePropertyName("Reflections");
      writer.WriteStartArray();
      foreach (var itm in value.Reflections)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Reflections");
    }
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class PlacedCone_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedCone>
{
  private IPlacedConeGetter_Converter _getterConverter;
  public PlacedCone_Converter(IPlacedConeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedCone value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedConeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedCone Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedCone();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateParents":
            retval.ActivateParents = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents>(ref reader, options);
            break;
        case "DistantLodData":
            ConverterHelpers.ReadExtendedList<Single>(retval.DistantLodData, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emittance":
            ConverterHelpers.ReadFormLinkNullable<IEmittanceGetter>(retval.Emittance, ref reader);
            break;
        case "EnableParent":
            retval.EnableParent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FavorCost":
            retval.FavorCost = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HeadTrackingWeight":
            retval.HeadTrackingWeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IgnoredBySandbox":
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LinkedReferences":
            ConverterHelpers.ReadExtendedList<LinkedReferences>(retval.LinkedReferences, ref reader, options);
            break;
        case "LocationReference":
            ConverterHelpers.ReadFormLinkNullable<ILocationRecordGetter>(retval.LocationReference, ref reader);
            break;
        case "LocationRefTypes":
            ConverterHelpers.ReadFormLinkList<ILocationReferenceTypeGetter>(retval.LocationRefTypes, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APlacedTrap.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MultiBoundReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MultiBoundReference, ref reader);
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Placement":
            retval.Placement = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Placement>(ref reader, options);
            break;
        case "Projectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.Projectile, ref reader);
            break;
        case "Reflections":
            ConverterHelpers.ReadExtendedList<WaterReflection>(retval.Reflections, ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedFlameGetter_Converter : JsonConverter<IPlacedFlameGetter>
{
  public override IPlacedFlameGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedFlameGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedFlame");
    writer.WritePropertyName("ActivateParents");
    JsonSerializer.Serialize(writer, value.ActivateParents, options);
    if (value.DistantLodData != default)
    {
      writer.WritePropertyName("DistantLodData");
      writer.WriteStartArray();
      foreach (var itm in value.DistantLodData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DistantLodData");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Emittance");
    JsonSerializer.Serialize(writer, value.Emittance, options);
    writer.WritePropertyName("EnableParent");
    JsonSerializer.Serialize(writer, value.EnableParent, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FavorCost");
    JsonSerializer.Serialize(writer, value.FavorCost, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HeadTrackingWeight");
    JsonSerializer.Serialize(writer, value.HeadTrackingWeight, options);
    writer.WritePropertyName("IgnoredBySandbox");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.LinkedReferences != default)
    {
      writer.WritePropertyName("LinkedReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedReferences");
    }
    writer.WritePropertyName("LocationReference");
    JsonSerializer.Serialize(writer, value.LocationReference, options);
    if (value.LocationRefTypes != default)
    {
      writer.WritePropertyName("LocationRefTypes");
      writer.WriteStartArray();
      foreach (var itm in value.LocationRefTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationRefTypes");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MultiBoundReference");
    JsonSerializer.Serialize(writer, value.MultiBoundReference, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    writer.WritePropertyName("Placement");
    JsonSerializer.Serialize(writer, value.Placement, options);
    writer.WritePropertyName("Projectile");
    JsonSerializer.Serialize(writer, value.Projectile, options);
    if (value.Reflections != default)
    {
      writer.WritePropertyName("Reflections");
      writer.WriteStartArray();
      foreach (var itm in value.Reflections)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Reflections");
    }
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class PlacedFlame_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedFlame>
{
  private IPlacedFlameGetter_Converter _getterConverter;
  public PlacedFlame_Converter(IPlacedFlameGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedFlame value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedFlameGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedFlame Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedFlame();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateParents":
            retval.ActivateParents = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents>(ref reader, options);
            break;
        case "DistantLodData":
            ConverterHelpers.ReadExtendedList<Single>(retval.DistantLodData, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emittance":
            ConverterHelpers.ReadFormLinkNullable<IEmittanceGetter>(retval.Emittance, ref reader);
            break;
        case "EnableParent":
            retval.EnableParent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FavorCost":
            retval.FavorCost = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HeadTrackingWeight":
            retval.HeadTrackingWeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IgnoredBySandbox":
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LinkedReferences":
            ConverterHelpers.ReadExtendedList<LinkedReferences>(retval.LinkedReferences, ref reader, options);
            break;
        case "LocationReference":
            ConverterHelpers.ReadFormLinkNullable<ILocationRecordGetter>(retval.LocationReference, ref reader);
            break;
        case "LocationRefTypes":
            ConverterHelpers.ReadFormLinkList<ILocationReferenceTypeGetter>(retval.LocationRefTypes, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APlacedTrap.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MultiBoundReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MultiBoundReference, ref reader);
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Placement":
            retval.Placement = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Placement>(ref reader, options);
            break;
        case "Projectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.Projectile, ref reader);
            break;
        case "Reflections":
            ConverterHelpers.ReadExtendedList<WaterReflection>(retval.Reflections, ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedHazardGetter_Converter : JsonConverter<IPlacedHazardGetter>
{
  public override IPlacedHazardGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedHazardGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedHazard");
    writer.WritePropertyName("ActivateParents");
    JsonSerializer.Serialize(writer, value.ActivateParents, options);
    if (value.DistantLodData != default)
    {
      writer.WritePropertyName("DistantLodData");
      writer.WriteStartArray();
      foreach (var itm in value.DistantLodData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DistantLodData");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Emittance");
    JsonSerializer.Serialize(writer, value.Emittance, options);
    writer.WritePropertyName("EnableParent");
    JsonSerializer.Serialize(writer, value.EnableParent, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FavorCost");
    JsonSerializer.Serialize(writer, value.FavorCost, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Hazard");
    JsonSerializer.Serialize(writer, value.Hazard, options);
    writer.WritePropertyName("HeadTrackingWeight");
    JsonSerializer.Serialize(writer, value.HeadTrackingWeight, options);
    writer.WritePropertyName("IgnoredBySandbox");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.LinkedReferences != default)
    {
      writer.WritePropertyName("LinkedReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedReferences");
    }
    writer.WritePropertyName("LocationReference");
    JsonSerializer.Serialize(writer, value.LocationReference, options);
    if (value.LocationRefTypes != default)
    {
      writer.WritePropertyName("LocationRefTypes");
      writer.WriteStartArray();
      foreach (var itm in value.LocationRefTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationRefTypes");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MultiBoundReference");
    JsonSerializer.Serialize(writer, value.MultiBoundReference, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    writer.WritePropertyName("Placement");
    JsonSerializer.Serialize(writer, value.Placement, options);
    if (value.Reflections != default)
    {
      writer.WritePropertyName("Reflections");
      writer.WriteStartArray();
      foreach (var itm in value.Reflections)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Reflections");
    }
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class PlacedHazard_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedHazard>
{
  private IPlacedHazardGetter_Converter _getterConverter;
  public PlacedHazard_Converter(IPlacedHazardGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedHazard value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedHazardGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedHazard Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedHazard();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateParents":
            retval.ActivateParents = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents>(ref reader, options);
            break;
        case "DistantLodData":
            ConverterHelpers.ReadExtendedList<Single>(retval.DistantLodData, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emittance":
            ConverterHelpers.ReadFormLinkNullable<IEmittanceGetter>(retval.Emittance, ref reader);
            break;
        case "EnableParent":
            retval.EnableParent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FavorCost":
            retval.FavorCost = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Hazard":
            ConverterHelpers.ReadFormLink<IHazardGetter>(retval.Hazard, ref reader);
            break;
        case "HeadTrackingWeight":
            retval.HeadTrackingWeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IgnoredBySandbox":
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LinkedReferences":
            ConverterHelpers.ReadExtendedList<LinkedReferences>(retval.LinkedReferences, ref reader, options);
            break;
        case "LocationReference":
            ConverterHelpers.ReadFormLinkNullable<ILocationRecordGetter>(retval.LocationReference, ref reader);
            break;
        case "LocationRefTypes":
            ConverterHelpers.ReadFormLinkList<ILocationReferenceTypeGetter>(retval.LocationRefTypes, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APlacedTrap.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MultiBoundReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MultiBoundReference, ref reader);
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Placement":
            retval.Placement = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Placement>(ref reader, options);
            break;
        case "Reflections":
            ConverterHelpers.ReadExtendedList<WaterReflection>(retval.Reflections, ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedMissileGetter_Converter : JsonConverter<IPlacedMissileGetter>
{
  public override IPlacedMissileGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedMissileGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedMissile");
    writer.WritePropertyName("ActivateParents");
    JsonSerializer.Serialize(writer, value.ActivateParents, options);
    if (value.DistantLodData != default)
    {
      writer.WritePropertyName("DistantLodData");
      writer.WriteStartArray();
      foreach (var itm in value.DistantLodData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DistantLodData");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Emittance");
    JsonSerializer.Serialize(writer, value.Emittance, options);
    writer.WritePropertyName("EnableParent");
    JsonSerializer.Serialize(writer, value.EnableParent, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FavorCost");
    JsonSerializer.Serialize(writer, value.FavorCost, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HeadTrackingWeight");
    JsonSerializer.Serialize(writer, value.HeadTrackingWeight, options);
    writer.WritePropertyName("IgnoredBySandbox");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.LinkedReferences != default)
    {
      writer.WritePropertyName("LinkedReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedReferences");
    }
    writer.WritePropertyName("LocationReference");
    JsonSerializer.Serialize(writer, value.LocationReference, options);
    if (value.LocationRefTypes != default)
    {
      writer.WritePropertyName("LocationRefTypes");
      writer.WriteStartArray();
      foreach (var itm in value.LocationRefTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationRefTypes");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MultiBoundReference");
    JsonSerializer.Serialize(writer, value.MultiBoundReference, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    writer.WritePropertyName("Placement");
    JsonSerializer.Serialize(writer, value.Placement, options);
    writer.WritePropertyName("Projectile");
    JsonSerializer.Serialize(writer, value.Projectile, options);
    if (value.Reflections != default)
    {
      writer.WritePropertyName("Reflections");
      writer.WriteStartArray();
      foreach (var itm in value.Reflections)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Reflections");
    }
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class PlacedMissile_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedMissile>
{
  private IPlacedMissileGetter_Converter _getterConverter;
  public PlacedMissile_Converter(IPlacedMissileGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedMissile value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedMissileGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedMissile Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedMissile();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateParents":
            retval.ActivateParents = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents>(ref reader, options);
            break;
        case "DistantLodData":
            ConverterHelpers.ReadExtendedList<Single>(retval.DistantLodData, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emittance":
            ConverterHelpers.ReadFormLinkNullable<IEmittanceGetter>(retval.Emittance, ref reader);
            break;
        case "EnableParent":
            retval.EnableParent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FavorCost":
            retval.FavorCost = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HeadTrackingWeight":
            retval.HeadTrackingWeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IgnoredBySandbox":
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LinkedReferences":
            ConverterHelpers.ReadExtendedList<LinkedReferences>(retval.LinkedReferences, ref reader, options);
            break;
        case "LocationReference":
            ConverterHelpers.ReadFormLinkNullable<ILocationRecordGetter>(retval.LocationReference, ref reader);
            break;
        case "LocationRefTypes":
            ConverterHelpers.ReadFormLinkList<ILocationReferenceTypeGetter>(retval.LocationRefTypes, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APlacedTrap.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MultiBoundReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MultiBoundReference, ref reader);
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Placement":
            retval.Placement = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Placement>(ref reader, options);
            break;
        case "Projectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.Projectile, ref reader);
            break;
        case "Reflections":
            ConverterHelpers.ReadExtendedList<WaterReflection>(retval.Reflections, ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedNpcGetter_Converter : JsonConverter<IPlacedNpcGetter>
{
  public override IPlacedNpcGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedNpcGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedNpc");
    writer.WritePropertyName("ActivateParents");
    JsonSerializer.Serialize(writer, value.ActivateParents, options);
    writer.WritePropertyName("Base");
    JsonSerializer.Serialize(writer, value.Base, options);
    writer.WritePropertyName("Count");
    JsonSerializer.Serialize(writer, value.Count, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Emittance");
    JsonSerializer.Serialize(writer, value.Emittance, options);
    writer.WritePropertyName("EnableParent");
    JsonSerializer.Serialize(writer, value.EnableParent, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FavorCost");
    JsonSerializer.Serialize(writer, value.FavorCost, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HeadTrackingWeight");
    JsonSerializer.Serialize(writer, value.HeadTrackingWeight, options);
    writer.WritePropertyName("Health");
    JsonSerializer.Serialize(writer, value.Health, options);
    writer.WritePropertyName("Horse");
    JsonSerializer.Serialize(writer, value.Horse, options);
    writer.WritePropertyName("IgnoredBySandbox");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox, options);
    writer.WritePropertyName("IgnoredBySandbox2");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox2, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LevelModifier");
    JsonSerializer.Serialize(writer, value.LevelModifier, options);
    writer.WritePropertyName("LinkedReferenceColor");
    JsonSerializer.Serialize(writer, value.LinkedReferenceColor, options);
    if (value.LinkedReferences != default)
    {
      writer.WritePropertyName("LinkedReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedReferences");
    }
    writer.WritePropertyName("LocationReference");
    JsonSerializer.Serialize(writer, value.LocationReference, options);
    if (value.LocationRefTypes != default)
    {
      writer.WritePropertyName("LocationRefTypes");
      writer.WriteStartArray();
      foreach (var itm in value.LocationRefTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationRefTypes");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MerchantContainer");
    JsonSerializer.Serialize(writer, value.MerchantContainer, options);
    writer.WritePropertyName("MultiboundReference");
    JsonSerializer.Serialize(writer, value.MultiboundReference, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    writer.WritePropertyName("Patrol");
    JsonSerializer.Serialize(writer, value.Patrol, options);
    writer.WritePropertyName("PersistentLocation");
    JsonSerializer.Serialize(writer, value.PersistentLocation, options);
    writer.WritePropertyName("Placement");
    JsonSerializer.Serialize(writer, value.Placement, options);
    writer.WritePropertyName("Radius");
    JsonSerializer.Serialize(writer, value.Radius, options);
    writer.WritePropertyName("RagdollBipedData");
    JsonSerializer.Serialize(writer, value.RagdollBipedData, options);
    writer.WritePropertyName("RagdollData");
    JsonSerializer.Serialize(writer, value.RagdollData, options);
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class PlacedNpc_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedNpc>
{
  private IPlacedNpcGetter_Converter _getterConverter;
  public PlacedNpc_Converter(IPlacedNpcGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedNpc value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedNpcGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedNpc Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedNpc();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateParents":
            retval.ActivateParents = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents>(ref reader, options);
            break;
        case "Base":
            ConverterHelpers.ReadFormLinkNullable<INpcGetter>(retval.Base, ref reader);
            break;
        case "Count":
            retval.Count = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emittance":
            ConverterHelpers.ReadFormLinkNullable<IEmittanceGetter>(retval.Emittance, ref reader);
            break;
        case "EnableParent":
            retval.EnableParent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FavorCost":
            retval.FavorCost = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HeadTrackingWeight":
            retval.HeadTrackingWeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Health":
            retval.Health = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Horse":
            ConverterHelpers.ReadFormLinkNullable<IPlacedNpcGetter>(retval.Horse, ref reader);
            break;
        case "IgnoredBySandbox":
            retval.IgnoredBySandbox = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IgnoredBySandbox2":
            retval.IgnoredBySandbox2 = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LevelModifier":
            retval.LevelModifier = JsonSerializer.Deserialize<Level?>(ref reader, options);
            break;
        case "LinkedReferenceColor":
            retval.LinkedReferenceColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LinkedReferenceColor>(ref reader, options);
            break;
        case "LinkedReferences":
            ConverterHelpers.ReadExtendedList<LinkedReferences>(retval.LinkedReferences, ref reader, options);
            break;
        case "LocationReference":
            ConverterHelpers.ReadFormLinkNullable<ILocationRecordGetter>(retval.LocationReference, ref reader);
            break;
        case "LocationRefTypes":
            ConverterHelpers.ReadFormLinkList<ILocationReferenceTypeGetter>(retval.LocationRefTypes, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PlacedNpc.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MerchantContainer":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MerchantContainer, ref reader);
            break;
        case "MultiboundReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MultiboundReference, ref reader);
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Patrol":
            retval.Patrol = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Patrol>(ref reader, options);
            break;
        case "PersistentLocation":
            ConverterHelpers.ReadFormLinkNullable<ILocationGetter>(retval.PersistentLocation, ref reader);
            break;
        case "Placement":
            retval.Placement = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Placement>(ref reader, options);
            break;
        case "Radius":
            retval.Radius = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "RagdollBipedData":
            break;
        case "RagdollData":
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedObjectGetter_Converter : JsonConverter<IPlacedObjectGetter>
{
  public override IPlacedObjectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedObjectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedObject");
    writer.WritePropertyName("Action");
    JsonSerializer.Serialize(writer, value.Action, options);
    writer.WritePropertyName("ActivateParents");
    JsonSerializer.Serialize(writer, value.ActivateParents, options);
    writer.WritePropertyName("Alpha");
    JsonSerializer.Serialize(writer, value.Alpha, options);
    writer.WritePropertyName("AttachRef");
    JsonSerializer.Serialize(writer, value.AttachRef, options);
    writer.WritePropertyName("Base");
    JsonSerializer.Serialize(writer, value.Base, options);
    writer.WritePropertyName("BoundHalfExtents");
    JsonSerializer.Serialize(writer, value.BoundHalfExtents, options);
    writer.WritePropertyName("Charge");
    JsonSerializer.Serialize(writer, value.Charge, options);
    writer.WritePropertyName("CollisionLayer");
    JsonSerializer.Serialize(writer, value.CollisionLayer, options);
    writer.WritePropertyName("DistantLodData");
    JsonSerializer.Serialize(writer, value.DistantLodData, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Emittance");
    JsonSerializer.Serialize(writer, value.Emittance, options);
    writer.WritePropertyName("EnableParent");
    JsonSerializer.Serialize(writer, value.EnableParent, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FavorCost");
    JsonSerializer.Serialize(writer, value.FavorCost, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HeadTrackingWeight");
    JsonSerializer.Serialize(writer, value.HeadTrackingWeight, options);
    writer.WritePropertyName("IgnoredBySandbox");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox, options);
    writer.WritePropertyName("ImageSpace");
    JsonSerializer.Serialize(writer, value.ImageSpace, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("ItemCount");
    JsonSerializer.Serialize(writer, value.ItemCount, options);
    writer.WritePropertyName("LeveledItemBaseObject");
    JsonSerializer.Serialize(writer, value.LeveledItemBaseObject, options);
    writer.WritePropertyName("LevelModifier");
    JsonSerializer.Serialize(writer, value.LevelModifier, options);
    writer.WritePropertyName("LightData");
    JsonSerializer.Serialize(writer, value.LightData, options);
    writer.WritePropertyName("LightingTemplate");
    JsonSerializer.Serialize(writer, value.LightingTemplate, options);
    if (value.LinkedReferences != default)
    {
      writer.WritePropertyName("LinkedReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedReferences");
    }
    if (value.LinkedRooms != default)
    {
      writer.WritePropertyName("LinkedRooms");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedRooms)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedRooms");
    }
    if (value.LitWater != default)
    {
      writer.WritePropertyName("LitWater");
      writer.WriteStartArray();
      foreach (var itm in value.LitWater)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LitWater");
    }
    writer.WritePropertyName("LocationReference");
    JsonSerializer.Serialize(writer, value.LocationReference, options);
    if (value.LocationRefTypes != default)
    {
      writer.WritePropertyName("LocationRefTypes");
      writer.WriteStartArray();
      foreach (var itm in value.LocationRefTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationRefTypes");
    }
    writer.WritePropertyName("Lock");
    JsonSerializer.Serialize(writer, value.Lock, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MapMarker");
    JsonSerializer.Serialize(writer, value.MapMarker, options);
    writer.WritePropertyName("MultiBoundPrimitive");
    JsonSerializer.Serialize(writer, value.MultiBoundPrimitive, options);
    writer.WritePropertyName("MultiboundReference");
    JsonSerializer.Serialize(writer, value.MultiboundReference, options);
    writer.WritePropertyName("NavigationDoorLink");
    JsonSerializer.Serialize(writer, value.NavigationDoorLink, options);
    writer.WritePropertyName("OcclusionPlane");
    JsonSerializer.Serialize(writer, value.OcclusionPlane, options);
    writer.WritePropertyName("OpenByDefault");
    JsonSerializer.Serialize(writer, value.OpenByDefault, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    writer.WritePropertyName("Patrol");
    JsonSerializer.Serialize(writer, value.Patrol, options);
    writer.WritePropertyName("PersistentLocation");
    JsonSerializer.Serialize(writer, value.PersistentLocation, options);
    writer.WritePropertyName("Placement");
    JsonSerializer.Serialize(writer, value.Placement, options);
    if (value.Portals != default)
    {
      writer.WritePropertyName("Portals");
      writer.WriteStartArray();
      foreach (var itm in value.Portals)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Portals");
    }
    writer.WritePropertyName("Primitive");
    JsonSerializer.Serialize(writer, value.Primitive, options);
    writer.WritePropertyName("Radius");
    JsonSerializer.Serialize(writer, value.Radius, options);
    writer.WritePropertyName("RagdollBipedData");
    JsonSerializer.Serialize(writer, value.RagdollBipedData, options);
    writer.WritePropertyName("RagdollData");
    JsonSerializer.Serialize(writer, value.RagdollData, options);
    if (value.Reflections != default)
    {
      writer.WritePropertyName("Reflections");
      writer.WriteStartArray();
      foreach (var itm in value.Reflections)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Reflections");
    }
    writer.WritePropertyName("RoomPortal");
    JsonSerializer.Serialize(writer, value.RoomPortal, options);
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("SpawnContainer");
    JsonSerializer.Serialize(writer, value.SpawnContainer, options);
    writer.WritePropertyName("TeleportDestination");
    JsonSerializer.Serialize(writer, value.TeleportDestination, options);
    writer.WritePropertyName("TeleportMessageBox");
    JsonSerializer.Serialize(writer, value.TeleportMessageBox, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("WaterVelocity");
    JsonSerializer.Serialize(writer, value.WaterVelocity, options);
    writer.WritePropertyName("XCVL");
    JsonSerializer.Serialize(writer, value.XCVL, options);
    writer.WritePropertyName("XCZA");
    JsonSerializer.Serialize(writer, value.XCZA, options);
    writer.WritePropertyName("XCZC");
    JsonSerializer.Serialize(writer, value.XCZC, options);
    writer.WritePropertyName("XCZR");
    JsonSerializer.Serialize(writer, value.XCZR, options);
    writer.WritePropertyName("XORD");
    JsonSerializer.Serialize(writer, value.XORD, options);
    writer.WritePropertyName("XWCN");
    JsonSerializer.Serialize(writer, value.XWCN, options);
    writer.WritePropertyName("XWCS");
    JsonSerializer.Serialize(writer, value.XWCS, options);
    writer.WriteEndObject();
  }
}
public class PlacedObject_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedObject>
{
  private IPlacedObjectGetter_Converter _getterConverter;
  public PlacedObject_Converter(IPlacedObjectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedObject value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedObjectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedObject();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Action":
            retval.Action = JsonSerializer.Deserialize<ActionFlag?>(ref reader, options);
            break;
        case "ActivateParents":
            retval.ActivateParents = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents>(ref reader, options);
            break;
        case "Alpha":
            retval.Alpha = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Alpha>(ref reader, options);
            break;
        case "AttachRef":
            ConverterHelpers.ReadFormLinkNullable<IPlacedThingGetter>(retval.AttachRef, ref reader);
            break;
        case "Base":
            ConverterHelpers.ReadFormLinkNullable<ISkyrimMajorRecordGetter>(retval.Base, ref reader);
            break;
        case "BoundHalfExtents":
            retval.BoundHalfExtents = JsonSerializer.Deserialize<P3Float?>(ref reader, options);
            break;
        case "Charge":
            retval.Charge = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "CollisionLayer":
            retval.CollisionLayer = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "DistantLodData":
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emittance":
            ConverterHelpers.ReadFormLinkNullable<IEmittanceGetter>(retval.Emittance, ref reader);
            break;
        case "EnableParent":
            retval.EnableParent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FavorCost":
            retval.FavorCost = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HeadTrackingWeight":
            retval.HeadTrackingWeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IgnoredBySandbox":
            retval.IgnoredBySandbox = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "ImageSpace":
            ConverterHelpers.ReadFormLinkNullable<IImageSpaceAdapterGetter>(retval.ImageSpace, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "ItemCount":
            retval.ItemCount = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "LeveledItemBaseObject":
            ConverterHelpers.ReadFormLinkNullable<ILeveledItemGetter>(retval.LeveledItemBaseObject, ref reader);
            break;
        case "LevelModifier":
            retval.LevelModifier = JsonSerializer.Deserialize<Level?>(ref reader, options);
            break;
        case "LightData":
            retval.LightData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LightData>(ref reader, options);
            break;
        case "LightingTemplate":
            ConverterHelpers.ReadFormLinkNullable<ILightGetter>(retval.LightingTemplate, ref reader);
            break;
        case "LinkedReferences":
            ConverterHelpers.ReadExtendedList<LinkedReferences>(retval.LinkedReferences, ref reader, options);
            break;
        case "LinkedRooms":
            ConverterHelpers.ReadFormLinkList<IPlacedObjectGetter>(retval.LinkedRooms, ref reader);
            break;
        case "LitWater":
            ConverterHelpers.ReadFormLinkList<IPlacedObjectGetter>(retval.LitWater, ref reader);
            break;
        case "LocationReference":
            ConverterHelpers.ReadFormLinkNullable<ILocationRecordGetter>(retval.LocationReference, ref reader);
            break;
        case "LocationRefTypes":
            ConverterHelpers.ReadFormLinkList<ILocationReferenceTypeGetter>(retval.LocationRefTypes, ref reader);
            break;
        case "Lock":
            retval.Lock = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LockData>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MapMarker":
            retval.MapMarker = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MapMarker>(ref reader, options);
            break;
        case "MultiBoundPrimitive":
            retval.MultiBoundPrimitive = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MultiboundReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MultiboundReference, ref reader);
            break;
        case "NavigationDoorLink":
            retval.NavigationDoorLink = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.NavigationDoorLink>(ref reader, options);
            break;
        case "OcclusionPlane":
            retval.OcclusionPlane = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Bounding>(ref reader, options);
            break;
        case "OpenByDefault":
            retval.OpenByDefault = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Patrol":
            retval.Patrol = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Patrol>(ref reader, options);
            break;
        case "PersistentLocation":
            ConverterHelpers.ReadFormLinkNullable<ILocationGetter>(retval.PersistentLocation, ref reader);
            break;
        case "Placement":
            retval.Placement = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Placement>(ref reader, options);
            break;
        case "Portals":
            ConverterHelpers.ReadExtendedList<Portal>(retval.Portals, ref reader, options);
            break;
        case "Primitive":
            retval.Primitive = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PlacedPrimitive>(ref reader, options);
            break;
        case "Radius":
            retval.Radius = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "RagdollBipedData":
            break;
        case "RagdollData":
            break;
        case "Reflections":
            ConverterHelpers.ReadExtendedList<WaterReflection>(retval.Reflections, ref reader, options);
            break;
        case "RoomPortal":
            retval.RoomPortal = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Bounding>(ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SpawnContainer":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.SpawnContainer, ref reader);
            break;
        case "TeleportDestination":
            retval.TeleportDestination = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.TeleportDestination>(ref reader, options);
            break;
        case "TeleportMessageBox":
            ConverterHelpers.ReadFormLinkNullable<IMessageGetter>(retval.TeleportMessageBox, ref reader);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "WaterVelocity":
            retval.WaterVelocity = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WaterVelocity>(ref reader, options);
            break;
        case "XCVL":
            break;
        case "XCZA":
            break;
        case "XCZC":
            ConverterHelpers.ReadFormLinkNullable<ICellGetter>(retval.XCZC, ref reader);
            break;
        case "XCZR":
            ConverterHelpers.ReadFormLinkNullable<ILinkedReferenceGetter>(retval.XCZR, ref reader);
            break;
        case "XORD":
            break;
        case "XWCN":
            break;
        case "XWCS":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedPrimitiveGetter_Converter : JsonConverter<IPlacedPrimitiveGetter>
{
  public override IPlacedPrimitiveGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedPrimitiveGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedPrimitive");
    writer.WritePropertyName("Bounds");
    JsonSerializer.Serialize(writer, value.Bounds, options);
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class PlacedPrimitive_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedPrimitive>
{
  private IPlacedPrimitiveGetter_Converter _getterConverter;
  public PlacedPrimitive_Converter(IPlacedPrimitiveGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedPrimitive value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedPrimitiveGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedPrimitive Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedPrimitive();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Bounds":
            retval.Bounds = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "Color":
            retval.Color = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.PlacedPrimitive.TypeEnum>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacedTrapGetter_Converter : JsonConverter<IPlacedTrapGetter>
{
  public override IPlacedTrapGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacedTrapGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlacedTrap");
    writer.WritePropertyName("ActivateParents");
    JsonSerializer.Serialize(writer, value.ActivateParents, options);
    if (value.DistantLodData != default)
    {
      writer.WritePropertyName("DistantLodData");
      writer.WriteStartArray();
      foreach (var itm in value.DistantLodData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DistantLodData");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Emittance");
    JsonSerializer.Serialize(writer, value.Emittance, options);
    writer.WritePropertyName("EnableParent");
    JsonSerializer.Serialize(writer, value.EnableParent, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FavorCost");
    JsonSerializer.Serialize(writer, value.FavorCost, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HeadTrackingWeight");
    JsonSerializer.Serialize(writer, value.HeadTrackingWeight, options);
    writer.WritePropertyName("IgnoredBySandbox");
    JsonSerializer.Serialize(writer, value.IgnoredBySandbox, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.LinkedReferences != default)
    {
      writer.WritePropertyName("LinkedReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LinkedReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LinkedReferences");
    }
    writer.WritePropertyName("LocationReference");
    JsonSerializer.Serialize(writer, value.LocationReference, options);
    if (value.LocationRefTypes != default)
    {
      writer.WritePropertyName("LocationRefTypes");
      writer.WriteStartArray();
      foreach (var itm in value.LocationRefTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LocationRefTypes");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MultiBoundReference");
    JsonSerializer.Serialize(writer, value.MultiBoundReference, options);
    writer.WritePropertyName("Ownership");
    JsonSerializer.Serialize(writer, value.Ownership, options);
    writer.WritePropertyName("Placement");
    JsonSerializer.Serialize(writer, value.Placement, options);
    writer.WritePropertyName("Projectile");
    JsonSerializer.Serialize(writer, value.Projectile, options);
    if (value.Reflections != default)
    {
      writer.WritePropertyName("Reflections");
      writer.WriteStartArray();
      foreach (var itm in value.Reflections)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Reflections");
    }
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class PlacedTrap_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlacedTrap>
{
  private IPlacedTrapGetter_Converter _getterConverter;
  public PlacedTrap_Converter(IPlacedTrapGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlacedTrap value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacedTrapGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlacedTrap Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlacedTrap();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActivateParents":
            retval.ActivateParents = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActivateParents>(ref reader, options);
            break;
        case "DistantLodData":
            ConverterHelpers.ReadExtendedList<Single>(retval.DistantLodData, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Emittance":
            ConverterHelpers.ReadFormLinkNullable<IEmittanceGetter>(retval.Emittance, ref reader);
            break;
        case "EnableParent":
            retval.EnableParent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.EnableParent>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FavorCost":
            retval.FavorCost = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HeadTrackingWeight":
            retval.HeadTrackingWeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IgnoredBySandbox":
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LinkedReferences":
            ConverterHelpers.ReadExtendedList<LinkedReferences>(retval.LinkedReferences, ref reader, options);
            break;
        case "LocationReference":
            ConverterHelpers.ReadFormLinkNullable<ILocationRecordGetter>(retval.LocationReference, ref reader);
            break;
        case "LocationRefTypes":
            ConverterHelpers.ReadFormLinkList<ILocationReferenceTypeGetter>(retval.LocationRefTypes, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.APlacedTrap.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MultiBoundReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedObjectGetter>(retval.MultiBoundReference, ref reader);
            break;
        case "Ownership":
            retval.Ownership = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Ownership>(ref reader, options);
            break;
        case "Placement":
            retval.Placement = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Placement>(ref reader, options);
            break;
        case "Projectile":
            ConverterHelpers.ReadFormLink<IProjectileGetter>(retval.Projectile, ref reader);
            break;
        case "Reflections":
            ConverterHelpers.ReadExtendedList<WaterReflection>(retval.Reflections, ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlacementGetter_Converter : JsonConverter<IPlacementGetter>
{
  public override IPlacementGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlacementGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Placement");
    writer.WritePropertyName("Position");
    JsonSerializer.Serialize(writer, value.Position, options);
    writer.WritePropertyName("Rotation");
    JsonSerializer.Serialize(writer, value.Rotation, options);
    writer.WriteEndObject();
  }
}
public class Placement_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Placement>
{
  private IPlacementGetter_Converter _getterConverter;
  public Placement_Converter(IPlacementGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Placement value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlacementGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Placement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Placement();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Position":
            retval.Position = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "Rotation":
            retval.Rotation = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPlayerSkillsGetter_Converter : JsonConverter<IPlayerSkillsGetter>
{
  public override IPlayerSkillsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPlayerSkillsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PlayerSkills");
    writer.WritePropertyName("FarAwayModelDistance");
    JsonSerializer.Serialize(writer, value.FarAwayModelDistance, options);
    writer.WritePropertyName("GearedUpWeapons");
    JsonSerializer.Serialize(writer, value.GearedUpWeapons, options);
    writer.WritePropertyName("Health");
    JsonSerializer.Serialize(writer, value.Health, options);
    writer.WritePropertyName("Magicka");
    JsonSerializer.Serialize(writer, value.Magicka, options);
    writer.WritePropertyName("SkillOffsets");
    JsonSerializer.Serialize(writer, value.SkillOffsets, options);
    writer.WritePropertyName("SkillValues");
    JsonSerializer.Serialize(writer, value.SkillValues, options);
    writer.WritePropertyName("Stamina");
    JsonSerializer.Serialize(writer, value.Stamina, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WritePropertyName("Unused2");
    JsonSerializer.Serialize(writer, value.Unused2, options);
    writer.WriteEndObject();
  }
}
public class PlayerSkills_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PlayerSkills>
{
  private IPlayerSkillsGetter_Converter _getterConverter;
  public PlayerSkills_Converter(IPlayerSkillsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PlayerSkills value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPlayerSkillsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PlayerSkills Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PlayerSkills();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FarAwayModelDistance":
            retval.FarAwayModelDistance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "GearedUpWeapons":
            retval.GearedUpWeapons = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Health":
            retval.Health = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Magicka":
            retval.Magicka = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "SkillOffsets":
            break;
        case "SkillValues":
            break;
        case "Stamina":
            retval.Stamina = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Unused":
            retval.Unused = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Unused2":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPortalGetter_Converter : JsonConverter<IPortalGetter>
{
  public override IPortalGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPortalGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Portal");
    writer.WritePropertyName("Destination");
    JsonSerializer.Serialize(writer, value.Destination, options);
    writer.WritePropertyName("Origin");
    JsonSerializer.Serialize(writer, value.Origin, options);
    writer.WriteEndObject();
  }
}
public class Portal_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Portal>
{
  private IPortalGetter_Converter _getterConverter;
  public Portal_Converter(IPortalGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Portal value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPortalGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Portal Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Portal();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Destination":
            ConverterHelpers.ReadFormLink<IPlacedObjectGetter>(retval.Destination, ref reader);
            break;
        case "Origin":
            ConverterHelpers.ReadFormLink<IPlacedObjectGetter>(retval.Origin, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IPreferredPathingGetter_Converter : JsonConverter<IPreferredPathingGetter>
{
  public override IPreferredPathingGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IPreferredPathingGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "PreferredPathing");
    if (value.NavmeshSets != default)
    {
      writer.WritePropertyName("NavmeshSets");
      writer.WriteStartArray();
      foreach (var itm in value.NavmeshSets)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("NavmeshSets");
    }
    if (value.NavmeshTree != default)
    {
      writer.WritePropertyName("NavmeshTree");
      writer.WriteStartArray();
      foreach (var itm in value.NavmeshTree)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("NavmeshTree");
    }
    writer.WriteEndObject();
  }
}
public class PreferredPathing_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.PreferredPathing>
{
  private IPreferredPathingGetter_Converter _getterConverter;
  public PreferredPathing_Converter(IPreferredPathingGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.PreferredPathing value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IPreferredPathingGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.PreferredPathing Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.PreferredPathing();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "NavmeshSets":
            ConverterHelpers.ReadExtendedList<NavmeshSet>(retval.NavmeshSets, ref reader, options);
            break;
        case "NavmeshTree":
            ConverterHelpers.ReadExtendedList<NavmeshNode>(retval.NavmeshTree, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IProjectileGetter_Converter : JsonConverter<IProjectileGetter>
{
  public override IProjectileGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IProjectileGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Projectile");
    writer.WritePropertyName("CollisionLayer");
    JsonSerializer.Serialize(writer, value.CollisionLayer, options);
    writer.WritePropertyName("CollisionRadius");
    JsonSerializer.Serialize(writer, value.CollisionRadius, options);
    writer.WritePropertyName("ConeSpread");
    JsonSerializer.Serialize(writer, value.ConeSpread, options);
    writer.WritePropertyName("CountdownSound");
    JsonSerializer.Serialize(writer, value.CountdownSound, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("DecalData");
    JsonSerializer.Serialize(writer, value.DecalData, options);
    writer.WritePropertyName("DefaultWeaponSource");
    JsonSerializer.Serialize(writer, value.DefaultWeaponSource, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("DisaleSound");
    JsonSerializer.Serialize(writer, value.DisaleSound, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Explosion");
    JsonSerializer.Serialize(writer, value.Explosion, options);
    writer.WritePropertyName("ExplosionAltTriggerProximity");
    JsonSerializer.Serialize(writer, value.ExplosionAltTriggerProximity, options);
    writer.WritePropertyName("ExplosionAltTriggerTimer");
    JsonSerializer.Serialize(writer, value.ExplosionAltTriggerTimer, options);
    writer.WritePropertyName("FadeDuration");
    JsonSerializer.Serialize(writer, value.FadeDuration, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Gravity");
    JsonSerializer.Serialize(writer, value.Gravity, options);
    writer.WritePropertyName("ImpactForce");
    JsonSerializer.Serialize(writer, value.ImpactForce, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("Lifetime");
    JsonSerializer.Serialize(writer, value.Lifetime, options);
    writer.WritePropertyName("Light");
    JsonSerializer.Serialize(writer, value.Light, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("MuzzleFlash");
    JsonSerializer.Serialize(writer, value.MuzzleFlash, options);
    writer.WritePropertyName("MuzzleFlashDuration");
    JsonSerializer.Serialize(writer, value.MuzzleFlashDuration, options);
    writer.WritePropertyName("MuzzleFlashModel");
    JsonSerializer.Serialize(writer, value.MuzzleFlashModel, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Range");
    JsonSerializer.Serialize(writer, value.Range, options);
    writer.WritePropertyName("RelaunchInterval");
    JsonSerializer.Serialize(writer, value.RelaunchInterval, options);
    writer.WritePropertyName("Sound");
    JsonSerializer.Serialize(writer, value.Sound, options);
    writer.WritePropertyName("SoundLevel");
    JsonSerializer.Serialize(writer, value.SoundLevel, options);
    writer.WritePropertyName("Speed");
    JsonSerializer.Serialize(writer, value.Speed, options);
    writer.WritePropertyName("TextureFilesHashes");
    JsonSerializer.Serialize(writer, value.TextureFilesHashes, options);
    writer.WritePropertyName("TracerChance");
    JsonSerializer.Serialize(writer, value.TracerChance, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Projectile_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Projectile>
{
  private IProjectileGetter_Converter _getterConverter;
  public Projectile_Converter(IProjectileGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Projectile value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IProjectileGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Projectile Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Projectile();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CollisionLayer":
            ConverterHelpers.ReadFormLink<ICollisionLayerGetter>(retval.CollisionLayer, ref reader);
            break;
        case "CollisionRadius":
            retval.CollisionRadius = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ConeSpread":
            retval.ConeSpread = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CountdownSound":
            ConverterHelpers.ReadFormLink<ISoundDescriptorGetter>(retval.CountdownSound, ref reader);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Projectile.DATADataType>(ref reader, options);
            break;
        case "DecalData":
            ConverterHelpers.ReadFormLink<ITextureSetGetter>(retval.DecalData, ref reader);
            break;
        case "DefaultWeaponSource":
            ConverterHelpers.ReadFormLink<IWeaponGetter>(retval.DefaultWeaponSource, ref reader);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "DisaleSound":
            ConverterHelpers.ReadFormLink<ISoundDescriptorGetter>(retval.DisaleSound, ref reader);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Explosion":
            ConverterHelpers.ReadFormLink<IExplosionGetter>(retval.Explosion, ref reader);
            break;
        case "ExplosionAltTriggerProximity":
            retval.ExplosionAltTriggerProximity = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ExplosionAltTriggerTimer":
            retval.ExplosionAltTriggerTimer = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FadeDuration":
            retval.FadeDuration = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Projectile.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Gravity":
            retval.Gravity = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ImpactForce":
            retval.ImpactForce = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Lifetime":
            retval.Lifetime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Light":
            ConverterHelpers.ReadFormLink<ILightGetter>(retval.Light, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "MuzzleFlash":
            ConverterHelpers.ReadFormLink<ILightGetter>(retval.MuzzleFlash, ref reader);
            break;
        case "MuzzleFlashDuration":
            retval.MuzzleFlashDuration = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MuzzleFlashModel":
            retval.MuzzleFlashModel = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "Range":
            retval.Range = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RelaunchInterval":
            retval.RelaunchInterval = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Sound":
            ConverterHelpers.ReadFormLink<ISoundDescriptorGetter>(retval.Sound, ref reader);
            break;
        case "SoundLevel":
            retval.SoundLevel = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Speed":
            retval.Speed = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "TextureFilesHashes":
            break;
        case "TracerChance":
            retval.TracerChance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Projectile.TypeEnum>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IQuestGetter_Converter : JsonConverter<IQuestGetter>
{
  public override IQuestGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IQuestGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Quest");
    if (value.Aliases != default)
    {
      writer.WritePropertyName("Aliases");
      writer.WriteStartArray();
      foreach (var itm in value.Aliases)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Aliases");
    }
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    if (value.DialogConditions != default)
    {
      writer.WritePropertyName("DialogConditions");
      writer.WriteStartArray();
      foreach (var itm in value.DialogConditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("DialogConditions");
    }
    writer.WritePropertyName("DNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.DNAMDataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Event");
    JsonSerializer.Serialize(writer, value.Event, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    if (value.Objectives != default)
    {
      writer.WritePropertyName("Objectives");
      writer.WriteStartArray();
      foreach (var itm in value.Objectives)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Objectives");
    }
    writer.WritePropertyName("ObjectWindowFilter");
    JsonSerializer.Serialize(writer, value.ObjectWindowFilter, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WritePropertyName("QuestFormVersion");
    JsonSerializer.Serialize(writer, value.QuestFormVersion, options);
    if (value.Stages != default)
    {
      writer.WritePropertyName("Stages");
      writer.WriteStartArray();
      foreach (var itm in value.Stages)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Stages");
    }
    if (value.TextDisplayGlobals != default)
    {
      writer.WritePropertyName("TextDisplayGlobals");
      writer.WriteStartArray();
      foreach (var itm in value.TextDisplayGlobals)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("TextDisplayGlobals");
    }
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    if (value.UnusedConditions != default)
    {
      writer.WritePropertyName("UnusedConditions");
      writer.WriteStartArray();
      foreach (var itm in value.UnusedConditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("UnusedConditions");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class Quest_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Quest>
{
  private IQuestGetter_Converter _getterConverter;
  public Quest_Converter(IQuestGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Quest value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IQuestGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Quest Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Quest();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Aliases":
            ConverterHelpers.ReadExtendedList<QuestAlias>(retval.Aliases, ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "DialogConditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.DialogConditions, ref reader, options);
            break;
        case "DNAMDataTypeState":
            retval.DNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Quest.DNAMDataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Event":
            retval.Event = JsonSerializer.Deserialize<RecordType?>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Quest.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Objectives":
            ConverterHelpers.ReadExtendedList<QuestObjective>(retval.Objectives, ref reader, options);
            break;
        case "ObjectWindowFilter":
            retval.ObjectWindowFilter = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "QuestFormVersion":
            retval.QuestFormVersion = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Stages":
            ConverterHelpers.ReadExtendedList<QuestStage>(retval.Stages, ref reader, options);
            break;
        case "TextDisplayGlobals":
            ConverterHelpers.ReadFormLinkList<IGlobalGetter>(retval.TextDisplayGlobals, ref reader);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Quest.TypeEnum>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "UnusedConditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.UnusedConditions, ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.QuestAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IQuestAdapterGetter_Converter : JsonConverter<IQuestAdapterGetter>
{
  public override IQuestAdapterGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IQuestAdapterGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "QuestAdapter");
    if (value.Aliases != default)
    {
      writer.WritePropertyName("Aliases");
      writer.WriteStartArray();
      foreach (var itm in value.Aliases)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Aliases");
    }
    writer.WritePropertyName("FileName");
    JsonSerializer.Serialize(writer, value.FileName, options);
    if (value.Fragments != default)
    {
      writer.WritePropertyName("Fragments");
      writer.WriteStartArray();
      foreach (var itm in value.Fragments)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Fragments");
    }
    writer.WritePropertyName("ObjectFormat");
    JsonSerializer.Serialize(writer, value.ObjectFormat, options);
    if (value.Scripts != default)
    {
      writer.WritePropertyName("Scripts");
      writer.WriteStartArray();
      foreach (var itm in value.Scripts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Scripts");
    }
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Version");
    JsonSerializer.Serialize(writer, value.Version, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class QuestAdapter_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.QuestAdapter>
{
  private IQuestAdapterGetter_Converter _getterConverter;
  public QuestAdapter_Converter(IQuestAdapterGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.QuestAdapter value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IQuestAdapterGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.QuestAdapter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.QuestAdapter();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Aliases":
            ConverterHelpers.ReadExtendedList<QuestFragmentAlias>(retval.Aliases, ref reader, options);
            break;
        case "FileName":
            retval.FileName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Fragments":
            ConverterHelpers.ReadExtendedList<QuestScriptFragment>(retval.Fragments, ref reader, options);
            break;
        case "ObjectFormat":
            retval.ObjectFormat = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Scripts":
            ConverterHelpers.ReadExtendedList<ScriptEntry>(retval.Scripts, ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Version":
            retval.Version = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.QuestAdapter.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IQuestAliasGetter_Converter : JsonConverter<IQuestAliasGetter>
{
  public override IQuestAliasGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IQuestAliasGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "QuestAlias");
    writer.WritePropertyName("AliasIndexToForceIntoWhenFilled");
    JsonSerializer.Serialize(writer, value.AliasIndexToForceIntoWhenFilled, options);
    writer.WritePropertyName("CombatOverridePackageList");
    JsonSerializer.Serialize(writer, value.CombatOverridePackageList, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("CreateReferenceToObject");
    JsonSerializer.Serialize(writer, value.CreateReferenceToObject, options);
    writer.WritePropertyName("DisplayName");
    JsonSerializer.Serialize(writer, value.DisplayName, options);
    writer.WritePropertyName("External");
    JsonSerializer.Serialize(writer, value.External, options);
    if (value.Factions != default)
    {
      writer.WritePropertyName("Factions");
      writer.WriteStartArray();
      foreach (var itm in value.Factions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Factions");
    }
    writer.WritePropertyName("FindMatchingRefFromEvent");
    JsonSerializer.Serialize(writer, value.FindMatchingRefFromEvent, options);
    writer.WritePropertyName("FindMatchingRefNearAlias");
    JsonSerializer.Serialize(writer, value.FindMatchingRefNearAlias, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("ForcedReference");
    JsonSerializer.Serialize(writer, value.ForcedReference, options);
    writer.WritePropertyName("GuardWarnOverridePackageList");
    JsonSerializer.Serialize(writer, value.GuardWarnOverridePackageList, options);
    writer.WritePropertyName("ID");
    JsonSerializer.Serialize(writer, value.ID, options);
    if (value.Items != default)
    {
      writer.WritePropertyName("Items");
      writer.WriteStartArray();
      foreach (var itm in value.Items)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Items");
    }
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("Location");
    JsonSerializer.Serialize(writer, value.Location, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObserveDeadBodyOverridePackageList");
    JsonSerializer.Serialize(writer, value.ObserveDeadBodyOverridePackageList, options);
    if (value.PackageData != default)
    {
      writer.WritePropertyName("PackageData");
      writer.WriteStartArray();
      foreach (var itm in value.PackageData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("PackageData");
    }
    writer.WritePropertyName("SpecificLocation");
    JsonSerializer.Serialize(writer, value.SpecificLocation, options);
    writer.WritePropertyName("SpectatorOverridePackageList");
    JsonSerializer.Serialize(writer, value.SpectatorOverridePackageList, options);
    if (value.Spells != default)
    {
      writer.WritePropertyName("Spells");
      writer.WriteStartArray();
      foreach (var itm in value.Spells)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Spells");
    }
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("UniqueActor");
    JsonSerializer.Serialize(writer, value.UniqueActor, options);
    writer.WritePropertyName("VoiceTypes");
    JsonSerializer.Serialize(writer, value.VoiceTypes, options);
    writer.WriteEndObject();
  }
}
public class QuestAlias_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.QuestAlias>
{
  private IQuestAliasGetter_Converter _getterConverter;
  public QuestAlias_Converter(IQuestAliasGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.QuestAlias value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IQuestAliasGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.QuestAlias Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.QuestAlias();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AliasIndexToForceIntoWhenFilled":
            retval.AliasIndexToForceIntoWhenFilled = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "CombatOverridePackageList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.CombatOverridePackageList, ref reader);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "CreateReferenceToObject":
            retval.CreateReferenceToObject = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CreateReferenceToObject>(ref reader, options);
            break;
        case "DisplayName":
            ConverterHelpers.ReadFormLinkNullable<IMessageGetter>(retval.DisplayName, ref reader);
            break;
        case "External":
            retval.External = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ExternalAliasReference>(ref reader, options);
            break;
        case "Factions":
            ConverterHelpers.ReadFormLinkList<IFactionGetter>(retval.Factions, ref reader);
            break;
        case "FindMatchingRefFromEvent":
            retval.FindMatchingRefFromEvent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.FindMatchingRefFromEvent>(ref reader, options);
            break;
        case "FindMatchingRefNearAlias":
            retval.FindMatchingRefNearAlias = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.FindMatchingRefNearAlias>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "ForcedReference":
            ConverterHelpers.ReadFormLinkNullable<IPlacedGetter>(retval.ForcedReference, ref reader);
            break;
        case "GuardWarnOverridePackageList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.GuardWarnOverridePackageList, ref reader);
            break;
        case "ID":
            retval.ID = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Items":
            ConverterHelpers.ReadExtendedList<ContainerEntry>(retval.Items, ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "Location":
            retval.Location = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.LocationAliasReference>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ObserveDeadBodyOverridePackageList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.ObserveDeadBodyOverridePackageList, ref reader);
            break;
        case "PackageData":
            ConverterHelpers.ReadFormLinkList<IPackageGetter>(retval.PackageData, ref reader);
            break;
        case "SpecificLocation":
            ConverterHelpers.ReadFormLinkNullable<ILocationGetter>(retval.SpecificLocation, ref reader);
            break;
        case "SpectatorOverridePackageList":
            ConverterHelpers.ReadFormLinkNullable<IFormListGetter>(retval.SpectatorOverridePackageList, ref reader);
            break;
        case "Spells":
            ConverterHelpers.ReadFormLinkList<ISpellGetter>(retval.Spells, ref reader);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.QuestAlias.TypeEnum>(ref reader, options);
            break;
        case "UniqueActor":
            ConverterHelpers.ReadFormLinkNullable<INpcGetter>(retval.UniqueActor, ref reader);
            break;
        case "VoiceTypes":
            ConverterHelpers.ReadFormLinkNullable<IAliasVoiceTypeGetter>(retval.VoiceTypes, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IQuestFragmentAliasGetter_Converter : JsonConverter<IQuestFragmentAliasGetter>
{
  public override IQuestFragmentAliasGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IQuestFragmentAliasGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "QuestFragmentAlias");
    writer.WritePropertyName("ObjectFormat");
    JsonSerializer.Serialize(writer, value.ObjectFormat, options);
    writer.WritePropertyName("Property");
    JsonSerializer.Serialize(writer, value.Property, options);
    if (value.Scripts != default)
    {
      writer.WritePropertyName("Scripts");
      writer.WriteStartArray();
      foreach (var itm in value.Scripts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Scripts");
    }
    writer.WritePropertyName("Version");
    JsonSerializer.Serialize(writer, value.Version, options);
    writer.WriteEndObject();
  }
}
public class QuestFragmentAlias_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.QuestFragmentAlias>
{
  private IQuestFragmentAliasGetter_Converter _getterConverter;
  public QuestFragmentAlias_Converter(IQuestFragmentAliasGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.QuestFragmentAlias value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IQuestFragmentAliasGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.QuestFragmentAlias Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.QuestFragmentAlias();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ObjectFormat":
            retval.ObjectFormat = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Property":
            retval.Property = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptObjectProperty>(ref reader, options);
            break;
        case "Scripts":
            ConverterHelpers.ReadExtendedList<ScriptEntry>(retval.Scripts, ref reader, options);
            break;
        case "Version":
            retval.Version = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IQuestLogEntryGetter_Converter : JsonConverter<IQuestLogEntryGetter>
{
  public override IQuestLogEntryGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IQuestLogEntryGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "QuestLogEntry");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("Entry");
    JsonSerializer.Serialize(writer, value.Entry, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("NextQuest");
    JsonSerializer.Serialize(writer, value.NextQuest, options);
    writer.WritePropertyName("QNAM");
    JsonSerializer.Serialize(writer, value.QNAM, options);
    writer.WritePropertyName("SCHR");
    JsonSerializer.Serialize(writer, value.SCHR, options);
    writer.WritePropertyName("SCTX");
    JsonSerializer.Serialize(writer, value.SCTX, options);
    writer.WriteEndObject();
  }
}
public class QuestLogEntry_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.QuestLogEntry>
{
  private IQuestLogEntryGetter_Converter _getterConverter;
  public QuestLogEntry_Converter(IQuestLogEntryGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.QuestLogEntry value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IQuestLogEntryGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.QuestLogEntry Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.QuestLogEntry();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "Entry":
            retval.Entry = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "NextQuest":
            ConverterHelpers.ReadFormLinkNullable<IQuestGetter>(retval.NextQuest, ref reader);
            break;
        case "QNAM":
            break;
        case "SCHR":
            break;
        case "SCTX":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IQuestObjectiveGetter_Converter : JsonConverter<IQuestObjectiveGetter>
{
  public override IQuestObjectiveGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IQuestObjectiveGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "QuestObjective");
    writer.WritePropertyName("DisplayText");
    JsonSerializer.Serialize(writer, value.DisplayText, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    if (value.Targets != default)
    {
      writer.WritePropertyName("Targets");
      writer.WriteStartArray();
      foreach (var itm in value.Targets)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Targets");
    }
    writer.WriteEndObject();
  }
}
public class QuestObjective_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.QuestObjective>
{
  private IQuestObjectiveGetter_Converter _getterConverter;
  public QuestObjective_Converter(IQuestObjectiveGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.QuestObjective value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IQuestObjectiveGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.QuestObjective Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.QuestObjective();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DisplayText":
            retval.DisplayText = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "Index":
            retval.Index = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Targets":
            ConverterHelpers.ReadExtendedList<QuestObjectiveTarget>(retval.Targets, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IQuestObjectiveTargetGetter_Converter : JsonConverter<IQuestObjectiveTargetGetter>
{
  public override IQuestObjectiveTargetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IQuestObjectiveTargetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "QuestObjectiveTarget");
    writer.WritePropertyName("AliasIndex");
    JsonSerializer.Serialize(writer, value.AliasIndex, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("QSTADataTypeState");
    JsonSerializer.Serialize(writer, value.QSTADataTypeState, options);
    writer.WriteEndObject();
  }
}
public class QuestObjectiveTarget_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.QuestObjectiveTarget>
{
  private IQuestObjectiveTargetGetter_Converter _getterConverter;
  public QuestObjectiveTarget_Converter(IQuestObjectiveTargetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.QuestObjectiveTarget value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IQuestObjectiveTargetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.QuestObjectiveTarget Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.QuestObjectiveTarget();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AliasIndex":
            retval.AliasIndex = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Quest.TargetFlag>(ref reader, options);
            break;
        case "QSTADataTypeState":
            retval.QSTADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.QuestObjectiveTarget.QSTADataType>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IQuestScriptFragmentGetter_Converter : JsonConverter<IQuestScriptFragmentGetter>
{
  public override IQuestScriptFragmentGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IQuestScriptFragmentGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "QuestScriptFragment");
    writer.WritePropertyName("FragmentName");
    JsonSerializer.Serialize(writer, value.FragmentName, options);
    writer.WritePropertyName("ScriptName");
    JsonSerializer.Serialize(writer, value.ScriptName, options);
    writer.WritePropertyName("Stage");
    JsonSerializer.Serialize(writer, value.Stage, options);
    writer.WritePropertyName("StageIndex");
    JsonSerializer.Serialize(writer, value.StageIndex, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class QuestScriptFragment_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.QuestScriptFragment>
{
  private IQuestScriptFragmentGetter_Converter _getterConverter;
  public QuestScriptFragment_Converter(IQuestScriptFragmentGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.QuestScriptFragment value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IQuestScriptFragmentGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.QuestScriptFragment Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.QuestScriptFragment();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FragmentName":
            retval.FragmentName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ScriptName":
            retval.ScriptName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Stage":
            retval.Stage = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "StageIndex":
            retval.StageIndex = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IQuestStageGetter_Converter : JsonConverter<IQuestStageGetter>
{
  public override IQuestStageGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IQuestStageGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "QuestStage");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WritePropertyName("INDXDataTypeState");
    JsonSerializer.Serialize(writer, value.INDXDataTypeState, options);
    if (value.LogEntries != default)
    {
      writer.WritePropertyName("LogEntries");
      writer.WriteStartArray();
      foreach (var itm in value.LogEntries)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LogEntries");
    }
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class QuestStage_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.QuestStage>
{
  private IQuestStageGetter_Converter _getterConverter;
  public QuestStage_Converter(IQuestStageGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.QuestStage value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IQuestStageGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.QuestStage Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.QuestStage();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.QuestStage.Flag>(ref reader, options);
            break;
        case "Index":
            retval.Index = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "INDXDataTypeState":
            retval.INDXDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.QuestStage.INDXDataType>(ref reader, options);
            break;
        case "LogEntries":
            ConverterHelpers.ReadExtendedList<QuestLogEntry>(retval.LogEntries, ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IQuestTargetGetter_Converter : JsonConverter<IQuestTargetGetter>
{
  public override IQuestTargetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IQuestTargetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "QuestTarget");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("QSTADataTypeState");
    JsonSerializer.Serialize(writer, value.QSTADataTypeState, options);
    writer.WritePropertyName("Target");
    JsonSerializer.Serialize(writer, value.Target, options);
    writer.WriteEndObject();
  }
}
public class QuestTarget_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.QuestTarget>
{
  private IQuestTargetGetter_Converter _getterConverter;
  public QuestTarget_Converter(IQuestTargetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.QuestTarget value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IQuestTargetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.QuestTarget Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.QuestTarget();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Quest.TargetFlag>(ref reader, options);
            break;
        case "QSTADataTypeState":
            retval.QSTADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.QuestTarget.QSTADataType>(ref reader, options);
            break;
        case "Target":
            ConverterHelpers.ReadFormLink<IPlacedGetter>(retval.Target, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRaceGetter_Converter : JsonConverter<IRaceGetter>
{
  public override IRaceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRaceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Race");
    writer.WritePropertyName("AccelerationRate");
    JsonSerializer.Serialize(writer, value.AccelerationRate, options);
    if (value.ActorEffect != default)
    {
      writer.WritePropertyName("ActorEffect");
      writer.WriteStartArray();
      foreach (var itm in value.ActorEffect)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("ActorEffect");
    }
    writer.WritePropertyName("AimAngleTolerance");
    JsonSerializer.Serialize(writer, value.AimAngleTolerance, options);
    writer.WritePropertyName("AngularAccelerationRate");
    JsonSerializer.Serialize(writer, value.AngularAccelerationRate, options);
    writer.WritePropertyName("AngularTolerance");
    JsonSerializer.Serialize(writer, value.AngularTolerance, options);
    writer.WritePropertyName("ArmorRace");
    JsonSerializer.Serialize(writer, value.ArmorRace, options);
    writer.WritePropertyName("AttackRace");
    JsonSerializer.Serialize(writer, value.AttackRace, options);
    if (value.Attacks != default)
    {
      writer.WritePropertyName("Attacks");
      writer.WriteStartArray();
      foreach (var itm in value.Attacks)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Attacks");
    }
    writer.WritePropertyName("BaseCarryWeight");
    JsonSerializer.Serialize(writer, value.BaseCarryWeight, options);
    writer.WritePropertyName("BaseMass");
    JsonSerializer.Serialize(writer, value.BaseMass, options);
    writer.WritePropertyName("BaseMovementDefaultFly");
    JsonSerializer.Serialize(writer, value.BaseMovementDefaultFly, options);
    writer.WritePropertyName("BaseMovementDefaultRun");
    JsonSerializer.Serialize(writer, value.BaseMovementDefaultRun, options);
    writer.WritePropertyName("BaseMovementDefaultSneak");
    JsonSerializer.Serialize(writer, value.BaseMovementDefaultSneak, options);
    writer.WritePropertyName("BaseMovementDefaultSprint");
    JsonSerializer.Serialize(writer, value.BaseMovementDefaultSprint, options);
    writer.WritePropertyName("BaseMovementDefaultSwim");
    JsonSerializer.Serialize(writer, value.BaseMovementDefaultSwim, options);
    writer.WritePropertyName("BaseMovementDefaultWalk");
    JsonSerializer.Serialize(writer, value.BaseMovementDefaultWalk, options);
    writer.WritePropertyName("BehaviorGraph");
    JsonSerializer.Serialize(writer, value.BehaviorGraph, options);
    writer.WritePropertyName("BipedObjectNames");
    JsonSerializer.Serialize(writer, value.BipedObjectNames, options);
    writer.WritePropertyName("BodyBipedObject");
    JsonSerializer.Serialize(writer, value.BodyBipedObject, options);
    writer.WritePropertyName("BodyData");
    JsonSerializer.Serialize(writer, value.BodyData, options);
    writer.WritePropertyName("BodyPartData");
    JsonSerializer.Serialize(writer, value.BodyPartData, options);
    writer.WritePropertyName("BodyTemplate");
    JsonSerializer.Serialize(writer, value.BodyTemplate, options);
    writer.WritePropertyName("CloseLootSound");
    JsonSerializer.Serialize(writer, value.CloseLootSound, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("DecapitateArmors");
    JsonSerializer.Serialize(writer, value.DecapitateArmors, options);
    writer.WritePropertyName("DecapitationFX");
    JsonSerializer.Serialize(writer, value.DecapitationFX, options);
    writer.WritePropertyName("DecelerationRate");
    JsonSerializer.Serialize(writer, value.DecelerationRate, options);
    writer.WritePropertyName("DefaultHairColors");
    JsonSerializer.Serialize(writer, value.DefaultHairColors, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EquipmentFlags");
    JsonSerializer.Serialize(writer, value.EquipmentFlags, options);
    if (value.EquipmentSlots != default)
    {
      writer.WritePropertyName("EquipmentSlots");
      writer.WriteStartArray();
      foreach (var itm in value.EquipmentSlots)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("EquipmentSlots");
    }
    writer.WritePropertyName("ExportingExtraNam2");
    JsonSerializer.Serialize(writer, value.ExportingExtraNam2, options);
    if (value.Eyes != default)
    {
      writer.WritePropertyName("Eyes");
      writer.WriteStartArray();
      foreach (var itm in value.Eyes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Eyes");
    }
    writer.WritePropertyName("FaceFxPhonemes");
    JsonSerializer.Serialize(writer, value.FaceFxPhonemes, options);
    writer.WritePropertyName("FacegenFaceClamp");
    JsonSerializer.Serialize(writer, value.FacegenFaceClamp, options);
    writer.WritePropertyName("FacegenMainClamp");
    JsonSerializer.Serialize(writer, value.FacegenMainClamp, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FlightRadius");
    JsonSerializer.Serialize(writer, value.FlightRadius, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HairBipedObject");
    JsonSerializer.Serialize(writer, value.HairBipedObject, options);
    if (value.Hairs != default)
    {
      writer.WritePropertyName("Hairs");
      writer.WriteStartArray();
      foreach (var itm in value.Hairs)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Hairs");
    }
    writer.WritePropertyName("HeadBipedObject");
    JsonSerializer.Serialize(writer, value.HeadBipedObject, options);
    writer.WritePropertyName("HeadData");
    JsonSerializer.Serialize(writer, value.HeadData, options);
    writer.WritePropertyName("Height");
    JsonSerializer.Serialize(writer, value.Height, options);
    writer.WritePropertyName("ImpactDataSet");
    JsonSerializer.Serialize(writer, value.ImpactDataSet, options);
    writer.WritePropertyName("InjuredHealthPercent");
    JsonSerializer.Serialize(writer, value.InjuredHealthPercent, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MaterialType");
    JsonSerializer.Serialize(writer, value.MaterialType, options);
    writer.WritePropertyName("MorphRace");
    JsonSerializer.Serialize(writer, value.MorphRace, options);
    writer.WritePropertyName("MountData");
    JsonSerializer.Serialize(writer, value.MountData, options);
    if (value.MovementTypeNames != default)
    {
      writer.WritePropertyName("MovementTypeNames");
      writer.WriteStartArray();
      foreach (var itm in value.MovementTypeNames)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("MovementTypeNames");
    }
    if (value.MovementTypes != default)
    {
      writer.WritePropertyName("MovementTypes");
      writer.WriteStartArray();
      foreach (var itm in value.MovementTypes)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("MovementTypes");
    }
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("NumberOfTintsInList");
    JsonSerializer.Serialize(writer, value.NumberOfTintsInList, options);
    writer.WritePropertyName("OpenLootSound");
    JsonSerializer.Serialize(writer, value.OpenLootSound, options);
    writer.WritePropertyName("Regen");
    JsonSerializer.Serialize(writer, value.Regen, options);
    writer.WritePropertyName("ShieldBipedObject");
    JsonSerializer.Serialize(writer, value.ShieldBipedObject, options);
    writer.WritePropertyName("Size");
    JsonSerializer.Serialize(writer, value.Size, options);
    writer.WritePropertyName("SkeletalModel");
    JsonSerializer.Serialize(writer, value.SkeletalModel, options);
    writer.WritePropertyName("SkillBoost0");
    JsonSerializer.Serialize(writer, value.SkillBoost0, options);
    writer.WritePropertyName("SkillBoost1");
    JsonSerializer.Serialize(writer, value.SkillBoost1, options);
    writer.WritePropertyName("SkillBoost2");
    JsonSerializer.Serialize(writer, value.SkillBoost2, options);
    writer.WritePropertyName("SkillBoost3");
    JsonSerializer.Serialize(writer, value.SkillBoost3, options);
    writer.WritePropertyName("SkillBoost4");
    JsonSerializer.Serialize(writer, value.SkillBoost4, options);
    writer.WritePropertyName("SkillBoost5");
    JsonSerializer.Serialize(writer, value.SkillBoost5, options);
    writer.WritePropertyName("SkillBoost6");
    JsonSerializer.Serialize(writer, value.SkillBoost6, options);
    writer.WritePropertyName("Skin");
    JsonSerializer.Serialize(writer, value.Skin, options);
    writer.WritePropertyName("Starting");
    JsonSerializer.Serialize(writer, value.Starting, options);
    writer.WritePropertyName("UnarmedDamage");
    JsonSerializer.Serialize(writer, value.UnarmedDamage, options);
    writer.WritePropertyName("UnarmedEquipSlot");
    JsonSerializer.Serialize(writer, value.UnarmedEquipSlot, options);
    writer.WritePropertyName("UnarmedReach");
    JsonSerializer.Serialize(writer, value.UnarmedReach, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("Voices");
    JsonSerializer.Serialize(writer, value.Voices, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class Race_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Race>
{
  private IRaceGetter_Converter _getterConverter;
  public Race_Converter(IRaceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Race value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRaceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Race Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Race();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AccelerationRate":
            retval.AccelerationRate = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ActorEffect":
            ConverterHelpers.ReadFormLinkList<ISpellRecordGetter>(retval.ActorEffect, ref reader);
            break;
        case "AimAngleTolerance":
            retval.AimAngleTolerance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AngularAccelerationRate":
            retval.AngularAccelerationRate = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AngularTolerance":
            retval.AngularTolerance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ArmorRace":
            ConverterHelpers.ReadFormLinkNullable<IRaceGetter>(retval.ArmorRace, ref reader);
            break;
        case "AttackRace":
            ConverterHelpers.ReadFormLinkNullable<IRaceGetter>(retval.AttackRace, ref reader);
            break;
        case "Attacks":
            ConverterHelpers.ReadExtendedList<Attack>(retval.Attacks, ref reader, options);
            break;
        case "BaseCarryWeight":
            retval.BaseCarryWeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BaseMass":
            retval.BaseMass = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BaseMovementDefaultFly":
            ConverterHelpers.ReadFormLinkNullable<IMovementTypeGetter>(retval.BaseMovementDefaultFly, ref reader);
            break;
        case "BaseMovementDefaultRun":
            ConverterHelpers.ReadFormLinkNullable<IMovementTypeGetter>(retval.BaseMovementDefaultRun, ref reader);
            break;
        case "BaseMovementDefaultSneak":
            ConverterHelpers.ReadFormLinkNullable<IMovementTypeGetter>(retval.BaseMovementDefaultSneak, ref reader);
            break;
        case "BaseMovementDefaultSprint":
            ConverterHelpers.ReadFormLinkNullable<IMovementTypeGetter>(retval.BaseMovementDefaultSprint, ref reader);
            break;
        case "BaseMovementDefaultSwim":
            ConverterHelpers.ReadFormLinkNullable<IMovementTypeGetter>(retval.BaseMovementDefaultSwim, ref reader);
            break;
        case "BaseMovementDefaultWalk":
            ConverterHelpers.ReadFormLinkNullable<IMovementTypeGetter>(retval.BaseMovementDefaultWalk, ref reader);
            break;
        case "BehaviorGraph":
            break;
        case "BipedObjectNames":
            break;
        case "BodyBipedObject":
            retval.BodyBipedObject = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BipedObject>(ref reader, options);
            break;
        case "BodyData":
            break;
        case "BodyPartData":
            ConverterHelpers.ReadFormLinkNullable<IBodyPartDataGetter>(retval.BodyPartData, ref reader);
            break;
        case "BodyTemplate":
            retval.BodyTemplate = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BodyTemplate>(ref reader, options);
            break;
        case "CloseLootSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.CloseLootSound, ref reader);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Race.DATADataType>(ref reader, options);
            break;
        case "DecapitateArmors":
            break;
        case "DecapitationFX":
            ConverterHelpers.ReadFormLinkNullable<IArtObjectGetter>(retval.DecapitationFX, ref reader);
            break;
        case "DecelerationRate":
            retval.DecelerationRate = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DefaultHairColors":
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EquipmentFlags":
            retval.EquipmentFlags = JsonSerializer.Deserialize<EquipTypeFlag?>(ref reader, options);
            break;
        case "EquipmentSlots":
            ConverterHelpers.ReadFormLinkList<IEquipTypeGetter>(retval.EquipmentSlots, ref reader);
            break;
        case "ExportingExtraNam2":
            retval.ExportingExtraNam2 = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Eyes":
            ConverterHelpers.ReadFormLinkList<IEyesGetter>(retval.Eyes, ref reader);
            break;
        case "FaceFxPhonemes":
            retval.FaceFxPhonemes = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.FaceFxPhonemes>(ref reader, options);
            break;
        case "FacegenFaceClamp":
            retval.FacegenFaceClamp = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FacegenMainClamp":
            retval.FacegenMainClamp = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Race.Flag>(ref reader, options);
            break;
        case "FlightRadius":
            retval.FlightRadius = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HairBipedObject":
            retval.HairBipedObject = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BipedObject>(ref reader, options);
            break;
        case "Hairs":
            ConverterHelpers.ReadFormLinkList<IHairGetter>(retval.Hairs, ref reader);
            break;
        case "HeadBipedObject":
            retval.HeadBipedObject = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BipedObject>(ref reader, options);
            break;
        case "HeadData":
            break;
        case "Height":
            break;
        case "ImpactDataSet":
            ConverterHelpers.ReadFormLinkNullable<IImpactDataSetGetter>(retval.ImpactDataSet, ref reader);
            break;
        case "InjuredHealthPercent":
            retval.InjuredHealthPercent = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Race.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MaterialType":
            ConverterHelpers.ReadFormLinkNullable<IMaterialTypeGetter>(retval.MaterialType, ref reader);
            break;
        case "MorphRace":
            ConverterHelpers.ReadFormLinkNullable<IRaceGetter>(retval.MorphRace, ref reader);
            break;
        case "MountData":
            retval.MountData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.MountData>(ref reader, options);
            break;
        case "MovementTypeNames":
            ConverterHelpers.ReadExtendedList<String>(retval.MovementTypeNames, ref reader, options);
            break;
        case "MovementTypes":
            ConverterHelpers.ReadExtendedList<RaceMovementType>(retval.MovementTypes, ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "NumberOfTintsInList":
            retval.NumberOfTintsInList = JsonSerializer.Deserialize<UInt16?>(ref reader, options);
            break;
        case "OpenLootSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.OpenLootSound, ref reader);
            break;
        case "Regen":
            break;
        case "ShieldBipedObject":
            retval.ShieldBipedObject = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.BipedObject>(ref reader, options);
            break;
        case "Size":
            retval.Size = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Size>(ref reader, options);
            break;
        case "SkeletalModel":
            break;
        case "SkillBoost0":
            retval.SkillBoost0 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkillBoost>(ref reader, options);
            break;
        case "SkillBoost1":
            retval.SkillBoost1 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkillBoost>(ref reader, options);
            break;
        case "SkillBoost2":
            retval.SkillBoost2 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkillBoost>(ref reader, options);
            break;
        case "SkillBoost3":
            retval.SkillBoost3 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkillBoost>(ref reader, options);
            break;
        case "SkillBoost4":
            retval.SkillBoost4 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkillBoost>(ref reader, options);
            break;
        case "SkillBoost5":
            retval.SkillBoost5 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkillBoost>(ref reader, options);
            break;
        case "SkillBoost6":
            retval.SkillBoost6 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkillBoost>(ref reader, options);
            break;
        case "Skin":
            ConverterHelpers.ReadFormLinkNullable<IArmorGetter>(retval.Skin, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Starting":
            break;
        case "UnarmedDamage":
            retval.UnarmedDamage = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "UnarmedEquipSlot":
            ConverterHelpers.ReadFormLinkNullable<IEquipTypeGetter>(retval.UnarmedEquipSlot, ref reader);
            break;
        case "UnarmedReach":
            retval.UnarmedReach = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Voices":
            break;
        case "Weight":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRaceMovementTypeGetter_Converter : JsonConverter<IRaceMovementTypeGetter>
{
  public override IRaceMovementTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRaceMovementTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RaceMovementType");
    writer.WritePropertyName("MovementType");
    JsonSerializer.Serialize(writer, value.MovementType, options);
    writer.WritePropertyName("Overrides");
    JsonSerializer.Serialize(writer, value.Overrides, options);
    writer.WriteEndObject();
  }
}
public class RaceMovementType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RaceMovementType>
{
  private IRaceMovementTypeGetter_Converter _getterConverter;
  public RaceMovementType_Converter(IRaceMovementTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RaceMovementType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRaceMovementTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RaceMovementType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RaceMovementType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "MovementType":
            ConverterHelpers.ReadFormLinkNullable<IMovementTypeGetter>(retval.MovementType, ref reader);
            break;
        case "Overrides":
            retval.Overrides = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SpeedOverrides>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRankGetter_Converter : JsonConverter<IRankGetter>
{
  public override IRankGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRankGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Rank");
    writer.WritePropertyName("Insignia");
    JsonSerializer.Serialize(writer, value.Insignia, options);
    writer.WritePropertyName("Number");
    JsonSerializer.Serialize(writer, value.Number, options);
    writer.WritePropertyName("Title");
    JsonSerializer.Serialize(writer, value.Title, options);
    writer.WriteEndObject();
  }
}
public class Rank_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Rank>
{
  private IRankGetter_Converter _getterConverter;
  public Rank_Converter(IRankGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Rank value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRankGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Rank Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Rank();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Insignia":
            retval.Insignia = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Number":
            retval.Number = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "Title":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRankPlacementGetter_Converter : JsonConverter<IRankPlacementGetter>
{
  public override IRankPlacementGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRankPlacementGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RankPlacement");
    writer.WritePropertyName("Faction");
    JsonSerializer.Serialize(writer, value.Faction, options);
    writer.WritePropertyName("Fluff");
    JsonSerializer.Serialize(writer, value.Fluff, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WriteEndObject();
  }
}
public class RankPlacement_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RankPlacement>
{
  private IRankPlacementGetter_Converter _getterConverter;
  public RankPlacement_Converter(IRankPlacementGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RankPlacement value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRankPlacementGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RankPlacement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RankPlacement();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Faction":
            ConverterHelpers.ReadFormLink<IFactionGetter>(retval.Faction, ref reader);
            break;
        case "Fluff":
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionGetter_Converter : JsonConverter<IRegionGetter>
{
  public override IRegionGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Region");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Grasses");
    JsonSerializer.Serialize(writer, value.Grasses, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("Land");
    JsonSerializer.Serialize(writer, value.Land, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Map");
    JsonSerializer.Serialize(writer, value.Map, options);
    writer.WritePropertyName("MapColor");
    JsonSerializer.Serialize(writer, value.MapColor, options);
    writer.WritePropertyName("Objects");
    JsonSerializer.Serialize(writer, value.Objects, options);
    if (value.RegionAreas != default)
    {
      writer.WritePropertyName("RegionAreas");
      writer.WriteStartArray();
      foreach (var itm in value.RegionAreas)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RegionAreas");
    }
    writer.WritePropertyName("Sounds");
    JsonSerializer.Serialize(writer, value.Sounds, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("Weather");
    JsonSerializer.Serialize(writer, value.Weather, options);
    writer.WritePropertyName("Worldspace");
    JsonSerializer.Serialize(writer, value.Worldspace, options);
    writer.WriteEndObject();
  }
}
public class Region_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Region>
{
  private IRegionGetter_Converter _getterConverter;
  public Region_Converter(IRegionGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Region value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Region Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Region();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Grasses":
            retval.Grasses = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionGrasses>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Land":
            retval.Land = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionLand>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Region.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Map":
            retval.Map = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionMap>(ref reader, options);
            break;
        case "MapColor":
            retval.MapColor = JsonSerializer.Deserialize<Color?>(ref reader, options);
            break;
        case "Objects":
            retval.Objects = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionObjects>(ref reader, options);
            break;
        case "RegionAreas":
            ConverterHelpers.ReadExtendedList<RegionArea>(retval.RegionAreas, ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Sounds":
            retval.Sounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionSounds>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Weather":
            retval.Weather = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionWeather>(ref reader, options);
            break;
        case "Worldspace":
            ConverterHelpers.ReadFormLinkNullable<IWorldspaceGetter>(retval.Worldspace, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionAreaGetter_Converter : JsonConverter<IRegionAreaGetter>
{
  public override IRegionAreaGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionAreaGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionArea");
    writer.WritePropertyName("EdgeFallOff");
    JsonSerializer.Serialize(writer, value.EdgeFallOff, options);
    if (value.RegionPointListData != default)
    {
      writer.WritePropertyName("RegionPointListData");
      writer.WriteStartArray();
      foreach (var itm in value.RegionPointListData)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("RegionPointListData");
    }
    writer.WriteEndObject();
  }
}
public class RegionArea_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionArea>
{
  private IRegionAreaGetter_Converter _getterConverter;
  public RegionArea_Converter(IRegionAreaGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionArea value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionAreaGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionArea Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionArea();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EdgeFallOff":
            retval.EdgeFallOff = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "RegionPointListData":
            ConverterHelpers.ReadExtendedList<P2Float>(retval.RegionPointListData, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionDataHeaderGetter_Converter : JsonConverter<IRegionDataHeaderGetter>
{
  public override IRegionDataHeaderGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionDataHeaderGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionDataHeader");
    writer.WritePropertyName("DataType");
    JsonSerializer.Serialize(writer, value.DataType, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    writer.WriteEndObject();
  }
}
public class RegionDataHeader_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionDataHeader>
{
  private IRegionDataHeaderGetter_Converter _getterConverter;
  public RegionDataHeader_Converter(IRegionDataHeaderGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionDataHeader value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionDataHeaderGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionDataHeader Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionDataHeader();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DataType":
            retval.DataType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionData.RegionDataType>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionData.RegionDataFlag>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionGrassGetter_Converter : JsonConverter<IRegionGrassGetter>
{
  public override IRegionGrassGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionGrassGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionGrass");
    writer.WritePropertyName("Grass");
    JsonSerializer.Serialize(writer, value.Grass, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class RegionGrass_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionGrass>
{
  private IRegionGrassGetter_Converter _getterConverter;
  public RegionGrass_Converter(IRegionGrassGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionGrass value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionGrassGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionGrass Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionGrass();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Grass":
            ConverterHelpers.ReadFormLink<IGrassGetter>(retval.Grass, ref reader);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionGrassesGetter_Converter : JsonConverter<IRegionGrassesGetter>
{
  public override IRegionGrassesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionGrassesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionGrasses");
    if (value.Grasses != default)
    {
      writer.WritePropertyName("Grasses");
      writer.WriteStartArray();
      foreach (var itm in value.Grasses)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Grasses");
    }
    writer.WritePropertyName("Header");
    JsonSerializer.Serialize(writer, value.Header, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WriteEndObject();
  }
}
public class RegionGrasses_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionGrasses>
{
  private IRegionGrassesGetter_Converter _getterConverter;
  public RegionGrasses_Converter(IRegionGrassesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionGrasses value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionGrassesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionGrasses Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionGrasses();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Grasses":
            ConverterHelpers.ReadExtendedList<RegionGrass>(retval.Grasses, ref reader, options);
            break;
        case "Header":
            retval.Header = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionDataHeader>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionLandGetter_Converter : JsonConverter<IRegionLandGetter>
{
  public override IRegionLandGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionLandGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionLand");
    writer.WritePropertyName("Header");
    JsonSerializer.Serialize(writer, value.Header, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WriteEndObject();
  }
}
public class RegionLand_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionLand>
{
  private IRegionLandGetter_Converter _getterConverter;
  public RegionLand_Converter(IRegionLandGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionLand value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionLandGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionLand Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionLand();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Header":
            retval.Header = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionDataHeader>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionMapGetter_Converter : JsonConverter<IRegionMapGetter>
{
  public override IRegionMapGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionMapGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionMap");
    writer.WritePropertyName("Header");
    JsonSerializer.Serialize(writer, value.Header, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class RegionMap_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionMap>
{
  private IRegionMapGetter_Converter _getterConverter;
  public RegionMap_Converter(IRegionMapGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionMap value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionMapGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionMap Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionMap();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Header":
            retval.Header = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionDataHeader>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionObjectGetter_Converter : JsonConverter<IRegionObjectGetter>
{
  public override IRegionObjectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionObjectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionObject");
    writer.WritePropertyName("AngleVariance");
    JsonSerializer.Serialize(writer, value.AngleVariance, options);
    writer.WritePropertyName("Clustering");
    JsonSerializer.Serialize(writer, value.Clustering, options);
    writer.WritePropertyName("Density");
    JsonSerializer.Serialize(writer, value.Density, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("MaxHeight");
    JsonSerializer.Serialize(writer, value.MaxHeight, options);
    writer.WritePropertyName("MaxSlope");
    JsonSerializer.Serialize(writer, value.MaxSlope, options);
    writer.WritePropertyName("MinHeight");
    JsonSerializer.Serialize(writer, value.MinHeight, options);
    writer.WritePropertyName("MinSlope");
    JsonSerializer.Serialize(writer, value.MinSlope, options);
    writer.WritePropertyName("Object");
    JsonSerializer.Serialize(writer, value.Object, options);
    writer.WritePropertyName("ParentIndex");
    JsonSerializer.Serialize(writer, value.ParentIndex, options);
    writer.WritePropertyName("Radius");
    JsonSerializer.Serialize(writer, value.Radius, options);
    writer.WritePropertyName("RadiusWrtPercent");
    JsonSerializer.Serialize(writer, value.RadiusWrtPercent, options);
    writer.WritePropertyName("Sink");
    JsonSerializer.Serialize(writer, value.Sink, options);
    writer.WritePropertyName("SinkVariance");
    JsonSerializer.Serialize(writer, value.SinkVariance, options);
    writer.WritePropertyName("SizeVariance");
    JsonSerializer.Serialize(writer, value.SizeVariance, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class RegionObject_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionObject>
{
  private IRegionObjectGetter_Converter _getterConverter;
  public RegionObject_Converter(IRegionObjectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionObject value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionObjectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionObject();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AngleVariance":
            retval.AngleVariance = JsonSerializer.Deserialize<Noggog.P3UInt16>(ref reader, options);
            break;
        case "Clustering":
            retval.Clustering = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Density":
            retval.Density = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionObject.Flag>(ref reader, options);
            break;
        case "MaxHeight":
            retval.MaxHeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MaxSlope":
            retval.MaxSlope = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "MinHeight":
            retval.MinHeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MinSlope":
            retval.MinSlope = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Object":
            ConverterHelpers.ReadFormLink<IRegionTargetGetter>(retval.Object, ref reader);
            break;
        case "ParentIndex":
            retval.ParentIndex = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Radius":
            retval.Radius = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "RadiusWrtPercent":
            retval.RadiusWrtPercent = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Sink":
            retval.Sink = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SinkVariance":
            retval.SinkVariance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SizeVariance":
            retval.SizeVariance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Unknown2":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionObjectsGetter_Converter : JsonConverter<IRegionObjectsGetter>
{
  public override IRegionObjectsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionObjectsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionObjects");
    writer.WritePropertyName("Header");
    JsonSerializer.Serialize(writer, value.Header, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    if (value.Objects != default)
    {
      writer.WritePropertyName("Objects");
      writer.WriteStartArray();
      foreach (var itm in value.Objects)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Objects");
    }
    writer.WriteEndObject();
  }
}
public class RegionObjects_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionObjects>
{
  private IRegionObjectsGetter_Converter _getterConverter;
  public RegionObjects_Converter(IRegionObjectsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionObjects value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionObjectsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionObjects Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionObjects();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Header":
            retval.Header = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionDataHeader>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "Objects":
            ConverterHelpers.ReadExtendedList<RegionObject>(retval.Objects, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionSoundGetter_Converter : JsonConverter<IRegionSoundGetter>
{
  public override IRegionSoundGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionSoundGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionSound");
    writer.WritePropertyName("Chance");
    JsonSerializer.Serialize(writer, value.Chance, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Sound");
    JsonSerializer.Serialize(writer, value.Sound, options);
    writer.WriteEndObject();
  }
}
public class RegionSound_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionSound>
{
  private IRegionSoundGetter_Converter _getterConverter;
  public RegionSound_Converter(IRegionSoundGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionSound value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionSoundGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionSound Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionSound();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Chance":
            retval.Chance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionSound.Flag>(ref reader, options);
            break;
        case "Sound":
            ConverterHelpers.ReadFormLink<ISoundDescriptorGetter>(retval.Sound, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionSoundsGetter_Converter : JsonConverter<IRegionSoundsGetter>
{
  public override IRegionSoundsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionSoundsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionSounds");
    writer.WritePropertyName("Header");
    JsonSerializer.Serialize(writer, value.Header, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("Music");
    JsonSerializer.Serialize(writer, value.Music, options);
    if (value.Sounds != default)
    {
      writer.WritePropertyName("Sounds");
      writer.WriteStartArray();
      foreach (var itm in value.Sounds)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Sounds");
    }
    writer.WriteEndObject();
  }
}
public class RegionSounds_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionSounds>
{
  private IRegionSoundsGetter_Converter _getterConverter;
  public RegionSounds_Converter(IRegionSoundsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionSounds value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionSoundsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionSounds Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionSounds();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Header":
            retval.Header = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionDataHeader>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "Music":
            ConverterHelpers.ReadFormLinkNullable<IMusicTypeGetter>(retval.Music, ref reader);
            break;
        case "Sounds":
            ConverterHelpers.ReadExtendedList<RegionSound>(retval.Sounds, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRegionWeatherGetter_Converter : JsonConverter<IRegionWeatherGetter>
{
  public override IRegionWeatherGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRegionWeatherGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "RegionWeather");
    writer.WritePropertyName("Header");
    JsonSerializer.Serialize(writer, value.Header, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    if (value.Weathers != default)
    {
      writer.WritePropertyName("Weathers");
      writer.WriteStartArray();
      foreach (var itm in value.Weathers)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Weathers");
    }
    writer.WriteEndObject();
  }
}
public class RegionWeather_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.RegionWeather>
{
  private IRegionWeatherGetter_Converter _getterConverter;
  public RegionWeather_Converter(IRegionWeatherGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.RegionWeather value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRegionWeatherGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.RegionWeather Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.RegionWeather();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Header":
            retval.Header = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.RegionDataHeader>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "Weathers":
            ConverterHelpers.ReadExtendedList<WeatherType>(retval.Weathers, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRelationGetter_Converter : JsonConverter<IRelationGetter>
{
  public override IRelationGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRelationGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Relation");
    writer.WritePropertyName("Modifier");
    JsonSerializer.Serialize(writer, value.Modifier, options);
    writer.WritePropertyName("Reaction");
    JsonSerializer.Serialize(writer, value.Reaction, options);
    writer.WritePropertyName("Target");
    JsonSerializer.Serialize(writer, value.Target, options);
    writer.WriteEndObject();
  }
}
public class Relation_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Relation>
{
  private IRelationGetter_Converter _getterConverter;
  public Relation_Converter(IRelationGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Relation value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRelationGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Relation Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Relation();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Modifier":
            retval.Modifier = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Reaction":
            retval.Reaction = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CombatReaction>(ref reader, options);
            break;
        case "Target":
            ConverterHelpers.ReadFormLink<IRelatableGetter>(retval.Target, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IRelationshipGetter_Converter : JsonConverter<IRelationshipGetter>
{
  public override IRelationshipGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IRelationshipGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Relationship");
    writer.WritePropertyName("AssociationType");
    JsonSerializer.Serialize(writer, value.AssociationType, options);
    writer.WritePropertyName("Child");
    JsonSerializer.Serialize(writer, value.Child, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Parent");
    JsonSerializer.Serialize(writer, value.Parent, options);
    writer.WritePropertyName("Rank");
    JsonSerializer.Serialize(writer, value.Rank, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Relationship_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Relationship>
{
  private IRelationshipGetter_Converter _getterConverter;
  public Relationship_Converter(IRelationshipGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Relationship value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IRelationshipGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Relationship Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Relationship();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AssociationType":
            ConverterHelpers.ReadFormLink<IAssociationTypeGetter>(retval.AssociationType, ref reader);
            break;
        case "Child":
            ConverterHelpers.ReadFormLink<INpcGetter>(retval.Child, ref reader);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Relationship.DATADataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Relationship.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Relationship.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Parent":
            ConverterHelpers.ReadFormLink<INpcGetter>(retval.Parent, ref reader);
            break;
        case "Rank":
            retval.Rank = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Relationship.RankType>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IReverbParametersGetter_Converter : JsonConverter<IReverbParametersGetter>
{
  public override IReverbParametersGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IReverbParametersGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ReverbParameters");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("DecayHfRatio");
    JsonSerializer.Serialize(writer, value.DecayHfRatio, options);
    writer.WritePropertyName("DecayMilliseconds");
    JsonSerializer.Serialize(writer, value.DecayMilliseconds, options);
    writer.WritePropertyName("DensityPercent");
    JsonSerializer.Serialize(writer, value.DensityPercent, options);
    writer.WritePropertyName("DiffusionPercent");
    JsonSerializer.Serialize(writer, value.DiffusionPercent, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HfReferenceHertz");
    JsonSerializer.Serialize(writer, value.HfReferenceHertz, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("ReflectDelayMS");
    JsonSerializer.Serialize(writer, value.ReflectDelayMS, options);
    writer.WritePropertyName("Reflections");
    JsonSerializer.Serialize(writer, value.Reflections, options);
    writer.WritePropertyName("ReverbAmp");
    JsonSerializer.Serialize(writer, value.ReverbAmp, options);
    writer.WritePropertyName("ReverbDelayMS");
    JsonSerializer.Serialize(writer, value.ReverbDelayMS, options);
    writer.WritePropertyName("RoomFilter");
    JsonSerializer.Serialize(writer, value.RoomFilter, options);
    writer.WritePropertyName("RoomHfFilter");
    JsonSerializer.Serialize(writer, value.RoomHfFilter, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class ReverbParameters_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ReverbParameters>
{
  private IReverbParametersGetter_Converter _getterConverter;
  public ReverbParameters_Converter(IReverbParametersGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ReverbParameters value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IReverbParametersGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ReverbParameters Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ReverbParameters();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ReverbParameters.DATADataType>(ref reader, options);
            break;
        case "DecayHfRatio":
            retval.DecayHfRatio = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DecayMilliseconds":
            retval.DecayMilliseconds = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "DensityPercent":
            retval.DensityPercent = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "DiffusionPercent":
            retval.DiffusionPercent = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HfReferenceHertz":
            retval.HfReferenceHertz = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ReflectDelayMS":
            retval.ReflectDelayMS = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Reflections":
            retval.Reflections = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "ReverbAmp":
            retval.ReverbAmp = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "ReverbDelayMS":
            retval.ReverbDelayMS = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "RoomFilter":
            retval.RoomFilter = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "RoomHfFilter":
            retval.RoomHfFilter = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISceneGetter_Converter : JsonConverter<ISceneGetter>
{
  public override ISceneGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISceneGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Scene");
    if (value.Actions != default)
    {
      writer.WritePropertyName("Actions");
      writer.WriteStartArray();
      foreach (var itm in value.Actions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Actions");
    }
    if (value.Actors != default)
    {
      writer.WritePropertyName("Actors");
      writer.WriteStartArray();
      foreach (var itm in value.Actors)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Actors");
    }
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LastActionIndex");
    JsonSerializer.Serialize(writer, value.LastActionIndex, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    if (value.Phases != default)
    {
      writer.WritePropertyName("Phases");
      writer.WriteStartArray();
      foreach (var itm in value.Phases)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Phases");
    }
    writer.WritePropertyName("Quest");
    JsonSerializer.Serialize(writer, value.Quest, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WritePropertyName("Unused2");
    JsonSerializer.Serialize(writer, value.Unused2, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("VNAM");
    JsonSerializer.Serialize(writer, value.VNAM, options);
    writer.WriteEndObject();
  }
}
public class Scene_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Scene>
{
  private ISceneGetter_Converter _getterConverter;
  public Scene_Converter(ISceneGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Scene value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISceneGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Scene Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Scene();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Actions":
            ConverterHelpers.ReadExtendedList<SceneAction>(retval.Actions, ref reader, options);
            break;
        case "Actors":
            ConverterHelpers.ReadExtendedList<SceneActor>(retval.Actors, ref reader, options);
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LastActionIndex":
            retval.LastActionIndex = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Phases":
            ConverterHelpers.ReadExtendedList<ScenePhase>(retval.Phases, ref reader, options);
            break;
        case "Quest":
            ConverterHelpers.ReadFormLinkNullable<IQuestGetter>(retval.Quest, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Unused":
            retval.Unused = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData>(ref reader, options);
            break;
        case "Unused2":
            retval.Unused2 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SceneAdapter>(ref reader, options);
            break;
        case "VNAM":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISceneActionGetter_Converter : JsonConverter<ISceneActionGetter>
{
  public override ISceneActionGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISceneActionGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SceneAction");
    writer.WritePropertyName("ActorID");
    JsonSerializer.Serialize(writer, value.ActorID, options);
    writer.WritePropertyName("Emotion");
    JsonSerializer.Serialize(writer, value.Emotion, options);
    writer.WritePropertyName("EmotionValue");
    JsonSerializer.Serialize(writer, value.EmotionValue, options);
    writer.WritePropertyName("EndPhase");
    JsonSerializer.Serialize(writer, value.EndPhase, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("HeadtrackActorID");
    JsonSerializer.Serialize(writer, value.HeadtrackActorID, options);
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WritePropertyName("LNAM");
    JsonSerializer.Serialize(writer, value.LNAM, options);
    writer.WritePropertyName("LoopingMax");
    JsonSerializer.Serialize(writer, value.LoopingMax, options);
    writer.WritePropertyName("LoopingMin");
    JsonSerializer.Serialize(writer, value.LoopingMin, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    if (value.Packages != default)
    {
      writer.WritePropertyName("Packages");
      writer.WriteStartArray();
      foreach (var itm in value.Packages)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Packages");
    }
    writer.WritePropertyName("StartPhase");
    JsonSerializer.Serialize(writer, value.StartPhase, options);
    writer.WritePropertyName("TimerSeconds");
    JsonSerializer.Serialize(writer, value.TimerSeconds, options);
    writer.WritePropertyName("Topic");
    JsonSerializer.Serialize(writer, value.Topic, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WriteEndObject();
  }
}
public class SceneAction_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SceneAction>
{
  private ISceneActionGetter_Converter _getterConverter;
  public SceneAction_Converter(ISceneActionGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SceneAction value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISceneActionGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SceneAction Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SceneAction();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ActorID":
            retval.ActorID = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "Emotion":
            retval.Emotion = JsonSerializer.Deserialize<Emotion?>(ref reader, options);
            break;
        case "EmotionValue":
            retval.EmotionValue = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "EndPhase":
            retval.EndPhase = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "HeadtrackActorID":
            retval.HeadtrackActorID = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "Index":
            retval.Index = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "LNAM":
            break;
        case "LoopingMax":
            retval.LoopingMax = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "LoopingMin":
            retval.LoopingMin = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Packages":
            ConverterHelpers.ReadFormLinkList<IPackageGetter>(retval.Packages, ref reader);
            break;
        case "StartPhase":
            retval.StartPhase = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "TimerSeconds":
            retval.TimerSeconds = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Topic":
            ConverterHelpers.ReadFormLinkNullable<IDialogTopicGetter>(retval.Topic, ref reader);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SceneAction.TypeEnum>(ref reader, options);
            break;
        case "Unused":
            retval.Unused = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISceneActorGetter_Converter : JsonConverter<ISceneActorGetter>
{
  public override ISceneActorGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISceneActorGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SceneActor");
    writer.WritePropertyName("BehaviorFlags");
    JsonSerializer.Serialize(writer, value.BehaviorFlags, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("ID");
    JsonSerializer.Serialize(writer, value.ID, options);
    writer.WriteEndObject();
  }
}
public class SceneActor_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SceneActor>
{
  private ISceneActorGetter_Converter _getterConverter;
  public SceneActor_Converter(ISceneActorGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SceneActor value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISceneActorGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SceneActor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SceneActor();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BehaviorFlags":
            retval.BehaviorFlags = JsonSerializer.Deserialize<BehaviorFlag?>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "ID":
            retval.ID = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISceneAdapterGetter_Converter : JsonConverter<ISceneAdapterGetter>
{
  public override ISceneAdapterGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISceneAdapterGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SceneAdapter");
    writer.WritePropertyName("ObjectFormat");
    JsonSerializer.Serialize(writer, value.ObjectFormat, options);
    writer.WritePropertyName("ScriptFragments");
    JsonSerializer.Serialize(writer, value.ScriptFragments, options);
    if (value.Scripts != default)
    {
      writer.WritePropertyName("Scripts");
      writer.WriteStartArray();
      foreach (var itm in value.Scripts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Scripts");
    }
    writer.WritePropertyName("Version");
    JsonSerializer.Serialize(writer, value.Version, options);
    writer.WriteEndObject();
  }
}
public class SceneAdapter_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SceneAdapter>
{
  private ISceneAdapterGetter_Converter _getterConverter;
  public SceneAdapter_Converter(ISceneAdapterGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SceneAdapter value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISceneAdapterGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SceneAdapter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SceneAdapter();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ObjectFormat":
            retval.ObjectFormat = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "ScriptFragments":
            retval.ScriptFragments = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SceneScriptFragments>(ref reader, options);
            break;
        case "Scripts":
            ConverterHelpers.ReadExtendedList<ScriptEntry>(retval.Scripts, ref reader, options);
            break;
        case "Version":
            retval.Version = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScenePhaseGetter_Converter : JsonConverter<IScenePhaseGetter>
{
  public override IScenePhaseGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScenePhaseGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScenePhase");
    if (value.CompletionConditions != default)
    {
      writer.WritePropertyName("CompletionConditions");
      writer.WriteStartArray();
      foreach (var itm in value.CompletionConditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("CompletionConditions");
    }
    writer.WritePropertyName("EditorWidth");
    JsonSerializer.Serialize(writer, value.EditorWidth, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    if (value.StartConditions != default)
    {
      writer.WritePropertyName("StartConditions");
      writer.WriteStartArray();
      foreach (var itm in value.StartConditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("StartConditions");
    }
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WritePropertyName("Unused2");
    JsonSerializer.Serialize(writer, value.Unused2, options);
    writer.WriteEndObject();
  }
}
public class ScenePhase_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScenePhase>
{
  private IScenePhaseGetter_Converter _getterConverter;
  public ScenePhase_Converter(IScenePhaseGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScenePhase value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScenePhaseGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScenePhase Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScenePhase();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CompletionConditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.CompletionConditions, ref reader, options);
            break;
        case "EditorWidth":
            retval.EditorWidth = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "StartConditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.StartConditions, ref reader, options);
            break;
        case "Unused":
            retval.Unused = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData>(ref reader, options);
            break;
        case "Unused2":
            retval.Unused2 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScenePhaseFragmentGetter_Converter : JsonConverter<IScenePhaseFragmentGetter>
{
  public override IScenePhaseFragmentGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScenePhaseFragmentGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScenePhaseFragment");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FragmentName");
    JsonSerializer.Serialize(writer, value.FragmentName, options);
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WritePropertyName("ScriptName");
    JsonSerializer.Serialize(writer, value.ScriptName, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class ScenePhaseFragment_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScenePhaseFragment>
{
  private IScenePhaseFragmentGetter_Converter _getterConverter;
  public ScenePhaseFragment_Converter(IScenePhaseFragmentGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScenePhaseFragment value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScenePhaseFragmentGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScenePhaseFragment Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScenePhaseFragment();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScenePhaseFragment.Flag>(ref reader, options);
            break;
        case "FragmentName":
            retval.FragmentName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Index":
            retval.Index = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "ScriptName":
            retval.ScriptName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScenePhaseUnusedDataGetter_Converter : JsonConverter<IScenePhaseUnusedDataGetter>
{
  public override IScenePhaseUnusedDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScenePhaseUnusedDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScenePhaseUnusedData");
    writer.WritePropertyName("QNAM");
    JsonSerializer.Serialize(writer, value.QNAM, options);
    writer.WritePropertyName("SCDA");
    JsonSerializer.Serialize(writer, value.SCDA, options);
    writer.WritePropertyName("SCHR");
    JsonSerializer.Serialize(writer, value.SCHR, options);
    writer.WritePropertyName("SCRO");
    JsonSerializer.Serialize(writer, value.SCRO, options);
    writer.WritePropertyName("SCTX");
    JsonSerializer.Serialize(writer, value.SCTX, options);
    writer.WriteEndObject();
  }
}
public class ScenePhaseUnusedData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData>
{
  private IScenePhaseUnusedDataGetter_Converter _getterConverter;
  public ScenePhaseUnusedData_Converter(IScenePhaseUnusedDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScenePhaseUnusedDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "QNAM":
            break;
        case "SCDA":
            break;
        case "SCHR":
            break;
        case "SCRO":
            break;
        case "SCTX":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISceneScriptFragmentsGetter_Converter : JsonConverter<ISceneScriptFragmentsGetter>
{
  public override ISceneScriptFragmentsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISceneScriptFragmentsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SceneScriptFragments");
    writer.WritePropertyName("FileName");
    JsonSerializer.Serialize(writer, value.FileName, options);
    writer.WritePropertyName("OnBegin");
    JsonSerializer.Serialize(writer, value.OnBegin, options);
    writer.WritePropertyName("OnEnd");
    JsonSerializer.Serialize(writer, value.OnEnd, options);
    if (value.PhaseFragments != default)
    {
      writer.WritePropertyName("PhaseFragments");
      writer.WriteStartArray();
      foreach (var itm in value.PhaseFragments)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("PhaseFragments");
    }
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class SceneScriptFragments_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SceneScriptFragments>
{
  private ISceneScriptFragmentsGetter_Converter _getterConverter;
  public SceneScriptFragments_Converter(ISceneScriptFragmentsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SceneScriptFragments value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISceneScriptFragmentsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SceneScriptFragments Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SceneScriptFragments();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FileName":
            retval.FileName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "OnBegin":
            retval.OnBegin = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptFragment>(ref reader, options);
            break;
        case "OnEnd":
            retval.OnEnd = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptFragment>(ref reader, options);
            break;
        case "PhaseFragments":
            ConverterHelpers.ReadExtendedList<ScenePhaseFragment>(retval.PhaseFragments, ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptBoolListPropertyGetter_Converter : JsonConverter<IScriptBoolListPropertyGetter>
{
  public override IScriptBoolListPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptBoolListPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptBoolListProperty");
    if (value.Data != default)
    {
      writer.WritePropertyName("Data");
      writer.WriteStartArray();
      foreach (var itm in value.Data)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Data");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class ScriptBoolListProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptBoolListProperty>
{
  private IScriptBoolListPropertyGetter_Converter _getterConverter;
  public ScriptBoolListProperty_Converter(IScriptBoolListPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptBoolListProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptBoolListPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptBoolListProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptBoolListProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            ConverterHelpers.ReadExtendedList<Boolean>(retval.Data, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptBoolPropertyGetter_Converter : JsonConverter<IScriptBoolPropertyGetter>
{
  public override IScriptBoolPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptBoolPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptBoolProperty");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class ScriptBoolProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptBoolProperty>
{
  private IScriptBoolPropertyGetter_Converter _getterConverter;
  public ScriptBoolProperty_Converter(IScriptBoolPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptBoolProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptBoolPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptBoolProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptBoolProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptEntryGetter_Converter : JsonConverter<IScriptEntryGetter>
{
  public override IScriptEntryGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptEntryGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptEntry");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    if (value.Properties != default)
    {
      writer.WritePropertyName("Properties");
      writer.WriteStartArray();
      foreach (var itm in value.Properties)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Properties");
    }
    writer.WriteEndObject();
  }
}
public class ScriptEntry_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptEntry>
{
  private IScriptEntryGetter_Converter _getterConverter;
  public ScriptEntry_Converter(IScriptEntryGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptEntry value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptEntryGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptEntry Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptEntry();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptEntry.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Properties":
            ConverterHelpers.ReadExtendedList<ScriptProperty>(retval.Properties, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptFloatListPropertyGetter_Converter : JsonConverter<IScriptFloatListPropertyGetter>
{
  public override IScriptFloatListPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptFloatListPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptFloatListProperty");
    if (value.Data != default)
    {
      writer.WritePropertyName("Data");
      writer.WriteStartArray();
      foreach (var itm in value.Data)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Data");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class ScriptFloatListProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptFloatListProperty>
{
  private IScriptFloatListPropertyGetter_Converter _getterConverter;
  public ScriptFloatListProperty_Converter(IScriptFloatListPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptFloatListProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptFloatListPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptFloatListProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptFloatListProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            ConverterHelpers.ReadExtendedList<Single>(retval.Data, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptFloatPropertyGetter_Converter : JsonConverter<IScriptFloatPropertyGetter>
{
  public override IScriptFloatPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptFloatPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptFloatProperty");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class ScriptFloatProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptFloatProperty>
{
  private IScriptFloatPropertyGetter_Converter _getterConverter;
  public ScriptFloatProperty_Converter(IScriptFloatPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptFloatProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptFloatPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptFloatProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptFloatProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptFragmentGetter_Converter : JsonConverter<IScriptFragmentGetter>
{
  public override IScriptFragmentGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptFragmentGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptFragment");
    writer.WritePropertyName("FragmentName");
    JsonSerializer.Serialize(writer, value.FragmentName, options);
    writer.WritePropertyName("ScriptName");
    JsonSerializer.Serialize(writer, value.ScriptName, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class ScriptFragment_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptFragment>
{
  private IScriptFragmentGetter_Converter _getterConverter;
  public ScriptFragment_Converter(IScriptFragmentGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptFragment value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptFragmentGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptFragment Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptFragment();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FragmentName":
            retval.FragmentName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ScriptName":
            retval.ScriptName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptFragmentsGetter_Converter : JsonConverter<IScriptFragmentsGetter>
{
  public override IScriptFragmentsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptFragmentsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptFragments");
    writer.WritePropertyName("FileName");
    JsonSerializer.Serialize(writer, value.FileName, options);
    writer.WritePropertyName("OnBegin");
    JsonSerializer.Serialize(writer, value.OnBegin, options);
    writer.WritePropertyName("OnEnd");
    JsonSerializer.Serialize(writer, value.OnEnd, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class ScriptFragments_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptFragments>
{
  private IScriptFragmentsGetter_Converter _getterConverter;
  public ScriptFragments_Converter(IScriptFragmentsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptFragments value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptFragmentsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptFragments Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptFragments();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FileName":
            retval.FileName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "OnBegin":
            retval.OnBegin = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptFragment>(ref reader, options);
            break;
        case "OnEnd":
            retval.OnEnd = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptFragment>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptIntListPropertyGetter_Converter : JsonConverter<IScriptIntListPropertyGetter>
{
  public override IScriptIntListPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptIntListPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptIntListProperty");
    if (value.Data != default)
    {
      writer.WritePropertyName("Data");
      writer.WriteStartArray();
      foreach (var itm in value.Data)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Data");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class ScriptIntListProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptIntListProperty>
{
  private IScriptIntListPropertyGetter_Converter _getterConverter;
  public ScriptIntListProperty_Converter(IScriptIntListPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptIntListProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptIntListPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptIntListProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptIntListProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            ConverterHelpers.ReadExtendedList<Int32>(retval.Data, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptIntPropertyGetter_Converter : JsonConverter<IScriptIntPropertyGetter>
{
  public override IScriptIntPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptIntPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptIntProperty");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class ScriptIntProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptIntProperty>
{
  private IScriptIntPropertyGetter_Converter _getterConverter;
  public ScriptIntProperty_Converter(IScriptIntPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptIntProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptIntPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptIntProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptIntProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptObjectListPropertyGetter_Converter : JsonConverter<IScriptObjectListPropertyGetter>
{
  public override IScriptObjectListPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptObjectListPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptObjectListProperty");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    if (value.Objects != default)
    {
      writer.WritePropertyName("Objects");
      writer.WriteStartArray();
      foreach (var itm in value.Objects)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Objects");
    }
    writer.WriteEndObject();
  }
}
public class ScriptObjectListProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptObjectListProperty>
{
  private IScriptObjectListPropertyGetter_Converter _getterConverter;
  public ScriptObjectListProperty_Converter(IScriptObjectListPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptObjectListProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptObjectListPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptObjectListProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptObjectListProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Objects":
            ConverterHelpers.ReadExtendedList<ScriptObjectProperty>(retval.Objects, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptObjectPropertyGetter_Converter : JsonConverter<IScriptObjectPropertyGetter>
{
  public override IScriptObjectPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptObjectPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptObjectProperty");
    writer.WritePropertyName("Alias");
    JsonSerializer.Serialize(writer, value.Alias, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Object");
    JsonSerializer.Serialize(writer, value.Object, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WriteEndObject();
  }
}
public class ScriptObjectProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptObjectProperty>
{
  private IScriptObjectPropertyGetter_Converter _getterConverter;
  public ScriptObjectProperty_Converter(IScriptObjectPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptObjectProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptObjectPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptObjectProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptObjectProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Alias":
            retval.Alias = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Object":
            ConverterHelpers.ReadFormLink<ISkyrimMajorRecordGetter>(retval.Object, ref reader);
            break;
        case "Unused":
            retval.Unused = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptPropertyGetter_Converter : JsonConverter<IScriptPropertyGetter>
{
  public override IScriptPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptProperty");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class ScriptProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptProperty>
{
  private IScriptPropertyGetter_Converter _getterConverter;
  public ScriptProperty_Converter(IScriptPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptStringListPropertyGetter_Converter : JsonConverter<IScriptStringListPropertyGetter>
{
  public override IScriptStringListPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptStringListPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptStringListProperty");
    if (value.Data != default)
    {
      writer.WritePropertyName("Data");
      writer.WriteStartArray();
      foreach (var itm in value.Data)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Data");
    }
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class ScriptStringListProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptStringListProperty>
{
  private IScriptStringListPropertyGetter_Converter _getterConverter;
  public ScriptStringListProperty_Converter(IScriptStringListPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptStringListProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptStringListPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptStringListProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptStringListProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            ConverterHelpers.ReadExtendedList<String>(retval.Data, ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScriptStringPropertyGetter_Converter : JsonConverter<IScriptStringPropertyGetter>
{
  public override IScriptStringPropertyGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScriptStringPropertyGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ScriptStringProperty");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WriteEndObject();
  }
}
public class ScriptStringProperty_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ScriptStringProperty>
{
  private IScriptStringPropertyGetter_Converter _getterConverter;
  public ScriptStringProperty_Converter(IScriptStringPropertyGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ScriptStringProperty value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScriptStringPropertyGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ScriptStringProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ScriptStringProperty();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            retval.Data = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ScriptProperty.Flag>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IScrollGetter_Converter : JsonConverter<IScrollGetter>
{
  public override IScrollGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IScrollGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Scroll");
    writer.WritePropertyName("BaseCost");
    JsonSerializer.Serialize(writer, value.BaseCost, options);
    writer.WritePropertyName("CastDuration");
    JsonSerializer.Serialize(writer, value.CastDuration, options);
    writer.WritePropertyName("CastType");
    JsonSerializer.Serialize(writer, value.CastType, options);
    writer.WritePropertyName("ChargeTime");
    JsonSerializer.Serialize(writer, value.ChargeTime, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.Effects != default)
    {
      writer.WritePropertyName("Effects");
      writer.WriteStartArray();
      foreach (var itm in value.Effects)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Effects");
    }
    writer.WritePropertyName("EquipmentType");
    JsonSerializer.Serialize(writer, value.EquipmentType, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HalfCostPerk");
    JsonSerializer.Serialize(writer, value.HalfCostPerk, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MenuDisplayObject");
    JsonSerializer.Serialize(writer, value.MenuDisplayObject, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("Range");
    JsonSerializer.Serialize(writer, value.Range, options);
    writer.WritePropertyName("SPITDataTypeState");
    JsonSerializer.Serialize(writer, value.SPITDataTypeState, options);
    writer.WritePropertyName("TargetType");
    JsonSerializer.Serialize(writer, value.TargetType, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class Scroll_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Scroll>
{
  private IScrollGetter_Converter _getterConverter;
  public Scroll_Converter(IScrollGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Scroll value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IScrollGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Scroll Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Scroll();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BaseCost":
            retval.BaseCost = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "CastDuration":
            retval.CastDuration = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CastType":
            retval.CastType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CastType>(ref reader, options);
            break;
        case "ChargeTime":
            retval.ChargeTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Scroll.DATADataType>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Effects":
            ConverterHelpers.ReadExtendedList<Effect>(retval.Effects, ref reader, options);
            break;
        case "EquipmentType":
            ConverterHelpers.ReadFormLinkNullable<IEquipTypeGetter>(retval.EquipmentType, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SpellDataFlag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HalfCostPerk":
            ConverterHelpers.ReadFormLink<IPerkGetter>(retval.HalfCostPerk, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MenuDisplayObject":
            ConverterHelpers.ReadFormLinkNullable<IStaticGetter>(retval.MenuDisplayObject, ref reader);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "Range":
            retval.Range = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SPITDataTypeState":
            retval.SPITDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Scroll.SPITDataType>(ref reader, options);
            break;
        case "TargetType":
            retval.TargetType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.TargetType>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SpellType>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISeasonalIngredientProductionGetter_Converter : JsonConverter<ISeasonalIngredientProductionGetter>
{
  public override ISeasonalIngredientProductionGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISeasonalIngredientProductionGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SeasonalIngredientProduction");
    writer.WritePropertyName("Fall");
    JsonSerializer.Serialize(writer, value.Fall, options);
    writer.WritePropertyName("Spring");
    JsonSerializer.Serialize(writer, value.Spring, options);
    writer.WritePropertyName("Summer");
    JsonSerializer.Serialize(writer, value.Summer, options);
    writer.WritePropertyName("Winter");
    JsonSerializer.Serialize(writer, value.Winter, options);
    writer.WriteEndObject();
  }
}
public class SeasonalIngredientProduction_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SeasonalIngredientProduction>
{
  private ISeasonalIngredientProductionGetter_Converter _getterConverter;
  public SeasonalIngredientProduction_Converter(ISeasonalIngredientProductionGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SeasonalIngredientProduction value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISeasonalIngredientProductionGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SeasonalIngredientProduction Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SeasonalIngredientProduction();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Fall":
            retval.Fall = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Spring":
            retval.Spring = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Summer":
            retval.Summer = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Winter":
            retval.Winter = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IShaderParticleGeometryGetter_Converter : JsonConverter<IShaderParticleGeometryGetter>
{
  public override IShaderParticleGeometryGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IShaderParticleGeometryGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ShaderParticleGeometry");
    writer.WritePropertyName("BoxSize");
    JsonSerializer.Serialize(writer, value.BoxSize, options);
    writer.WritePropertyName("CenterOffsetMax");
    JsonSerializer.Serialize(writer, value.CenterOffsetMax, options);
    writer.WritePropertyName("CenterOffsetMin");
    JsonSerializer.Serialize(writer, value.CenterOffsetMin, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("GravityVelocity");
    JsonSerializer.Serialize(writer, value.GravityVelocity, options);
    writer.WritePropertyName("InitialRotationRange");
    JsonSerializer.Serialize(writer, value.InitialRotationRange, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("NumSubtexturesX");
    JsonSerializer.Serialize(writer, value.NumSubtexturesX, options);
    writer.WritePropertyName("NumSubtexturesY");
    JsonSerializer.Serialize(writer, value.NumSubtexturesY, options);
    writer.WritePropertyName("ParticleDensity");
    JsonSerializer.Serialize(writer, value.ParticleDensity, options);
    writer.WritePropertyName("ParticleSizeX");
    JsonSerializer.Serialize(writer, value.ParticleSizeX, options);
    writer.WritePropertyName("ParticleSizeY");
    JsonSerializer.Serialize(writer, value.ParticleSizeY, options);
    writer.WritePropertyName("ParticleTexture");
    JsonSerializer.Serialize(writer, value.ParticleTexture, options);
    writer.WritePropertyName("RotationVelocity");
    JsonSerializer.Serialize(writer, value.RotationVelocity, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class ShaderParticleGeometry_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ShaderParticleGeometry>
{
  private IShaderParticleGeometryGetter_Converter _getterConverter;
  public ShaderParticleGeometry_Converter(IShaderParticleGeometryGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ShaderParticleGeometry value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IShaderParticleGeometryGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ShaderParticleGeometry Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ShaderParticleGeometry();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BoxSize":
            retval.BoxSize = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "CenterOffsetMax":
            retval.CenterOffsetMax = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CenterOffsetMin":
            retval.CenterOffsetMin = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ShaderParticleGeometry.DATADataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "GravityVelocity":
            retval.GravityVelocity = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "InitialRotationRange":
            retval.InitialRotationRange = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "NumSubtexturesX":
            retval.NumSubtexturesX = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "NumSubtexturesY":
            retval.NumSubtexturesY = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "ParticleDensity":
            retval.ParticleDensity = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleSizeX":
            retval.ParticleSizeX = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleSizeY":
            retval.ParticleSizeY = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ParticleTexture":
            retval.ParticleTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "RotationVelocity":
            retval.RotationVelocity = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ShaderParticleGeometry.TypeEnum>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IShoutGetter_Converter : JsonConverter<IShoutGetter>
{
  public override IShoutGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IShoutGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Shout");
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MenuDisplayObject");
    JsonSerializer.Serialize(writer, value.MenuDisplayObject, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    if (value.WordsOfPower != default)
    {
      writer.WritePropertyName("WordsOfPower");
      writer.WriteStartArray();
      foreach (var itm in value.WordsOfPower)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("WordsOfPower");
    }
    writer.WriteEndObject();
  }
}
public class Shout_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Shout>
{
  private IShoutGetter_Converter _getterConverter;
  public Shout_Converter(IShoutGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Shout value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IShoutGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Shout Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Shout();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Shout.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MenuDisplayObject":
            ConverterHelpers.ReadFormLinkNullable<IStaticGetter>(retval.MenuDisplayObject, ref reader);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "WordsOfPower":
            ConverterHelpers.ReadExtendedList<ShoutWord>(retval.WordsOfPower, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IShoutWordGetter_Converter : JsonConverter<IShoutWordGetter>
{
  public override IShoutWordGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IShoutWordGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "ShoutWord");
    writer.WritePropertyName("RecoveryTime");
    JsonSerializer.Serialize(writer, value.RecoveryTime, options);
    writer.WritePropertyName("Spell");
    JsonSerializer.Serialize(writer, value.Spell, options);
    writer.WritePropertyName("Word");
    JsonSerializer.Serialize(writer, value.Word, options);
    writer.WriteEndObject();
  }
}
public class ShoutWord_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.ShoutWord>
{
  private IShoutWordGetter_Converter _getterConverter;
  public ShoutWord_Converter(IShoutWordGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.ShoutWord value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IShoutWordGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.ShoutWord Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.ShoutWord();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "RecoveryTime":
            retval.RecoveryTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Spell":
            ConverterHelpers.ReadFormLink<ISpellGetter>(retval.Spell, ref reader);
            break;
        case "Word":
            ConverterHelpers.ReadFormLink<IWordOfPowerGetter>(retval.Word, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISimpleModelGetter_Converter : JsonConverter<ISimpleModelGetter>
{
  public override ISimpleModelGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISimpleModelGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SimpleModel");
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("File");
    JsonSerializer.Serialize(writer, value.File, options);
    writer.WriteEndObject();
  }
}
public class SimpleModel_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SimpleModel>
{
  private ISimpleModelGetter_Converter _getterConverter;
  public SimpleModel_Converter(ISimpleModelGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SimpleModel value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISimpleModelGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SimpleModel Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SimpleModel();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Data":
            break;
        case "File":
            retval.File = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISkillBoostGetter_Converter : JsonConverter<ISkillBoostGetter>
{
  public override ISkillBoostGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISkillBoostGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SkillBoost");
    writer.WritePropertyName("Boost");
    JsonSerializer.Serialize(writer, value.Boost, options);
    writer.WritePropertyName("Skill");
    JsonSerializer.Serialize(writer, value.Skill, options);
    writer.WriteEndObject();
  }
}
public class SkillBoost_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SkillBoost>
{
  private ISkillBoostGetter_Converter _getterConverter;
  public SkillBoost_Converter(ISkillBoostGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SkillBoost value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISkillBoostGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SkillBoost Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SkillBoost();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Boost":
            retval.Boost = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "Skill":
            retval.Skill = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISkyrimModGetter_Converter : JsonConverter<ISkyrimModGetter>
{
  public override ISkyrimModGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISkyrimModGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SkyrimMod");
    writer.WritePropertyName("AcousticSpaces");
    JsonSerializer.Serialize(writer, value.AcousticSpaces, options);
    writer.WritePropertyName("Actions");
    JsonSerializer.Serialize(writer, value.Actions, options);
    writer.WritePropertyName("Activators");
    JsonSerializer.Serialize(writer, value.Activators, options);
    writer.WritePropertyName("ActorValueInformation");
    JsonSerializer.Serialize(writer, value.ActorValueInformation, options);
    writer.WritePropertyName("AddonNodes");
    JsonSerializer.Serialize(writer, value.AddonNodes, options);
    writer.WritePropertyName("AlchemicalApparatuses");
    JsonSerializer.Serialize(writer, value.AlchemicalApparatuses, options);
    writer.WritePropertyName("Ammunitions");
    JsonSerializer.Serialize(writer, value.Ammunitions, options);
    writer.WritePropertyName("AnimatedObjects");
    JsonSerializer.Serialize(writer, value.AnimatedObjects, options);
    writer.WritePropertyName("ArmorAddons");
    JsonSerializer.Serialize(writer, value.ArmorAddons, options);
    writer.WritePropertyName("Armors");
    JsonSerializer.Serialize(writer, value.Armors, options);
    writer.WritePropertyName("ArtObjects");
    JsonSerializer.Serialize(writer, value.ArtObjects, options);
    writer.WritePropertyName("AssociationTypes");
    JsonSerializer.Serialize(writer, value.AssociationTypes, options);
    writer.WritePropertyName("BodyParts");
    JsonSerializer.Serialize(writer, value.BodyParts, options);
    writer.WritePropertyName("Books");
    JsonSerializer.Serialize(writer, value.Books, options);
    writer.WritePropertyName("CameraPaths");
    JsonSerializer.Serialize(writer, value.CameraPaths, options);
    writer.WritePropertyName("CameraShots");
    JsonSerializer.Serialize(writer, value.CameraShots, options);
    writer.WritePropertyName("Cells");
    JsonSerializer.Serialize(writer, value.Cells, options);
    writer.WritePropertyName("Classes");
    JsonSerializer.Serialize(writer, value.Classes, options);
    writer.WritePropertyName("Climates");
    JsonSerializer.Serialize(writer, value.Climates, options);
    writer.WritePropertyName("CollisionLayers");
    JsonSerializer.Serialize(writer, value.CollisionLayers, options);
    writer.WritePropertyName("Colors");
    JsonSerializer.Serialize(writer, value.Colors, options);
    writer.WritePropertyName("CombatStyles");
    JsonSerializer.Serialize(writer, value.CombatStyles, options);
    writer.WritePropertyName("ConstructibleObjects");
    JsonSerializer.Serialize(writer, value.ConstructibleObjects, options);
    writer.WritePropertyName("Containers");
    JsonSerializer.Serialize(writer, value.Containers, options);
    writer.WritePropertyName("Debris");
    JsonSerializer.Serialize(writer, value.Debris, options);
    writer.WritePropertyName("DefaultObjectManagers");
    JsonSerializer.Serialize(writer, value.DefaultObjectManagers, options);
    writer.WritePropertyName("DialogBranches");
    JsonSerializer.Serialize(writer, value.DialogBranches, options);
    writer.WritePropertyName("DialogTopics");
    JsonSerializer.Serialize(writer, value.DialogTopics, options);
    writer.WritePropertyName("DialogViews");
    JsonSerializer.Serialize(writer, value.DialogViews, options);
    writer.WritePropertyName("Doors");
    JsonSerializer.Serialize(writer, value.Doors, options);
    writer.WritePropertyName("DualCastData");
    JsonSerializer.Serialize(writer, value.DualCastData, options);
    writer.WritePropertyName("EffectShaders");
    JsonSerializer.Serialize(writer, value.EffectShaders, options);
    writer.WritePropertyName("EncounterZones");
    JsonSerializer.Serialize(writer, value.EncounterZones, options);
    writer.WritePropertyName("EquipTypes");
    JsonSerializer.Serialize(writer, value.EquipTypes, options);
    writer.WritePropertyName("Explosions");
    JsonSerializer.Serialize(writer, value.Explosions, options);
    writer.WritePropertyName("Eyes");
    JsonSerializer.Serialize(writer, value.Eyes, options);
    writer.WritePropertyName("Factions");
    JsonSerializer.Serialize(writer, value.Factions, options);
    writer.WritePropertyName("Florae");
    JsonSerializer.Serialize(writer, value.Florae, options);
    writer.WritePropertyName("Footsteps");
    JsonSerializer.Serialize(writer, value.Footsteps, options);
    writer.WritePropertyName("FootstepSets");
    JsonSerializer.Serialize(writer, value.FootstepSets, options);
    writer.WritePropertyName("FormLists");
    JsonSerializer.Serialize(writer, value.FormLists, options);
    writer.WritePropertyName("Furniture");
    JsonSerializer.Serialize(writer, value.Furniture, options);
    writer.WritePropertyName("GameSettings");
    JsonSerializer.Serialize(writer, value.GameSettings, options);
    writer.WritePropertyName("Globals");
    JsonSerializer.Serialize(writer, value.Globals, options);
    writer.WritePropertyName("Grasses");
    JsonSerializer.Serialize(writer, value.Grasses, options);
    writer.WritePropertyName("Hairs");
    JsonSerializer.Serialize(writer, value.Hairs, options);
    writer.WritePropertyName("Hazards");
    JsonSerializer.Serialize(writer, value.Hazards, options);
    writer.WritePropertyName("HeadParts");
    JsonSerializer.Serialize(writer, value.HeadParts, options);
    writer.WritePropertyName("IdleAnimations");
    JsonSerializer.Serialize(writer, value.IdleAnimations, options);
    writer.WritePropertyName("IdleMarkers");
    JsonSerializer.Serialize(writer, value.IdleMarkers, options);
    writer.WritePropertyName("ImageSpaceAdapters");
    JsonSerializer.Serialize(writer, value.ImageSpaceAdapters, options);
    writer.WritePropertyName("ImageSpaces");
    JsonSerializer.Serialize(writer, value.ImageSpaces, options);
    writer.WritePropertyName("ImpactDataSets");
    JsonSerializer.Serialize(writer, value.ImpactDataSets, options);
    writer.WritePropertyName("Impacts");
    JsonSerializer.Serialize(writer, value.Impacts, options);
    writer.WritePropertyName("Ingestibles");
    JsonSerializer.Serialize(writer, value.Ingestibles, options);
    writer.WritePropertyName("Ingredients");
    JsonSerializer.Serialize(writer, value.Ingredients, options);
    writer.WritePropertyName("Keys");
    JsonSerializer.Serialize(writer, value.Keys, options);
    writer.WritePropertyName("Keywords");
    JsonSerializer.Serialize(writer, value.Keywords, options);
    writer.WritePropertyName("LandscapeTextures");
    JsonSerializer.Serialize(writer, value.LandscapeTextures, options);
    writer.WritePropertyName("LeveledItems");
    JsonSerializer.Serialize(writer, value.LeveledItems, options);
    writer.WritePropertyName("LeveledNpcs");
    JsonSerializer.Serialize(writer, value.LeveledNpcs, options);
    writer.WritePropertyName("LeveledSpells");
    JsonSerializer.Serialize(writer, value.LeveledSpells, options);
    writer.WritePropertyName("LightingTemplates");
    JsonSerializer.Serialize(writer, value.LightingTemplates, options);
    writer.WritePropertyName("Lights");
    JsonSerializer.Serialize(writer, value.Lights, options);
    writer.WritePropertyName("LoadScreens");
    JsonSerializer.Serialize(writer, value.LoadScreens, options);
    writer.WritePropertyName("LocationReferenceTypes");
    JsonSerializer.Serialize(writer, value.LocationReferenceTypes, options);
    writer.WritePropertyName("Locations");
    JsonSerializer.Serialize(writer, value.Locations, options);
    writer.WritePropertyName("MagicEffects");
    JsonSerializer.Serialize(writer, value.MagicEffects, options);
    writer.WritePropertyName("MaterialObjects");
    JsonSerializer.Serialize(writer, value.MaterialObjects, options);
    writer.WritePropertyName("MaterialTypes");
    JsonSerializer.Serialize(writer, value.MaterialTypes, options);
    writer.WritePropertyName("Messages");
    JsonSerializer.Serialize(writer, value.Messages, options);
    writer.WritePropertyName("MiscItems");
    JsonSerializer.Serialize(writer, value.MiscItems, options);
    writer.WritePropertyName("ModHeader");
    JsonSerializer.Serialize(writer, value.ModHeader, options);
    writer.WritePropertyName("MoveableStatics");
    JsonSerializer.Serialize(writer, value.MoveableStatics, options);
    writer.WritePropertyName("MovementTypes");
    JsonSerializer.Serialize(writer, value.MovementTypes, options);
    writer.WritePropertyName("MusicTracks");
    JsonSerializer.Serialize(writer, value.MusicTracks, options);
    writer.WritePropertyName("MusicTypes");
    JsonSerializer.Serialize(writer, value.MusicTypes, options);
    writer.WritePropertyName("NavigationMeshInfoMaps");
    JsonSerializer.Serialize(writer, value.NavigationMeshInfoMaps, options);
    writer.WritePropertyName("Npcs");
    JsonSerializer.Serialize(writer, value.Npcs, options);
    writer.WritePropertyName("ObjectEffects");
    JsonSerializer.Serialize(writer, value.ObjectEffects, options);
    writer.WritePropertyName("Outfits");
    JsonSerializer.Serialize(writer, value.Outfits, options);
    writer.WritePropertyName("Packages");
    JsonSerializer.Serialize(writer, value.Packages, options);
    writer.WritePropertyName("Perks");
    JsonSerializer.Serialize(writer, value.Perks, options);
    writer.WritePropertyName("Projectiles");
    JsonSerializer.Serialize(writer, value.Projectiles, options);
    writer.WritePropertyName("Quests");
    JsonSerializer.Serialize(writer, value.Quests, options);
    writer.WritePropertyName("Races");
    JsonSerializer.Serialize(writer, value.Races, options);
    writer.WritePropertyName("Regions");
    JsonSerializer.Serialize(writer, value.Regions, options);
    writer.WritePropertyName("Relationships");
    JsonSerializer.Serialize(writer, value.Relationships, options);
    writer.WritePropertyName("ReverbParameters");
    JsonSerializer.Serialize(writer, value.ReverbParameters, options);
    writer.WritePropertyName("Scenes");
    JsonSerializer.Serialize(writer, value.Scenes, options);
    writer.WritePropertyName("Scrolls");
    JsonSerializer.Serialize(writer, value.Scrolls, options);
    writer.WritePropertyName("ShaderParticleGeometries");
    JsonSerializer.Serialize(writer, value.ShaderParticleGeometries, options);
    writer.WritePropertyName("Shouts");
    JsonSerializer.Serialize(writer, value.Shouts, options);
    writer.WritePropertyName("SkyrimRelease");
    JsonSerializer.Serialize(writer, value.SkyrimRelease, options);
    writer.WritePropertyName("SoulGems");
    JsonSerializer.Serialize(writer, value.SoulGems, options);
    writer.WritePropertyName("SoundCategories");
    JsonSerializer.Serialize(writer, value.SoundCategories, options);
    writer.WritePropertyName("SoundDescriptors");
    JsonSerializer.Serialize(writer, value.SoundDescriptors, options);
    writer.WritePropertyName("SoundMarkers");
    JsonSerializer.Serialize(writer, value.SoundMarkers, options);
    writer.WritePropertyName("SoundOutputModels");
    JsonSerializer.Serialize(writer, value.SoundOutputModels, options);
    writer.WritePropertyName("Spells");
    JsonSerializer.Serialize(writer, value.Spells, options);
    writer.WritePropertyName("Statics");
    JsonSerializer.Serialize(writer, value.Statics, options);
    writer.WritePropertyName("StoryManagerBranchNodes");
    JsonSerializer.Serialize(writer, value.StoryManagerBranchNodes, options);
    writer.WritePropertyName("StoryManagerEventNodes");
    JsonSerializer.Serialize(writer, value.StoryManagerEventNodes, options);
    writer.WritePropertyName("StoryManagerQuestNodes");
    JsonSerializer.Serialize(writer, value.StoryManagerQuestNodes, options);
    writer.WritePropertyName("TalkingActivators");
    JsonSerializer.Serialize(writer, value.TalkingActivators, options);
    writer.WritePropertyName("TextureSets");
    JsonSerializer.Serialize(writer, value.TextureSets, options);
    writer.WritePropertyName("Trees");
    JsonSerializer.Serialize(writer, value.Trees, options);
    writer.WritePropertyName("VisualEffects");
    JsonSerializer.Serialize(writer, value.VisualEffects, options);
    writer.WritePropertyName("VoiceTypes");
    JsonSerializer.Serialize(writer, value.VoiceTypes, options);
    writer.WritePropertyName("VolumetricLightings");
    JsonSerializer.Serialize(writer, value.VolumetricLightings, options);
    writer.WritePropertyName("Waters");
    JsonSerializer.Serialize(writer, value.Waters, options);
    writer.WritePropertyName("Weapons");
    JsonSerializer.Serialize(writer, value.Weapons, options);
    writer.WritePropertyName("Weathers");
    JsonSerializer.Serialize(writer, value.Weathers, options);
    writer.WritePropertyName("WordsOfPower");
    JsonSerializer.Serialize(writer, value.WordsOfPower, options);
    writer.WritePropertyName("Worldspaces");
    JsonSerializer.Serialize(writer, value.Worldspaces, options);
    writer.WriteEndObject();
  }
}
public class SkyrimMod_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SkyrimMod>
{
  private ISkyrimModGetter_Converter _getterConverter;
  public SkyrimMod_Converter(ISkyrimModGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SkyrimMod value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISkyrimModGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SkyrimMod Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SkyrimMod();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AcousticSpaces":
            break;
        case "Actions":
            break;
        case "Activators":
            break;
        case "ActorValueInformation":
            break;
        case "AddonNodes":
            break;
        case "AlchemicalApparatuses":
            break;
        case "Ammunitions":
            break;
        case "AnimatedObjects":
            break;
        case "ArmorAddons":
            break;
        case "Armors":
            break;
        case "ArtObjects":
            break;
        case "AssociationTypes":
            break;
        case "BodyParts":
            break;
        case "Books":
            break;
        case "CameraPaths":
            break;
        case "CameraShots":
            break;
        case "CanUseLocalization":
            retval.CanUseLocalization = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Cells":
            break;
        case "Classes":
            break;
        case "Climates":
            break;
        case "CollisionLayers":
            break;
        case "Colors":
            break;
        case "CombatStyles":
            break;
        case "ConstructibleObjects":
            break;
        case "Containers":
            break;
        case "Debris":
            break;
        case "DefaultObjectManagers":
            break;
        case "DialogBranches":
            break;
        case "DialogTopics":
            break;
        case "DialogViews":
            break;
        case "Doors":
            break;
        case "DualCastData":
            break;
        case "EffectShaders":
            break;
        case "EncounterZones":
            break;
        case "EquipTypes":
            break;
        case "Explosions":
            break;
        case "Eyes":
            break;
        case "Factions":
            break;
        case "Florae":
            break;
        case "Footsteps":
            break;
        case "FootstepSets":
            break;
        case "FormLists":
            break;
        case "Furniture":
            break;
        case "GameRelease":
            retval.GameRelease = JsonSerializer.Deserialize<Mutagen.Bethesda.GameRelease>(ref reader, options);
            break;
        case "GameSettings":
            break;
        case "Globals":
            break;
        case "Grasses":
            break;
        case "Hairs":
            break;
        case "Hazards":
            break;
        case "HeadParts":
            break;
        case "IdleAnimations":
            break;
        case "IdleMarkers":
            break;
        case "ImageSpaceAdapters":
            break;
        case "ImageSpaces":
            break;
        case "ImpactDataSets":
            break;
        case "Impacts":
            break;
        case "Ingestibles":
            break;
        case "Ingredients":
            break;
        case "Keys":
            break;
        case "Keywords":
            break;
        case "LandscapeTextures":
            break;
        case "LeveledItems":
            break;
        case "LeveledNpcs":
            break;
        case "LeveledSpells":
            break;
        case "LightingTemplates":
            break;
        case "Lights":
            break;
        case "LoadScreens":
            break;
        case "LocationReferenceTypes":
            break;
        case "Locations":
            break;
        case "MagicEffects":
            break;
        case "MaterialObjects":
            break;
        case "MaterialTypes":
            break;
        case "Messages":
            break;
        case "MiscItems":
            break;
        case "ModHeader":
            retval.ModHeader = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimModHeader>(ref reader, options);
            break;
        case "ModKey":
            retval.ModKey = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.ModKey>(ref reader, options);
            break;
        case "MoveableStatics":
            break;
        case "MovementTypes":
            break;
        case "MusicTracks":
            break;
        case "MusicTypes":
            break;
        case "NavigationMeshInfoMaps":
            break;
        case "Npcs":
            break;
        case "ObjectEffects":
            break;
        case "Outfits":
            break;
        case "Packages":
            break;
        case "Perks":
            break;
        case "Projectiles":
            break;
        case "Quests":
            break;
        case "Races":
            break;
        case "Regions":
            break;
        case "Relationships":
            break;
        case "ReverbParameters":
            break;
        case "Scenes":
            break;
        case "Scrolls":
            break;
        case "ShaderParticleGeometries":
            break;
        case "Shouts":
            break;
        case "SkyrimRelease":
            retval.SkyrimRelease = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimRelease>(ref reader, options);
            break;
        case "SoulGems":
            break;
        case "SoundCategories":
            break;
        case "SoundDescriptors":
            break;
        case "SoundMarkers":
            break;
        case "SoundOutputModels":
            break;
        case "Spells":
            break;
        case "Statics":
            break;
        case "StoryManagerBranchNodes":
            break;
        case "StoryManagerEventNodes":
            break;
        case "StoryManagerQuestNodes":
            break;
        case "TalkingActivators":
            break;
        case "TextureSets":
            break;
        case "Trees":
            break;
        case "UsingLocalization":
            retval.UsingLocalization = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "VisualEffects":
            break;
        case "VoiceTypes":
            break;
        case "VolumetricLightings":
            break;
        case "Waters":
            break;
        case "Weapons":
            break;
        case "Weathers":
            break;
        case "WordsOfPower":
            break;
        case "Worldspaces":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISkyrimModHeaderGetter_Converter : JsonConverter<ISkyrimModHeaderGetter>
{
  public override ISkyrimModHeaderGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISkyrimModHeaderGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SkyrimModHeader");
    writer.WritePropertyName("Author");
    JsonSerializer.Serialize(writer, value.Author, options);
    writer.WritePropertyName("Deleted");
    JsonSerializer.Serialize(writer, value.Deleted, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormID");
    JsonSerializer.Serialize(writer, value.FormID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("INCC");
    JsonSerializer.Serialize(writer, value.INCC, options);
    writer.WritePropertyName("INTV");
    JsonSerializer.Serialize(writer, value.INTV, options);
    if (value.MasterReferences != default)
    {
      writer.WritePropertyName("MasterReferences");
      writer.WriteStartArray();
      foreach (var itm in value.MasterReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("MasterReferences");
    }
    if (value.OverriddenForms != default)
    {
      writer.WritePropertyName("OverriddenForms");
      writer.WriteStartArray();
      foreach (var itm in value.OverriddenForms)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("OverriddenForms");
    }
    writer.WritePropertyName("Stats");
    JsonSerializer.Serialize(writer, value.Stats, options);
    writer.WritePropertyName("TypeOffsets");
    JsonSerializer.Serialize(writer, value.TypeOffsets, options);
    writer.WritePropertyName("Version");
    JsonSerializer.Serialize(writer, value.Version, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WriteEndObject();
  }
}
public class SkyrimModHeader_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SkyrimModHeader>
{
  private ISkyrimModHeaderGetter_Converter _getterConverter;
  public SkyrimModHeader_Converter(ISkyrimModHeaderGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SkyrimModHeader value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISkyrimModHeaderGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SkyrimModHeader Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SkyrimModHeader();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Author":
            retval.Author = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Deleted":
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimModHeader.HeaderFlag>(ref reader, options);
            break;
        case "FormID":
            retval.FormID = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "INCC":
            retval.INCC = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "INTV":
            retval.INTV = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "MasterReferences":
            ConverterHelpers.ReadExtendedList<MasterReference>(retval.MasterReferences, ref reader, options);
            break;
        case "OverriddenForms":
            ConverterHelpers.ReadFormLinkList<ISkyrimMajorRecordGetter>(retval.OverriddenForms, ref reader);
            break;
        case "Stats":
            retval.Stats = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ModStats>(ref reader, options);
            break;
        case "TypeOffsets":
            break;
        case "Version":
            retval.Version = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISoulGemGetter_Converter : JsonConverter<ISoulGemGetter>
{
  public override ISoulGemGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISoulGemGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SoulGem");
    writer.WritePropertyName("ContainedSoul");
    JsonSerializer.Serialize(writer, value.ContainedSoul, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("LinkedTo");
    JsonSerializer.Serialize(writer, value.LinkedTo, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MaximumCapacity");
    JsonSerializer.Serialize(writer, value.MaximumCapacity, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class SoulGem_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SoulGem>
{
  private ISoulGemGetter_Converter _getterConverter;
  public SoulGem_Converter(ISoulGemGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SoulGem value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISoulGemGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SoulGem Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SoulGem();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ContainedSoul":
            retval.ContainedSoul = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoulGem.Level>(ref reader, options);
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoulGem.DATADataType>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "LinkedTo":
            ConverterHelpers.ReadFormLinkNullable<ISoulGemGetter>(retval.LinkedTo, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoulGem.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MaximumCapacity":
            retval.MaximumCapacity = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoulGem.Level>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISoundCategoryGetter_Converter : JsonConverter<ISoundCategoryGetter>
{
  public override ISoundCategoryGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISoundCategoryGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SoundCategory");
    writer.WritePropertyName("DefaultMenuVolume");
    JsonSerializer.Serialize(writer, value.DefaultMenuVolume, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Parent");
    JsonSerializer.Serialize(writer, value.Parent, options);
    writer.WritePropertyName("StaticVolumeMultiplier");
    JsonSerializer.Serialize(writer, value.StaticVolumeMultiplier, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class SoundCategory_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SoundCategory>
{
  private ISoundCategoryGetter_Converter _getterConverter;
  public SoundCategory_Converter(ISoundCategoryGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SoundCategory value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISoundCategoryGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SoundCategory Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SoundCategory();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DefaultMenuVolume":
            retval.DefaultMenuVolume = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Parent":
            ConverterHelpers.ReadFormLinkNullable<ISoundCategoryGetter>(retval.Parent, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "StaticVolumeMultiplier":
            retval.StaticVolumeMultiplier = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISoundDescriptorGetter_Converter : JsonConverter<ISoundDescriptorGetter>
{
  public override ISoundDescriptorGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISoundDescriptorGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SoundDescriptor");
    writer.WritePropertyName("AlternateSoundFor");
    JsonSerializer.Serialize(writer, value.AlternateSoundFor, options);
    writer.WritePropertyName("BNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.BNAMDataTypeState, options);
    writer.WritePropertyName("Category");
    JsonSerializer.Serialize(writer, value.Category, options);
    writer.WritePropertyName("CNAM");
    JsonSerializer.Serialize(writer, value.CNAM, options);
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LoopAndRumble");
    JsonSerializer.Serialize(writer, value.LoopAndRumble, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("OutputModel");
    JsonSerializer.Serialize(writer, value.OutputModel, options);
    writer.WritePropertyName("PercentFrequencyShift");
    JsonSerializer.Serialize(writer, value.PercentFrequencyShift, options);
    writer.WritePropertyName("PercentFrequencyVariance");
    JsonSerializer.Serialize(writer, value.PercentFrequencyVariance, options);
    writer.WritePropertyName("Priority");
    JsonSerializer.Serialize(writer, value.Priority, options);
    if (value.SoundFiles != default)
    {
      writer.WritePropertyName("SoundFiles");
      writer.WriteStartArray();
      foreach (var itm in value.SoundFiles)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("SoundFiles");
    }
    writer.WritePropertyName("StaticAttenuation");
    JsonSerializer.Serialize(writer, value.StaticAttenuation, options);
    writer.WritePropertyName("String");
    JsonSerializer.Serialize(writer, value.String, options);
    writer.WritePropertyName("Variance");
    JsonSerializer.Serialize(writer, value.Variance, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class SoundDescriptor_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SoundDescriptor>
{
  private ISoundDescriptorGetter_Converter _getterConverter;
  public SoundDescriptor_Converter(ISoundDescriptorGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SoundDescriptor value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISoundDescriptorGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SoundDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SoundDescriptor();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AlternateSoundFor":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.AlternateSoundFor, ref reader);
            break;
        case "BNAMDataTypeState":
            retval.BNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundDescriptor.BNAMDataType>(ref reader, options);
            break;
        case "Category":
            ConverterHelpers.ReadFormLinkNullable<ISoundCategoryGetter>(retval.Category, ref reader);
            break;
        case "CNAM":
            break;
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LoopAndRumble":
            retval.LoopAndRumble = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundLoopAndRumble>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "OutputModel":
            ConverterHelpers.ReadFormLinkNullable<ISoundOutputModelGetter>(retval.OutputModel, ref reader);
            break;
        case "PercentFrequencyShift":
            retval.PercentFrequencyShift = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "PercentFrequencyVariance":
            retval.PercentFrequencyVariance = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "Priority":
            retval.Priority = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SoundFiles":
            ConverterHelpers.ReadExtendedList<String>(retval.SoundFiles, ref reader, options);
            break;
        case "StaticAttenuation":
            retval.StaticAttenuation = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "String":
            retval.String = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Variance":
            retval.Variance = JsonSerializer.Deserialize<System.SByte>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISoundLoopAndRumbleGetter_Converter : JsonConverter<ISoundLoopAndRumbleGetter>
{
  public override ISoundLoopAndRumbleGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISoundLoopAndRumbleGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SoundLoopAndRumble");
    writer.WritePropertyName("Loop");
    JsonSerializer.Serialize(writer, value.Loop, options);
    writer.WritePropertyName("RumbleValues");
    JsonSerializer.Serialize(writer, value.RumbleValues, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class SoundLoopAndRumble_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SoundLoopAndRumble>
{
  private ISoundLoopAndRumbleGetter_Converter _getterConverter;
  public SoundLoopAndRumble_Converter(ISoundLoopAndRumbleGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SoundLoopAndRumble value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISoundLoopAndRumbleGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SoundLoopAndRumble Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SoundLoopAndRumble();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Loop":
            retval.Loop = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundDescriptor.LoopType>(ref reader, options);
            break;
        case "RumbleValues":
            retval.RumbleValues = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISoundMarkerGetter_Converter : JsonConverter<ISoundMarkerGetter>
{
  public override ISoundMarkerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISoundMarkerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SoundMarker");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FNAM");
    JsonSerializer.Serialize(writer, value.FNAM, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("SNDD");
    JsonSerializer.Serialize(writer, value.SNDD, options);
    writer.WritePropertyName("SoundDescriptor");
    JsonSerializer.Serialize(writer, value.SoundDescriptor, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class SoundMarker_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SoundMarker>
{
  private ISoundMarkerGetter_Converter _getterConverter;
  public SoundMarker_Converter(ISoundMarkerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SoundMarker value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISoundMarkerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SoundMarker Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SoundMarker();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FNAM":
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SNDD":
            break;
        case "SoundDescriptor":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.SoundDescriptor, ref reader);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISoundOutputAttenuationGetter_Converter : JsonConverter<ISoundOutputAttenuationGetter>
{
  public override ISoundOutputAttenuationGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISoundOutputAttenuationGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SoundOutputAttenuation");
    writer.WritePropertyName("Curve");
    JsonSerializer.Serialize(writer, value.Curve, options);
    writer.WritePropertyName("MaxDistance");
    JsonSerializer.Serialize(writer, value.MaxDistance, options);
    writer.WritePropertyName("MinDistance");
    JsonSerializer.Serialize(writer, value.MinDistance, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class SoundOutputAttenuation_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SoundOutputAttenuation>
{
  private ISoundOutputAttenuationGetter_Converter _getterConverter;
  public SoundOutputAttenuation_Converter(ISoundOutputAttenuationGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SoundOutputAttenuation value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISoundOutputAttenuationGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SoundOutputAttenuation Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SoundOutputAttenuation();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Curve":
            break;
        case "MaxDistance":
            retval.MaxDistance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MinDistance":
            retval.MinDistance = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown2":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISoundOutputChannelGetter_Converter : JsonConverter<ISoundOutputChannelGetter>
{
  public override ISoundOutputChannelGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISoundOutputChannelGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SoundOutputChannel");
    writer.WritePropertyName("BL");
    JsonSerializer.Serialize(writer, value.BL, options);
    writer.WritePropertyName("BR");
    JsonSerializer.Serialize(writer, value.BR, options);
    writer.WritePropertyName("C");
    JsonSerializer.Serialize(writer, value.C, options);
    writer.WritePropertyName("L");
    JsonSerializer.Serialize(writer, value.L, options);
    writer.WritePropertyName("LFE");
    JsonSerializer.Serialize(writer, value.LFE, options);
    writer.WritePropertyName("R");
    JsonSerializer.Serialize(writer, value.R, options);
    writer.WritePropertyName("RL");
    JsonSerializer.Serialize(writer, value.RL, options);
    writer.WritePropertyName("RR");
    JsonSerializer.Serialize(writer, value.RR, options);
    writer.WriteEndObject();
  }
}
public class SoundOutputChannel_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SoundOutputChannel>
{
  private ISoundOutputChannelGetter_Converter _getterConverter;
  public SoundOutputChannel_Converter(ISoundOutputChannelGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SoundOutputChannel value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISoundOutputChannelGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SoundOutputChannel Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SoundOutputChannel();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BL":
            retval.BL = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "BR":
            retval.BR = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "C":
            retval.C = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "L":
            retval.L = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "LFE":
            retval.LFE = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "R":
            retval.R = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "RL":
            retval.RL = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "RR":
            retval.RR = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISoundOutputChannelsGetter_Converter : JsonConverter<ISoundOutputChannelsGetter>
{
  public override ISoundOutputChannelsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISoundOutputChannelsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SoundOutputChannels");
    writer.WritePropertyName("Channel0");
    JsonSerializer.Serialize(writer, value.Channel0, options);
    writer.WritePropertyName("Channel1");
    JsonSerializer.Serialize(writer, value.Channel1, options);
    writer.WritePropertyName("Channel2");
    JsonSerializer.Serialize(writer, value.Channel2, options);
    writer.WriteEndObject();
  }
}
public class SoundOutputChannels_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SoundOutputChannels>
{
  private ISoundOutputChannelsGetter_Converter _getterConverter;
  public SoundOutputChannels_Converter(ISoundOutputChannelsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SoundOutputChannels value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISoundOutputChannelsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SoundOutputChannels Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SoundOutputChannels();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Channel0":
            retval.Channel0 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundOutputChannel>(ref reader, options);
            break;
        case "Channel1":
            retval.Channel1 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundOutputChannel>(ref reader, options);
            break;
        case "Channel2":
            retval.Channel2 = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundOutputChannel>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISoundOutputDataGetter_Converter : JsonConverter<ISoundOutputDataGetter>
{
  public override ISoundOutputDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISoundOutputDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SoundOutputData");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("ReverbSendPercent");
    JsonSerializer.Serialize(writer, value.ReverbSendPercent, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class SoundOutputData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SoundOutputData>
{
  private ISoundOutputDataGetter_Converter _getterConverter;
  public SoundOutputData_Converter(ISoundOutputDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SoundOutputData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISoundOutputDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SoundOutputData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SoundOutputData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundOutputModel.Flag>(ref reader, options);
            break;
        case "ReverbSendPercent":
            retval.ReverbSendPercent = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISoundOutputModelGetter_Converter : JsonConverter<ISoundOutputModelGetter>
{
  public override ISoundOutputModelGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISoundOutputModelGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SoundOutputModel");
    writer.WritePropertyName("Attenuation");
    JsonSerializer.Serialize(writer, value.Attenuation, options);
    writer.WritePropertyName("CNAM");
    JsonSerializer.Serialize(writer, value.CNAM, options);
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FNAM");
    JsonSerializer.Serialize(writer, value.FNAM, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("OutputChannels");
    JsonSerializer.Serialize(writer, value.OutputChannels, options);
    writer.WritePropertyName("SNAM");
    JsonSerializer.Serialize(writer, value.SNAM, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class SoundOutputModel_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SoundOutputModel>
{
  private ISoundOutputModelGetter_Converter _getterConverter;
  public SoundOutputModel_Converter(ISoundOutputModelGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SoundOutputModel value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISoundOutputModelGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SoundOutputModel Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SoundOutputModel();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Attenuation":
            retval.Attenuation = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundOutputAttenuation>(ref reader, options);
            break;
        case "CNAM":
            break;
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundOutputData>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FNAM":
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "OutputChannels":
            retval.OutputChannels = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SoundOutputChannels>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SNAM":
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<TypeEnum?>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISpeedOverridesGetter_Converter : JsonConverter<ISpeedOverridesGetter>
{
  public override ISpeedOverridesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISpeedOverridesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "SpeedOverrides");
    writer.WritePropertyName("BackRun");
    JsonSerializer.Serialize(writer, value.BackRun, options);
    writer.WritePropertyName("BackWalk");
    JsonSerializer.Serialize(writer, value.BackWalk, options);
    writer.WritePropertyName("ForwardRun");
    JsonSerializer.Serialize(writer, value.ForwardRun, options);
    writer.WritePropertyName("ForwardWalk");
    JsonSerializer.Serialize(writer, value.ForwardWalk, options);
    writer.WritePropertyName("LeftRun");
    JsonSerializer.Serialize(writer, value.LeftRun, options);
    writer.WritePropertyName("LeftWalk");
    JsonSerializer.Serialize(writer, value.LeftWalk, options);
    writer.WritePropertyName("RightRun");
    JsonSerializer.Serialize(writer, value.RightRun, options);
    writer.WritePropertyName("RightWalk");
    JsonSerializer.Serialize(writer, value.RightWalk, options);
    writer.WritePropertyName("RotateRun");
    JsonSerializer.Serialize(writer, value.RotateRun, options);
    writer.WritePropertyName("RotateWalk");
    JsonSerializer.Serialize(writer, value.RotateWalk, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class SpeedOverrides_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.SpeedOverrides>
{
  private ISpeedOverridesGetter_Converter _getterConverter;
  public SpeedOverrides_Converter(ISpeedOverridesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.SpeedOverrides value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISpeedOverridesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.SpeedOverrides Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.SpeedOverrides();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BackRun":
            retval.BackRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "BackWalk":
            retval.BackWalk = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ForwardRun":
            retval.ForwardRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "ForwardWalk":
            retval.ForwardWalk = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "LeftRun":
            retval.LeftRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "LeftWalk":
            retval.LeftWalk = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RightRun":
            retval.RightRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RightWalk":
            retval.RightWalk = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RotateRun":
            retval.RotateRun = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RotateWalk":
            retval.RotateWalk = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ISpellGetter_Converter : JsonConverter<ISpellGetter>
{
  public override ISpellGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ISpellGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Spell");
    writer.WritePropertyName("BaseCost");
    JsonSerializer.Serialize(writer, value.BaseCost, options);
    writer.WritePropertyName("CastDuration");
    JsonSerializer.Serialize(writer, value.CastDuration, options);
    writer.WritePropertyName("CastType");
    JsonSerializer.Serialize(writer, value.CastType, options);
    writer.WritePropertyName("ChargeTime");
    JsonSerializer.Serialize(writer, value.ChargeTime, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    if (value.Effects != default)
    {
      writer.WritePropertyName("Effects");
      writer.WriteStartArray();
      foreach (var itm in value.Effects)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Effects");
    }
    writer.WritePropertyName("EquipmentType");
    JsonSerializer.Serialize(writer, value.EquipmentType, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HalfCostPerk");
    JsonSerializer.Serialize(writer, value.HalfCostPerk, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MenuDisplayObject");
    JsonSerializer.Serialize(writer, value.MenuDisplayObject, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Range");
    JsonSerializer.Serialize(writer, value.Range, options);
    writer.WritePropertyName("SPITDataTypeState");
    JsonSerializer.Serialize(writer, value.SPITDataTypeState, options);
    writer.WritePropertyName("TargetType");
    JsonSerializer.Serialize(writer, value.TargetType, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Spell_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Spell>
{
  private ISpellGetter_Converter _getterConverter;
  public Spell_Converter(ISpellGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Spell value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ISpellGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Spell Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Spell();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BaseCost":
            retval.BaseCost = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "CastDuration":
            retval.CastDuration = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CastType":
            retval.CastType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CastType>(ref reader, options);
            break;
        case "ChargeTime":
            retval.ChargeTime = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Effects":
            ConverterHelpers.ReadExtendedList<Effect>(retval.Effects, ref reader, options);
            break;
        case "EquipmentType":
            ConverterHelpers.ReadFormLinkNullable<IEquipTypeGetter>(retval.EquipmentType, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SpellDataFlag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HalfCostPerk":
            ConverterHelpers.ReadFormLink<IPerkGetter>(retval.HalfCostPerk, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MenuDisplayObject":
            ConverterHelpers.ReadFormLinkNullable<IStaticGetter>(retval.MenuDisplayObject, ref reader);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "Range":
            retval.Range = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SPITDataTypeState":
            retval.SPITDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Spell.SPITDataType>(ref reader, options);
            break;
        case "TargetType":
            retval.TargetType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.TargetType>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SpellType>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IStaticGetter_Converter : JsonConverter<IStaticGetter>
{
  public override IStaticGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IStaticGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Static");
    writer.WritePropertyName("DNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.DNAMDataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("Lod");
    JsonSerializer.Serialize(writer, value.Lod, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Material");
    JsonSerializer.Serialize(writer, value.Material, options);
    writer.WritePropertyName("MaxAngle");
    JsonSerializer.Serialize(writer, value.MaxAngle, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class Static_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Static>
{
  private IStaticGetter_Converter _getterConverter;
  public Static_Converter(IStaticGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Static value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IStaticGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Static Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Static();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DNAMDataTypeState":
            retval.DNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Static.DNAMDataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Static.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Lod":
            retval.Lod = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Lod>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Static.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Material":
            ConverterHelpers.ReadFormLink<IMaterialObjectGetter>(retval.Material, ref reader);
            break;
        case "MaxAngle":
            retval.MaxAngle = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Unused":
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IStoryManagerBranchNodeGetter_Converter : JsonConverter<IStoryManagerBranchNodeGetter>
{
  public override IStoryManagerBranchNodeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IStoryManagerBranchNodeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "StoryManagerBranchNode");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Parent");
    JsonSerializer.Serialize(writer, value.Parent, options);
    writer.WritePropertyName("PreviousSibling");
    JsonSerializer.Serialize(writer, value.PreviousSibling, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("XNAM");
    JsonSerializer.Serialize(writer, value.XNAM, options);
    writer.WriteEndObject();
  }
}
public class StoryManagerBranchNode_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.StoryManagerBranchNode>
{
  private IStoryManagerBranchNodeGetter_Converter _getterConverter;
  public StoryManagerBranchNode_Converter(IStoryManagerBranchNodeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.StoryManagerBranchNode value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IStoryManagerBranchNodeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.StoryManagerBranchNode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.StoryManagerBranchNode();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Parent":
            ConverterHelpers.ReadFormLinkNullable<IAStoryManagerNodeGetter>(retval.Parent, ref reader);
            break;
        case "PreviousSibling":
            ConverterHelpers.ReadFormLinkNullable<IAStoryManagerNodeGetter>(retval.PreviousSibling, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "XNAM":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IStoryManagerEventNodeGetter_Converter : JsonConverter<IStoryManagerEventNodeGetter>
{
  public override IStoryManagerEventNodeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IStoryManagerEventNodeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "StoryManagerEventNode");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Parent");
    JsonSerializer.Serialize(writer, value.Parent, options);
    writer.WritePropertyName("PreviousSibling");
    JsonSerializer.Serialize(writer, value.PreviousSibling, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("XNAM");
    JsonSerializer.Serialize(writer, value.XNAM, options);
    writer.WriteEndObject();
  }
}
public class StoryManagerEventNode_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.StoryManagerEventNode>
{
  private IStoryManagerEventNodeGetter_Converter _getterConverter;
  public StoryManagerEventNode_Converter(IStoryManagerEventNodeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.StoryManagerEventNode value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IStoryManagerEventNodeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.StoryManagerEventNode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.StoryManagerEventNode();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Parent":
            ConverterHelpers.ReadFormLinkNullable<IAStoryManagerNodeGetter>(retval.Parent, ref reader);
            break;
        case "PreviousSibling":
            ConverterHelpers.ReadFormLinkNullable<IAStoryManagerNodeGetter>(retval.PreviousSibling, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<RecordType?>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "XNAM":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IStoryManagerQuestGetter_Converter : JsonConverter<IStoryManagerQuestGetter>
{
  public override IStoryManagerQuestGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IStoryManagerQuestGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "StoryManagerQuest");
    writer.WritePropertyName("FNAM");
    JsonSerializer.Serialize(writer, value.FNAM, options);
    writer.WritePropertyName("HoursUntilReset");
    JsonSerializer.Serialize(writer, value.HoursUntilReset, options);
    writer.WritePropertyName("Quest");
    JsonSerializer.Serialize(writer, value.Quest, options);
    writer.WriteEndObject();
  }
}
public class StoryManagerQuest_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.StoryManagerQuest>
{
  private IStoryManagerQuestGetter_Converter _getterConverter;
  public StoryManagerQuest_Converter(IStoryManagerQuestGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.StoryManagerQuest value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IStoryManagerQuestGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.StoryManagerQuest Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.StoryManagerQuest();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FNAM":
            break;
        case "HoursUntilReset":
            retval.HoursUntilReset = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Quest":
            ConverterHelpers.ReadFormLinkNullable<IQuestGetter>(retval.Quest, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IStoryManagerQuestNodeGetter_Converter : JsonConverter<IStoryManagerQuestNodeGetter>
{
  public override IStoryManagerQuestNodeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IStoryManagerQuestNodeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "StoryManagerQuestNode");
    if (value.Conditions != default)
    {
      writer.WritePropertyName("Conditions");
      writer.WriteStartArray();
      foreach (var itm in value.Conditions)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Conditions");
    }
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MaxConcurrentQuests");
    JsonSerializer.Serialize(writer, value.MaxConcurrentQuests, options);
    writer.WritePropertyName("MaxNumQuestsToRun");
    JsonSerializer.Serialize(writer, value.MaxNumQuestsToRun, options);
    writer.WritePropertyName("Parent");
    JsonSerializer.Serialize(writer, value.Parent, options);
    writer.WritePropertyName("PreviousSibling");
    JsonSerializer.Serialize(writer, value.PreviousSibling, options);
    if (value.Quests != default)
    {
      writer.WritePropertyName("Quests");
      writer.WriteStartArray();
      foreach (var itm in value.Quests)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Quests");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class StoryManagerQuestNode_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.StoryManagerQuestNode>
{
  private IStoryManagerQuestNodeGetter_Converter _getterConverter;
  public StoryManagerQuestNode_Converter(IStoryManagerQuestNodeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.StoryManagerQuestNode value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IStoryManagerQuestNodeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.StoryManagerQuestNode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.StoryManagerQuestNode();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Conditions":
            ConverterHelpers.ReadExtendedList<Condition>(retval.Conditions, ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<QuestFlag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MaxConcurrentQuests":
            retval.MaxConcurrentQuests = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "MaxNumQuestsToRun":
            retval.MaxNumQuestsToRun = JsonSerializer.Deserialize<UInt32?>(ref reader, options);
            break;
        case "Parent":
            ConverterHelpers.ReadFormLinkNullable<IAStoryManagerNodeGetter>(retval.Parent, ref reader);
            break;
        case "PreviousSibling":
            ConverterHelpers.ReadFormLinkNullable<IAStoryManagerNodeGetter>(retval.PreviousSibling, ref reader);
            break;
        case "Quests":
            ConverterHelpers.ReadExtendedList<StoryManagerQuest>(retval.Quests, ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ITalkingActivatorGetter_Converter : JsonConverter<ITalkingActivatorGetter>
{
  public override ITalkingActivatorGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ITalkingActivatorGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "TalkingActivator");
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FNAM");
    JsonSerializer.Serialize(writer, value.FNAM, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("LoopingSound");
    JsonSerializer.Serialize(writer, value.LoopingSound, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("PNAM");
    JsonSerializer.Serialize(writer, value.PNAM, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WritePropertyName("VoiceType");
    JsonSerializer.Serialize(writer, value.VoiceType, options);
    writer.WriteEndObject();
  }
}
public class TalkingActivator_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.TalkingActivator>
{
  private ITalkingActivatorGetter_Converter _getterConverter;
  public TalkingActivator_Converter(ITalkingActivatorGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.TalkingActivator value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ITalkingActivatorGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.TalkingActivator Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.TalkingActivator();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FNAM":
            retval.FNAM = JsonSerializer.Deserialize<Int16?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "LoopingSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundMarkerGetter>(retval.LoopingSound, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.TalkingActivator.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "PNAM":
            retval.PNAM = JsonSerializer.Deserialize<Int32?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        case "VoiceType":
            ConverterHelpers.ReadFormLinkNullable<IVoiceTypeGetter>(retval.VoiceType, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ITeleportDestinationGetter_Converter : JsonConverter<ITeleportDestinationGetter>
{
  public override ITeleportDestinationGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ITeleportDestinationGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "TeleportDestination");
    writer.WritePropertyName("Door");
    JsonSerializer.Serialize(writer, value.Door, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Position");
    JsonSerializer.Serialize(writer, value.Position, options);
    writer.WritePropertyName("Rotation");
    JsonSerializer.Serialize(writer, value.Rotation, options);
    writer.WriteEndObject();
  }
}
public class TeleportDestination_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.TeleportDestination>
{
  private ITeleportDestinationGetter_Converter _getterConverter;
  public TeleportDestination_Converter(ITeleportDestinationGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.TeleportDestination value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ITeleportDestinationGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.TeleportDestination Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.TeleportDestination();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Door":
            ConverterHelpers.ReadFormLink<IPlacedObjectGetter>(retval.Door, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.TeleportDestination.Flag>(ref reader, options);
            break;
        case "Position":
            retval.Position = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "Rotation":
            retval.Rotation = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ITextureSetGetter_Converter : JsonConverter<ITextureSetGetter>
{
  public override ITextureSetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ITextureSetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "TextureSet");
    writer.WritePropertyName("BacklightMaskOrSpecular");
    JsonSerializer.Serialize(writer, value.BacklightMaskOrSpecular, options);
    writer.WritePropertyName("Decal");
    JsonSerializer.Serialize(writer, value.Decal, options);
    writer.WritePropertyName("Diffuse");
    JsonSerializer.Serialize(writer, value.Diffuse, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Environment");
    JsonSerializer.Serialize(writer, value.Environment, options);
    writer.WritePropertyName("EnvironmentMaskOrSubsurfaceTint");
    JsonSerializer.Serialize(writer, value.EnvironmentMaskOrSubsurfaceTint, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("GlowOrDetailMap");
    JsonSerializer.Serialize(writer, value.GlowOrDetailMap, options);
    writer.WritePropertyName("Height");
    JsonSerializer.Serialize(writer, value.Height, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Multilayer");
    JsonSerializer.Serialize(writer, value.Multilayer, options);
    writer.WritePropertyName("NormalOrGloss");
    JsonSerializer.Serialize(writer, value.NormalOrGloss, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class TextureSet_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.TextureSet>
{
  private ITextureSetGetter_Converter _getterConverter;
  public TextureSet_Converter(ITextureSetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.TextureSet value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ITextureSetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.TextureSet Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.TextureSet();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BacklightMaskOrSpecular":
            retval.BacklightMaskOrSpecular = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Decal":
            retval.Decal = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Decal>(ref reader, options);
            break;
        case "Diffuse":
            retval.Diffuse = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Environment":
            retval.Environment = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EnvironmentMaskOrSubsurfaceTint":
            retval.EnvironmentMaskOrSubsurfaceTint = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "GlowOrDetailMap":
            retval.GlowOrDetailMap = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Height":
            retval.Height = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Multilayer":
            retval.Multilayer = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "NormalOrGloss":
            retval.NormalOrGloss = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ITintAssetsGetter_Converter : JsonConverter<ITintAssetsGetter>
{
  public override ITintAssetsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ITintAssetsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "TintAssets");
    writer.WritePropertyName("FileName");
    JsonSerializer.Serialize(writer, value.FileName, options);
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WritePropertyName("MaskType");
    JsonSerializer.Serialize(writer, value.MaskType, options);
    writer.WritePropertyName("PresetDefault");
    JsonSerializer.Serialize(writer, value.PresetDefault, options);
    if (value.Presets != default)
    {
      writer.WritePropertyName("Presets");
      writer.WriteStartArray();
      foreach (var itm in value.Presets)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Presets");
    }
    writer.WriteEndObject();
  }
}
public class TintAssets_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.TintAssets>
{
  private ITintAssetsGetter_Converter _getterConverter;
  public TintAssets_Converter(ITintAssetsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.TintAssets value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ITintAssetsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.TintAssets Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.TintAssets();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "FileName":
            retval.FileName = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Index":
            retval.Index = JsonSerializer.Deserialize<UInt16?>(ref reader, options);
            break;
        case "MaskType":
            retval.MaskType = JsonSerializer.Deserialize<TintMaskType?>(ref reader, options);
            break;
        case "PresetDefault":
            ConverterHelpers.ReadFormLinkNullable<IColorRecordGetter>(retval.PresetDefault, ref reader);
            break;
        case "Presets":
            ConverterHelpers.ReadExtendedList<TintPreset>(retval.Presets, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ITintLayerGetter_Converter : JsonConverter<ITintLayerGetter>
{
  public override ITintLayerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ITintLayerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "TintLayer");
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WritePropertyName("InterpolationValue");
    JsonSerializer.Serialize(writer, value.InterpolationValue, options);
    writer.WritePropertyName("Preset");
    JsonSerializer.Serialize(writer, value.Preset, options);
    writer.WriteEndObject();
  }
}
public class TintLayer_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.TintLayer>
{
  private ITintLayerGetter_Converter _getterConverter;
  public TintLayer_Converter(ITintLayerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.TintLayer value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ITintLayerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.TintLayer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.TintLayer();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Color":
            retval.Color = JsonSerializer.Deserialize<Color?>(ref reader, options);
            break;
        case "Index":
            retval.Index = JsonSerializer.Deserialize<UInt16?>(ref reader, options);
            break;
        case "InterpolationValue":
            retval.InterpolationValue = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Preset":
            retval.Preset = JsonSerializer.Deserialize<Int16?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ITintPresetGetter_Converter : JsonConverter<ITintPresetGetter>
{
  public override ITintPresetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ITintPresetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "TintPreset");
    writer.WritePropertyName("Color");
    JsonSerializer.Serialize(writer, value.Color, options);
    writer.WritePropertyName("DefaultValue");
    JsonSerializer.Serialize(writer, value.DefaultValue, options);
    writer.WritePropertyName("Index");
    JsonSerializer.Serialize(writer, value.Index, options);
    writer.WriteEndObject();
  }
}
public class TintPreset_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.TintPreset>
{
  private ITintPresetGetter_Converter _getterConverter;
  public TintPreset_Converter(ITintPresetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.TintPreset value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ITintPresetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.TintPreset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.TintPreset();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Color":
            ConverterHelpers.ReadFormLinkNullable<IColorRecordGetter>(retval.Color, ref reader);
            break;
        case "DefaultValue":
            retval.DefaultValue = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "Index":
            retval.Index = JsonSerializer.Deserialize<UInt16?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ITopicReferenceGetter_Converter : JsonConverter<ITopicReferenceGetter>
{
  public override ITopicReferenceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ITopicReferenceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "TopicReference");
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WriteEndObject();
  }
}
public class TopicReference_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.TopicReference>
{
  private ITopicReferenceGetter_Converter _getterConverter;
  public TopicReference_Converter(ITopicReferenceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.TopicReference value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ITopicReferenceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.TopicReference Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.TopicReference();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Reference":
            ConverterHelpers.ReadFormLink<IDialogTopicGetter>(retval.Reference, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ITopicReferenceSubtypeGetter_Converter : JsonConverter<ITopicReferenceSubtypeGetter>
{
  public override ITopicReferenceSubtypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ITopicReferenceSubtypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "TopicReferenceSubtype");
    writer.WritePropertyName("Subtype");
    JsonSerializer.Serialize(writer, value.Subtype, options);
    writer.WriteEndObject();
  }
}
public class TopicReferenceSubtype_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.TopicReferenceSubtype>
{
  private ITopicReferenceSubtypeGetter_Converter _getterConverter;
  public TopicReferenceSubtype_Converter(ITopicReferenceSubtypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.TopicReferenceSubtype value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ITopicReferenceSubtypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.TopicReferenceSubtype Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.TopicReferenceSubtype();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Subtype":
            retval.Subtype = JsonSerializer.Deserialize<Mutagen.Bethesda.Plugins.RecordType>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class ITreeGetter_Converter : JsonConverter<ITreeGetter>
{
  public override ITreeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, ITreeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Tree");
    writer.WritePropertyName("BranchFlexibility");
    JsonSerializer.Serialize(writer, value.BranchFlexibility, options);
    writer.WritePropertyName("CNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.CNAMDataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HarvestSound");
    JsonSerializer.Serialize(writer, value.HarvestSound, options);
    writer.WritePropertyName("Ingredient");
    JsonSerializer.Serialize(writer, value.Ingredient, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LeafAmplitude");
    JsonSerializer.Serialize(writer, value.LeafAmplitude, options);
    writer.WritePropertyName("LeafFrequency");
    JsonSerializer.Serialize(writer, value.LeafFrequency, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("Production");
    JsonSerializer.Serialize(writer, value.Production, options);
    writer.WritePropertyName("TrunkFlexibility");
    JsonSerializer.Serialize(writer, value.TrunkFlexibility, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class Tree_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Tree>
{
  private ITreeGetter_Converter _getterConverter;
  public Tree_Converter(ITreeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Tree value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (ITreeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Tree Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Tree();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BranchFlexibility":
            retval.BranchFlexibility = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CNAMDataTypeState":
            retval.CNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Tree.CNAMDataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HarvestSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.HarvestSound, ref reader);
            break;
        case "Ingredient":
            ConverterHelpers.ReadFormLinkNullable<IHarvestTargetGetter>(retval.Ingredient, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LeafAmplitude":
            retval.LeafAmplitude = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "LeafFrequency":
            retval.LeafFrequency = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Tree.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "Production":
            retval.Production = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SeasonalIngredientProduction>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "TrunkFlexibility":
            retval.TrunkFlexibility = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IVendorValuesGetter_Converter : JsonConverter<IVendorValuesGetter>
{
  public override IVendorValuesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IVendorValuesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "VendorValues");
    writer.WritePropertyName("EndHour");
    JsonSerializer.Serialize(writer, value.EndHour, options);
    writer.WritePropertyName("NotSellBuy");
    JsonSerializer.Serialize(writer, value.NotSellBuy, options);
    writer.WritePropertyName("OnlyBuysStolenItems");
    JsonSerializer.Serialize(writer, value.OnlyBuysStolenItems, options);
    writer.WritePropertyName("Radius");
    JsonSerializer.Serialize(writer, value.Radius, options);
    writer.WritePropertyName("StartHour");
    JsonSerializer.Serialize(writer, value.StartHour, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class VendorValues_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.VendorValues>
{
  private IVendorValuesGetter_Converter _getterConverter;
  public VendorValues_Converter(IVendorValuesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.VendorValues value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IVendorValuesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.VendorValues Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.VendorValues();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EndHour":
            retval.EndHour = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "NotSellBuy":
            retval.NotSellBuy = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "OnlyBuysStolenItems":
            retval.OnlyBuysStolenItems = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Radius":
            retval.Radius = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "StartHour":
            retval.StartHour = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IVirtualMachineAdapterGetter_Converter : JsonConverter<IVirtualMachineAdapterGetter>
{
  public override IVirtualMachineAdapterGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IVirtualMachineAdapterGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "VirtualMachineAdapter");
    writer.WritePropertyName("ObjectFormat");
    JsonSerializer.Serialize(writer, value.ObjectFormat, options);
    if (value.Scripts != default)
    {
      writer.WritePropertyName("Scripts");
      writer.WriteStartArray();
      foreach (var itm in value.Scripts)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Scripts");
    }
    writer.WritePropertyName("Version");
    JsonSerializer.Serialize(writer, value.Version, options);
    writer.WriteEndObject();
  }
}
public class VirtualMachineAdapter_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>
{
  private IVirtualMachineAdapterGetter_Converter _getterConverter;
  public VirtualMachineAdapter_Converter(IVirtualMachineAdapterGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.VirtualMachineAdapter value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IVirtualMachineAdapterGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.VirtualMachineAdapter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.VirtualMachineAdapter();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ObjectFormat":
            retval.ObjectFormat = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Scripts":
            ConverterHelpers.ReadExtendedList<ScriptEntry>(retval.Scripts, ref reader, options);
            break;
        case "Version":
            retval.Version = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IVisualEffectGetter_Converter : JsonConverter<IVisualEffectGetter>
{
  public override IVisualEffectGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IVisualEffectGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "VisualEffect");
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EffectArt");
    JsonSerializer.Serialize(writer, value.EffectArt, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Shader");
    JsonSerializer.Serialize(writer, value.Shader, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class VisualEffect_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.VisualEffect>
{
  private IVisualEffectGetter_Converter _getterConverter;
  public VisualEffect_Converter(IVisualEffectGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.VisualEffect value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IVisualEffectGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.VisualEffect Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.VisualEffect();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VisualEffect.DATADataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EffectArt":
            ConverterHelpers.ReadFormLink<IArtObjectGetter>(retval.EffectArt, ref reader);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VisualEffect.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Shader":
            ConverterHelpers.ReadFormLink<IEffectShaderGetter>(retval.Shader, ref reader);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IVoiceTypeGetter_Converter : JsonConverter<IVoiceTypeGetter>
{
  public override IVoiceTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IVoiceTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "VoiceType");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class VoiceType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.VoiceType>
{
  private IVoiceTypeGetter_Converter _getterConverter;
  public VoiceType_Converter(IVoiceTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.VoiceType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IVoiceTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.VoiceType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.VoiceType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VoiceType.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IVolumetricLightingGetter_Converter : JsonConverter<IVolumetricLightingGetter>
{
  public override IVolumetricLightingGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IVolumetricLightingGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "VolumetricLighting");
    writer.WritePropertyName("ColorB");
    JsonSerializer.Serialize(writer, value.ColorB, options);
    writer.WritePropertyName("ColorG");
    JsonSerializer.Serialize(writer, value.ColorG, options);
    writer.WritePropertyName("ColorR");
    JsonSerializer.Serialize(writer, value.ColorR, options);
    writer.WritePropertyName("CustomColorContribution");
    JsonSerializer.Serialize(writer, value.CustomColorContribution, options);
    writer.WritePropertyName("DensityContribution");
    JsonSerializer.Serialize(writer, value.DensityContribution, options);
    writer.WritePropertyName("DensityFallingSpeed");
    JsonSerializer.Serialize(writer, value.DensityFallingSpeed, options);
    writer.WritePropertyName("DensitySize");
    JsonSerializer.Serialize(writer, value.DensitySize, options);
    writer.WritePropertyName("DensityWindSpeed");
    JsonSerializer.Serialize(writer, value.DensityWindSpeed, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Intensity");
    JsonSerializer.Serialize(writer, value.Intensity, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("PhaseFunctionContribution");
    JsonSerializer.Serialize(writer, value.PhaseFunctionContribution, options);
    writer.WritePropertyName("PhaseFunctionScattering");
    JsonSerializer.Serialize(writer, value.PhaseFunctionScattering, options);
    writer.WritePropertyName("SamplingRepartitionRangeFactor");
    JsonSerializer.Serialize(writer, value.SamplingRepartitionRangeFactor, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class VolumetricLighting_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.VolumetricLighting>
{
  private IVolumetricLightingGetter_Converter _getterConverter;
  public VolumetricLighting_Converter(IVolumetricLightingGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.VolumetricLighting value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IVolumetricLightingGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.VolumetricLighting Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.VolumetricLighting();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "ColorB":
            retval.ColorB = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "ColorG":
            retval.ColorG = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "ColorR":
            retval.ColorR = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "CustomColorContribution":
            retval.CustomColorContribution = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "DensityContribution":
            retval.DensityContribution = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "DensityFallingSpeed":
            retval.DensityFallingSpeed = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "DensitySize":
            retval.DensitySize = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "DensityWindSpeed":
            retval.DensityWindSpeed = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Intensity":
            retval.Intensity = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "PhaseFunctionContribution":
            retval.PhaseFunctionContribution = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "PhaseFunctionScattering":
            retval.PhaseFunctionScattering = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SamplingRepartitionRangeFactor":
            retval.SamplingRepartitionRangeFactor = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWaterGetter_Converter : JsonConverter<IWaterGetter>
{
  public override IWaterGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWaterGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Water");
    writer.WritePropertyName("AngularVelocity");
    JsonSerializer.Serialize(writer, value.AngularVelocity, options);
    writer.WritePropertyName("DamagePerSecond");
    JsonSerializer.Serialize(writer, value.DamagePerSecond, options);
    writer.WritePropertyName("DeepColor");
    JsonSerializer.Serialize(writer, value.DeepColor, options);
    writer.WritePropertyName("DepthNormals");
    JsonSerializer.Serialize(writer, value.DepthNormals, options);
    writer.WritePropertyName("DepthReflections");
    JsonSerializer.Serialize(writer, value.DepthReflections, options);
    writer.WritePropertyName("DepthRefraction");
    JsonSerializer.Serialize(writer, value.DepthRefraction, options);
    writer.WritePropertyName("DepthSpecularLighting");
    JsonSerializer.Serialize(writer, value.DepthSpecularLighting, options);
    writer.WritePropertyName("DisplacementDampner");
    JsonSerializer.Serialize(writer, value.DisplacementDampner, options);
    writer.WritePropertyName("DisplacementFalloff");
    JsonSerializer.Serialize(writer, value.DisplacementFalloff, options);
    writer.WritePropertyName("DisplacementFoce");
    JsonSerializer.Serialize(writer, value.DisplacementFoce, options);
    writer.WritePropertyName("DisplacementStartingSize");
    JsonSerializer.Serialize(writer, value.DisplacementStartingSize, options);
    writer.WritePropertyName("DisplacementVelocity");
    JsonSerializer.Serialize(writer, value.DisplacementVelocity, options);
    writer.WritePropertyName("DNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.DNAMDataTypeState, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FlowNormalsNoiseTexture");
    JsonSerializer.Serialize(writer, value.FlowNormalsNoiseTexture, options);
    writer.WritePropertyName("FogAboveWaterAmount");
    JsonSerializer.Serialize(writer, value.FogAboveWaterAmount, options);
    writer.WritePropertyName("FogAboveWaterDistanceFarPlane");
    JsonSerializer.Serialize(writer, value.FogAboveWaterDistanceFarPlane, options);
    writer.WritePropertyName("FogAboveWaterDistanceNearPlane");
    JsonSerializer.Serialize(writer, value.FogAboveWaterDistanceNearPlane, options);
    writer.WritePropertyName("FogUnderWaterAmount");
    JsonSerializer.Serialize(writer, value.FogUnderWaterAmount, options);
    writer.WritePropertyName("FogUnderWaterDistanceFarPlane");
    JsonSerializer.Serialize(writer, value.FogUnderWaterDistanceFarPlane, options);
    writer.WritePropertyName("FogUnderWaterDistanceNearPlane");
    JsonSerializer.Serialize(writer, value.FogUnderWaterDistanceNearPlane, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("GNAM");
    JsonSerializer.Serialize(writer, value.GNAM, options);
    writer.WritePropertyName("ImageSpace");
    JsonSerializer.Serialize(writer, value.ImageSpace, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LinearVelocity");
    JsonSerializer.Serialize(writer, value.LinearVelocity, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Material");
    JsonSerializer.Serialize(writer, value.Material, options);
    writer.WritePropertyName("MNAM");
    JsonSerializer.Serialize(writer, value.MNAM, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("NoiseFalloff");
    JsonSerializer.Serialize(writer, value.NoiseFalloff, options);
    writer.WritePropertyName("NoiseFlowmapScale");
    JsonSerializer.Serialize(writer, value.NoiseFlowmapScale, options);
    writer.WritePropertyName("NoiseLayerOneAmplitudeScale");
    JsonSerializer.Serialize(writer, value.NoiseLayerOneAmplitudeScale, options);
    writer.WritePropertyName("NoiseLayerOneTexture");
    JsonSerializer.Serialize(writer, value.NoiseLayerOneTexture, options);
    writer.WritePropertyName("NoiseLayerOneUvScale");
    JsonSerializer.Serialize(writer, value.NoiseLayerOneUvScale, options);
    writer.WritePropertyName("NoiseLayerOneWindDirection");
    JsonSerializer.Serialize(writer, value.NoiseLayerOneWindDirection, options);
    writer.WritePropertyName("NoiseLayerOneWindSpeed");
    JsonSerializer.Serialize(writer, value.NoiseLayerOneWindSpeed, options);
    writer.WritePropertyName("NoiseLayerThreeAmplitudeScale");
    JsonSerializer.Serialize(writer, value.NoiseLayerThreeAmplitudeScale, options);
    writer.WritePropertyName("NoiseLayerThreeTexture");
    JsonSerializer.Serialize(writer, value.NoiseLayerThreeTexture, options);
    writer.WritePropertyName("NoiseLayerThreeUvScale");
    JsonSerializer.Serialize(writer, value.NoiseLayerThreeUvScale, options);
    writer.WritePropertyName("NoiseLayerThreeWindDirection");
    JsonSerializer.Serialize(writer, value.NoiseLayerThreeWindDirection, options);
    writer.WritePropertyName("NoiseLayerThreeWindSpeed");
    JsonSerializer.Serialize(writer, value.NoiseLayerThreeWindSpeed, options);
    writer.WritePropertyName("NoiseLayerTwoAmplitudeScale");
    JsonSerializer.Serialize(writer, value.NoiseLayerTwoAmplitudeScale, options);
    writer.WritePropertyName("NoiseLayerTwoTexture");
    JsonSerializer.Serialize(writer, value.NoiseLayerTwoTexture, options);
    writer.WritePropertyName("NoiseLayerTwoUvScale");
    JsonSerializer.Serialize(writer, value.NoiseLayerTwoUvScale, options);
    writer.WritePropertyName("NoiseLayerTwoWindDirection");
    JsonSerializer.Serialize(writer, value.NoiseLayerTwoWindDirection, options);
    writer.WritePropertyName("NoiseLayerTwoWindSpeed");
    JsonSerializer.Serialize(writer, value.NoiseLayerTwoWindSpeed, options);
    writer.WritePropertyName("Opacity");
    JsonSerializer.Serialize(writer, value.Opacity, options);
    writer.WritePropertyName("OpenSound");
    JsonSerializer.Serialize(writer, value.OpenSound, options);
    writer.WritePropertyName("ReflectionColor");
    JsonSerializer.Serialize(writer, value.ReflectionColor, options);
    writer.WritePropertyName("ShallowColor");
    JsonSerializer.Serialize(writer, value.ShallowColor, options);
    writer.WritePropertyName("SpecularBrightness");
    JsonSerializer.Serialize(writer, value.SpecularBrightness, options);
    writer.WritePropertyName("SpecularPower");
    JsonSerializer.Serialize(writer, value.SpecularPower, options);
    writer.WritePropertyName("SpecularRadius");
    JsonSerializer.Serialize(writer, value.SpecularRadius, options);
    writer.WritePropertyName("SpecularSunPower");
    JsonSerializer.Serialize(writer, value.SpecularSunPower, options);
    writer.WritePropertyName("SpecularSunSparkleMagnitude");
    JsonSerializer.Serialize(writer, value.SpecularSunSparkleMagnitude, options);
    writer.WritePropertyName("SpecularSunSparklePower");
    JsonSerializer.Serialize(writer, value.SpecularSunSparklePower, options);
    writer.WritePropertyName("SpecularSunSpecularMagnitude");
    JsonSerializer.Serialize(writer, value.SpecularSunSpecularMagnitude, options);
    writer.WritePropertyName("Spell");
    JsonSerializer.Serialize(writer, value.Spell, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WritePropertyName("Unknown3");
    JsonSerializer.Serialize(writer, value.Unknown3, options);
    writer.WritePropertyName("Unknown4");
    JsonSerializer.Serialize(writer, value.Unknown4, options);
    writer.WritePropertyName("Unknown5");
    JsonSerializer.Serialize(writer, value.Unknown5, options);
    writer.WritePropertyName("Unknown6");
    JsonSerializer.Serialize(writer, value.Unknown6, options);
    writer.WritePropertyName("Unknown7");
    JsonSerializer.Serialize(writer, value.Unknown7, options);
    if (value.UnusedNoisemaps != default)
    {
      writer.WritePropertyName("UnusedNoisemaps");
      writer.WriteStartArray();
      foreach (var itm in value.UnusedNoisemaps)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("UnusedNoisemaps");
    }
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("WaterFresnel");
    JsonSerializer.Serialize(writer, value.WaterFresnel, options);
    writer.WritePropertyName("WaterReflectionMagnitude");
    JsonSerializer.Serialize(writer, value.WaterReflectionMagnitude, options);
    writer.WritePropertyName("WaterReflectivity");
    JsonSerializer.Serialize(writer, value.WaterReflectivity, options);
    writer.WritePropertyName("WaterRefractionMagnitude");
    JsonSerializer.Serialize(writer, value.WaterRefractionMagnitude, options);
    writer.WriteEndObject();
  }
}
public class Water_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Water>
{
  private IWaterGetter_Converter _getterConverter;
  public Water_Converter(IWaterGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Water value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWaterGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Water Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Water();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AngularVelocity":
            retval.AngularVelocity = JsonSerializer.Deserialize<P3Float?>(ref reader, options);
            break;
        case "DamagePerSecond":
            retval.DamagePerSecond = JsonSerializer.Deserialize<UInt16?>(ref reader, options);
            break;
        case "DeepColor":
            retval.DeepColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "DepthNormals":
            retval.DepthNormals = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DepthReflections":
            retval.DepthReflections = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DepthRefraction":
            retval.DepthRefraction = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DepthSpecularLighting":
            retval.DepthSpecularLighting = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DisplacementDampner":
            retval.DisplacementDampner = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DisplacementFalloff":
            retval.DisplacementFalloff = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DisplacementFoce":
            retval.DisplacementFoce = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DisplacementStartingSize":
            retval.DisplacementStartingSize = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DisplacementVelocity":
            retval.DisplacementVelocity = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DNAMDataTypeState":
            retval.DNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Water.DNAMDataType>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Flag?>(ref reader, options);
            break;
        case "FlowNormalsNoiseTexture":
            retval.FlowNormalsNoiseTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FogAboveWaterAmount":
            retval.FogAboveWaterAmount = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogAboveWaterDistanceFarPlane":
            retval.FogAboveWaterDistanceFarPlane = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogAboveWaterDistanceNearPlane":
            retval.FogAboveWaterDistanceNearPlane = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogUnderWaterAmount":
            retval.FogUnderWaterAmount = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogUnderWaterDistanceFarPlane":
            retval.FogUnderWaterDistanceFarPlane = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogUnderWaterDistanceNearPlane":
            retval.FogUnderWaterDistanceNearPlane = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "GNAM":
            break;
        case "ImageSpace":
            ConverterHelpers.ReadFormLinkNullable<IImageSpaceAdapterGetter>(retval.ImageSpace, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LinearVelocity":
            retval.LinearVelocity = JsonSerializer.Deserialize<P3Float?>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Material":
            ConverterHelpers.ReadFormLinkNullable<IMaterialTypeGetter>(retval.Material, ref reader);
            break;
        case "MNAM":
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "NoiseFalloff":
            retval.NoiseFalloff = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseFlowmapScale":
            retval.NoiseFlowmapScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerOneAmplitudeScale":
            retval.NoiseLayerOneAmplitudeScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerOneTexture":
            retval.NoiseLayerOneTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "NoiseLayerOneUvScale":
            retval.NoiseLayerOneUvScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerOneWindDirection":
            retval.NoiseLayerOneWindDirection = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerOneWindSpeed":
            retval.NoiseLayerOneWindSpeed = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerThreeAmplitudeScale":
            retval.NoiseLayerThreeAmplitudeScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerThreeTexture":
            retval.NoiseLayerThreeTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "NoiseLayerThreeUvScale":
            retval.NoiseLayerThreeUvScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerThreeWindDirection":
            retval.NoiseLayerThreeWindDirection = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerThreeWindSpeed":
            retval.NoiseLayerThreeWindSpeed = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerTwoAmplitudeScale":
            retval.NoiseLayerTwoAmplitudeScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerTwoTexture":
            retval.NoiseLayerTwoTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "NoiseLayerTwoUvScale":
            retval.NoiseLayerTwoUvScale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerTwoWindDirection":
            retval.NoiseLayerTwoWindDirection = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NoiseLayerTwoWindSpeed":
            retval.NoiseLayerTwoWindSpeed = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Opacity":
            retval.Opacity = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "OpenSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.OpenSound, ref reader);
            break;
        case "ReflectionColor":
            retval.ReflectionColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "ShallowColor":
            retval.ShallowColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SpecularBrightness":
            retval.SpecularBrightness = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SpecularPower":
            retval.SpecularPower = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SpecularRadius":
            retval.SpecularRadius = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SpecularSunPower":
            retval.SpecularSunPower = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SpecularSunSparkleMagnitude":
            retval.SpecularSunSparkleMagnitude = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SpecularSunSparklePower":
            retval.SpecularSunSparklePower = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SpecularSunSpecularMagnitude":
            retval.SpecularSunSpecularMagnitude = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Spell":
            ConverterHelpers.ReadFormLinkNullable<ISpellGetter>(retval.Spell, ref reader);
            break;
        case "Unknown":
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown3":
            break;
        case "Unknown4":
            retval.Unknown4 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown5":
            break;
        case "Unknown6":
            retval.Unknown6 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown7":
            retval.Unknown7 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "UnusedNoisemaps":
            ConverterHelpers.ReadExtendedList<String>(retval.UnusedNoisemaps, ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "WaterFresnel":
            retval.WaterFresnel = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "WaterReflectionMagnitude":
            retval.WaterReflectionMagnitude = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "WaterReflectivity":
            retval.WaterReflectivity = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "WaterRefractionMagnitude":
            retval.WaterRefractionMagnitude = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWaterReflectionGetter_Converter : JsonConverter<IWaterReflectionGetter>
{
  public override IWaterReflectionGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWaterReflectionGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WaterReflection");
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WritePropertyName("Water");
    JsonSerializer.Serialize(writer, value.Water, options);
    writer.WriteEndObject();
  }
}
public class WaterReflection_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WaterReflection>
{
  private IWaterReflectionGetter_Converter _getterConverter;
  public WaterReflection_Converter(IWaterReflectionGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WaterReflection value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWaterReflectionGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WaterReflection Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WaterReflection();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WaterReflection.Flag>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WaterReflection.VersioningBreaks>(ref reader, options);
            break;
        case "Water":
            ConverterHelpers.ReadFormLink<IPlacedObjectGetter>(retval.Water, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWaterVelocityGetter_Converter : JsonConverter<IWaterVelocityGetter>
{
  public override IWaterVelocityGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWaterVelocityGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WaterVelocity");
    writer.WritePropertyName("Angle");
    JsonSerializer.Serialize(writer, value.Angle, options);
    writer.WritePropertyName("Offset");
    JsonSerializer.Serialize(writer, value.Offset, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WriteEndObject();
  }
}
public class WaterVelocity_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WaterVelocity>
{
  private IWaterVelocityGetter_Converter _getterConverter;
  public WaterVelocity_Converter(IWaterVelocityGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WaterVelocity value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWaterVelocityGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WaterVelocity Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WaterVelocity();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Angle":
            retval.Angle = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "Offset":
            retval.Offset = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown2":
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeaponGetter_Converter : JsonConverter<IWeaponGetter>
{
  public override IWeaponGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeaponGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Weapon");
    writer.WritePropertyName("AlternateBlockMaterial");
    JsonSerializer.Serialize(writer, value.AlternateBlockMaterial, options);
    writer.WritePropertyName("AttackFailSound");
    JsonSerializer.Serialize(writer, value.AttackFailSound, options);
    writer.WritePropertyName("AttackLoopSound");
    JsonSerializer.Serialize(writer, value.AttackLoopSound, options);
    writer.WritePropertyName("AttackSound");
    JsonSerializer.Serialize(writer, value.AttackSound, options);
    writer.WritePropertyName("AttackSound2D");
    JsonSerializer.Serialize(writer, value.AttackSound2D, options);
    writer.WritePropertyName("BasicStats");
    JsonSerializer.Serialize(writer, value.BasicStats, options);
    writer.WritePropertyName("BlockBashImpact");
    JsonSerializer.Serialize(writer, value.BlockBashImpact, options);
    writer.WritePropertyName("Critical");
    JsonSerializer.Serialize(writer, value.Critical, options);
    writer.WritePropertyName("Data");
    JsonSerializer.Serialize(writer, value.Data, options);
    writer.WritePropertyName("Description");
    JsonSerializer.Serialize(writer, value.Description, options);
    writer.WritePropertyName("Destructible");
    JsonSerializer.Serialize(writer, value.Destructible, options);
    writer.WritePropertyName("DetectionSoundLevel");
    JsonSerializer.Serialize(writer, value.DetectionSoundLevel, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EnchantmentAmount");
    JsonSerializer.Serialize(writer, value.EnchantmentAmount, options);
    writer.WritePropertyName("EquipmentType");
    JsonSerializer.Serialize(writer, value.EquipmentType, options);
    writer.WritePropertyName("EquipSound");
    JsonSerializer.Serialize(writer, value.EquipSound, options);
    writer.WritePropertyName("FirstPersonModel");
    JsonSerializer.Serialize(writer, value.FirstPersonModel, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("Icons");
    JsonSerializer.Serialize(writer, value.Icons, options);
    writer.WritePropertyName("IdleSound");
    JsonSerializer.Serialize(writer, value.IdleSound, options);
    writer.WritePropertyName("ImpactDataSet");
    JsonSerializer.Serialize(writer, value.ImpactDataSet, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    if (value.Keywords != default)
    {
      writer.WritePropertyName("Keywords");
      writer.WriteStartArray();
      foreach (var itm in value.Keywords)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Keywords");
    }
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Model");
    JsonSerializer.Serialize(writer, value.Model, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("ObjectEffect");
    JsonSerializer.Serialize(writer, value.ObjectEffect, options);
    writer.WritePropertyName("PickUpSound");
    JsonSerializer.Serialize(writer, value.PickUpSound, options);
    writer.WritePropertyName("PutDownSound");
    JsonSerializer.Serialize(writer, value.PutDownSound, options);
    writer.WritePropertyName("ScopeModel");
    JsonSerializer.Serialize(writer, value.ScopeModel, options);
    writer.WritePropertyName("Template");
    JsonSerializer.Serialize(writer, value.Template, options);
    writer.WritePropertyName("UnequipSound");
    JsonSerializer.Serialize(writer, value.UnequipSound, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VirtualMachineAdapter");
    JsonSerializer.Serialize(writer, value.VirtualMachineAdapter, options);
    writer.WriteEndObject();
  }
}
public class Weapon_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Weapon>
{
  private IWeaponGetter_Converter _getterConverter;
  public Weapon_Converter(IWeaponGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Weapon value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeaponGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Weapon Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Weapon();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AlternateBlockMaterial":
            ConverterHelpers.ReadFormLinkNullable<IMaterialTypeGetter>(retval.AlternateBlockMaterial, ref reader);
            break;
        case "AttackFailSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.AttackFailSound, ref reader);
            break;
        case "AttackLoopSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.AttackLoopSound, ref reader);
            break;
        case "AttackSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.AttackSound, ref reader);
            break;
        case "AttackSound2D":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.AttackSound2D, ref reader);
            break;
        case "BasicStats":
            retval.BasicStats = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeaponBasicStats>(ref reader, options);
            break;
        case "BlockBashImpact":
            ConverterHelpers.ReadFormLinkNullable<IImpactDataSetGetter>(retval.BlockBashImpact, ref reader);
            break;
        case "Critical":
            retval.Critical = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CriticalData>(ref reader, options);
            break;
        case "Data":
            retval.Data = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeaponData>(ref reader, options);
            break;
        case "Description":
            retval.Description = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Destructible":
            retval.Destructible = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Destructible>(ref reader, options);
            break;
        case "DetectionSoundLevel":
            retval.DetectionSoundLevel = JsonSerializer.Deserialize<SoundLevel?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EnchantmentAmount":
            retval.EnchantmentAmount = JsonSerializer.Deserialize<UInt16?>(ref reader, options);
            break;
        case "EquipmentType":
            ConverterHelpers.ReadFormLinkNullable<IEquipTypeGetter>(retval.EquipmentType, ref reader);
            break;
        case "EquipSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.EquipSound, ref reader);
            break;
        case "FirstPersonModel":
            ConverterHelpers.ReadFormLinkNullable<IStaticGetter>(retval.FirstPersonModel, ref reader);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Icons":
            retval.Icons = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Icons>(ref reader, options);
            break;
        case "IdleSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.IdleSound, ref reader);
            break;
        case "ImpactDataSet":
            ConverterHelpers.ReadFormLinkNullable<IImpactDataSetGetter>(retval.ImpactDataSet, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "Keywords":
            ConverterHelpers.ReadFormLinkList<IKeywordGetter>(retval.Keywords, ref reader);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Weapon.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Model":
            retval.Model = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ObjectBounds>(ref reader, options);
            break;
        case "ObjectEffect":
            ConverterHelpers.ReadFormLinkNullable<IEffectRecordGetter>(retval.ObjectEffect, ref reader);
            break;
        case "PickUpSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PickUpSound, ref reader);
            break;
        case "PutDownSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.PutDownSound, ref reader);
            break;
        case "ScopeModel":
            retval.ScopeModel = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Template":
            ConverterHelpers.ReadFormLinkNullable<IWeaponGetter>(retval.Template, ref reader);
            break;
        case "UnequipSound":
            ConverterHelpers.ReadFormLinkNullable<ISoundDescriptorGetter>(retval.UnequipSound, ref reader);
            break;
        case "Unused":
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VirtualMachineAdapter":
            retval.VirtualMachineAdapter = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.VirtualMachineAdapter>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeaponBasicStatsGetter_Converter : JsonConverter<IWeaponBasicStatsGetter>
{
  public override IWeaponBasicStatsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeaponBasicStatsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WeaponBasicStats");
    writer.WritePropertyName("Damage");
    JsonSerializer.Serialize(writer, value.Damage, options);
    writer.WritePropertyName("Value");
    JsonSerializer.Serialize(writer, value.Value, options);
    writer.WritePropertyName("Weight");
    JsonSerializer.Serialize(writer, value.Weight, options);
    writer.WriteEndObject();
  }
}
public class WeaponBasicStats_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WeaponBasicStats>
{
  private IWeaponBasicStatsGetter_Converter _getterConverter;
  public WeaponBasicStats_Converter(IWeaponBasicStatsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WeaponBasicStats value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeaponBasicStatsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WeaponBasicStats Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WeaponBasicStats();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Damage":
            retval.Damage = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "Value":
            retval.Value = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Weight":
            retval.Weight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeaponDataGetter_Converter : JsonConverter<IWeaponDataGetter>
{
  public override IWeaponDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeaponDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WeaponData");
    writer.WritePropertyName("AnimationAttackMult");
    JsonSerializer.Serialize(writer, value.AnimationAttackMult, options);
    writer.WritePropertyName("AnimationType");
    JsonSerializer.Serialize(writer, value.AnimationType, options);
    writer.WritePropertyName("AttackAnimation");
    JsonSerializer.Serialize(writer, value.AttackAnimation, options);
    writer.WritePropertyName("BaseVATStoHitChance");
    JsonSerializer.Serialize(writer, value.BaseVATStoHitChance, options);
    writer.WritePropertyName("EmbeddedWeaponAV");
    JsonSerializer.Serialize(writer, value.EmbeddedWeaponAV, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("NumProjectiles");
    JsonSerializer.Serialize(writer, value.NumProjectiles, options);
    writer.WritePropertyName("OnHit");
    JsonSerializer.Serialize(writer, value.OnHit, options);
    writer.WritePropertyName("RangeMax");
    JsonSerializer.Serialize(writer, value.RangeMax, options);
    writer.WritePropertyName("RangeMin");
    JsonSerializer.Serialize(writer, value.RangeMin, options);
    writer.WritePropertyName("Reach");
    JsonSerializer.Serialize(writer, value.Reach, options);
    writer.WritePropertyName("Resist");
    JsonSerializer.Serialize(writer, value.Resist, options);
    writer.WritePropertyName("RumbleDuration");
    JsonSerializer.Serialize(writer, value.RumbleDuration, options);
    writer.WritePropertyName("RumbleLeftMotorStrength");
    JsonSerializer.Serialize(writer, value.RumbleLeftMotorStrength, options);
    writer.WritePropertyName("RumbleRightMotorStrength");
    JsonSerializer.Serialize(writer, value.RumbleRightMotorStrength, options);
    writer.WritePropertyName("SightFOV");
    JsonSerializer.Serialize(writer, value.SightFOV, options);
    writer.WritePropertyName("Skill");
    JsonSerializer.Serialize(writer, value.Skill, options);
    writer.WritePropertyName("Speed");
    JsonSerializer.Serialize(writer, value.Speed, options);
    writer.WritePropertyName("Stagger");
    JsonSerializer.Serialize(writer, value.Stagger, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("Unknown2");
    JsonSerializer.Serialize(writer, value.Unknown2, options);
    writer.WritePropertyName("Unknown3");
    JsonSerializer.Serialize(writer, value.Unknown3, options);
    writer.WritePropertyName("Unknown4");
    JsonSerializer.Serialize(writer, value.Unknown4, options);
    writer.WritePropertyName("Unknown5");
    JsonSerializer.Serialize(writer, value.Unknown5, options);
    writer.WritePropertyName("Unused");
    JsonSerializer.Serialize(writer, value.Unused, options);
    writer.WritePropertyName("Unused2");
    JsonSerializer.Serialize(writer, value.Unused2, options);
    writer.WriteEndObject();
  }
}
public class WeaponData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WeaponData>
{
  private IWeaponDataGetter_Converter _getterConverter;
  public WeaponData_Converter(IWeaponDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WeaponData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeaponDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WeaponData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WeaponData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AnimationAttackMult":
            retval.AnimationAttackMult = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "AnimationType":
            retval.AnimationType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeaponAnimationType>(ref reader, options);
            break;
        case "AttackAnimation":
            retval.AttackAnimation = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeaponData.AttackAnimationType>(ref reader, options);
            break;
        case "BaseVATStoHitChance":
            retval.BaseVATStoHitChance = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "EmbeddedWeaponAV":
            retval.EmbeddedWeaponAV = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeaponData.Flag>(ref reader, options);
            break;
        case "NumProjectiles":
            retval.NumProjectiles = JsonSerializer.Deserialize<System.Byte>(ref reader, options);
            break;
        case "OnHit":
            retval.OnHit = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeaponData.OnHitType>(ref reader, options);
            break;
        case "RangeMax":
            retval.RangeMax = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RangeMin":
            retval.RangeMin = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Reach":
            retval.Reach = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Resist":
            retval.Resist = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.ActorValue>(ref reader, options);
            break;
        case "RumbleDuration":
            retval.RumbleDuration = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RumbleLeftMotorStrength":
            retval.RumbleLeftMotorStrength = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "RumbleRightMotorStrength":
            retval.RumbleRightMotorStrength = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "SightFOV":
            retval.SightFOV = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Skill":
            retval.Skill = JsonSerializer.Deserialize<Skill?>(ref reader, options);
            break;
        case "Speed":
            retval.Speed = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Stagger":
            retval.Stagger = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown2":
            retval.Unknown2 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown3":
            break;
        case "Unknown4":
            retval.Unknown4 = JsonSerializer.Deserialize<System.Int64>(ref reader, options);
            break;
        case "Unknown5":
            retval.Unknown5 = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unused":
            break;
        case "Unused2":
            retval.Unused2 = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeatherGetter_Converter : JsonConverter<IWeatherGetter>
{
  public override IWeatherGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeatherGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Weather");
    writer.WritePropertyName("AmbientColor");
    JsonSerializer.Serialize(writer, value.AmbientColor, options);
    writer.WritePropertyName("ANAM");
    JsonSerializer.Serialize(writer, value.ANAM, options);
    writer.WritePropertyName("Aurora");
    JsonSerializer.Serialize(writer, value.Aurora, options);
    writer.WritePropertyName("BNAM");
    JsonSerializer.Serialize(writer, value.BNAM, options);
    writer.WritePropertyName("CloudLodAmbientColor");
    JsonSerializer.Serialize(writer, value.CloudLodAmbientColor, options);
    writer.WritePropertyName("CloudLodDiffuseColor");
    JsonSerializer.Serialize(writer, value.CloudLodDiffuseColor, options);
    writer.WritePropertyName("Clouds");
    JsonSerializer.Serialize(writer, value.Clouds, options);
    writer.WritePropertyName("CloudTextures");
    JsonSerializer.Serialize(writer, value.CloudTextures, options);
    writer.WritePropertyName("CNAM");
    JsonSerializer.Serialize(writer, value.CNAM, options);
    writer.WritePropertyName("DATADataTypeState");
    JsonSerializer.Serialize(writer, value.DATADataTypeState, options);
    writer.WritePropertyName("DirectionalAmbientLightingColors");
    JsonSerializer.Serialize(writer, value.DirectionalAmbientLightingColors, options);
    writer.WritePropertyName("DNAM");
    JsonSerializer.Serialize(writer, value.DNAM, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EffectLightingColor");
    JsonSerializer.Serialize(writer, value.EffectLightingColor, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FNAMDataTypeState");
    JsonSerializer.Serialize(writer, value.FNAMDataTypeState, options);
    writer.WritePropertyName("FogDistanceDayFar");
    JsonSerializer.Serialize(writer, value.FogDistanceDayFar, options);
    writer.WritePropertyName("FogDistanceDayMax");
    JsonSerializer.Serialize(writer, value.FogDistanceDayMax, options);
    writer.WritePropertyName("FogDistanceDayNear");
    JsonSerializer.Serialize(writer, value.FogDistanceDayNear, options);
    writer.WritePropertyName("FogDistanceDayPower");
    JsonSerializer.Serialize(writer, value.FogDistanceDayPower, options);
    writer.WritePropertyName("FogDistanceNightFar");
    JsonSerializer.Serialize(writer, value.FogDistanceNightFar, options);
    writer.WritePropertyName("FogDistanceNightMax");
    JsonSerializer.Serialize(writer, value.FogDistanceNightMax, options);
    writer.WritePropertyName("FogDistanceNightNear");
    JsonSerializer.Serialize(writer, value.FogDistanceNightNear, options);
    writer.WritePropertyName("FogDistanceNightPower");
    JsonSerializer.Serialize(writer, value.FogDistanceNightPower, options);
    writer.WritePropertyName("FogFarColor");
    JsonSerializer.Serialize(writer, value.FogFarColor, options);
    writer.WritePropertyName("FogNearColor");
    JsonSerializer.Serialize(writer, value.FogNearColor, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HorizonColor");
    JsonSerializer.Serialize(writer, value.HorizonColor, options);
    writer.WritePropertyName("ImageSpaces");
    JsonSerializer.Serialize(writer, value.ImageSpaces, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LightningColor");
    JsonSerializer.Serialize(writer, value.LightningColor, options);
    writer.WritePropertyName("LNAM");
    JsonSerializer.Serialize(writer, value.LNAM, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MoonGlareColor");
    JsonSerializer.Serialize(writer, value.MoonGlareColor, options);
    writer.WritePropertyName("NAM0DataTypeState");
    JsonSerializer.Serialize(writer, value.NAM0DataTypeState, options);
    writer.WritePropertyName("NAM2");
    JsonSerializer.Serialize(writer, value.NAM2, options);
    writer.WritePropertyName("NAM3");
    JsonSerializer.Serialize(writer, value.NAM3, options);
    writer.WritePropertyName("ONAM");
    JsonSerializer.Serialize(writer, value.ONAM, options);
    writer.WritePropertyName("Precipitation");
    JsonSerializer.Serialize(writer, value.Precipitation, options);
    writer.WritePropertyName("PrecipitationBeginFadeIn");
    JsonSerializer.Serialize(writer, value.PrecipitationBeginFadeIn, options);
    writer.WritePropertyName("PrecipitationEndFadeOut");
    JsonSerializer.Serialize(writer, value.PrecipitationEndFadeOut, options);
    writer.WritePropertyName("SkyLowerColor");
    JsonSerializer.Serialize(writer, value.SkyLowerColor, options);
    if (value.SkyStatics != default)
    {
      writer.WritePropertyName("SkyStatics");
      writer.WriteStartArray();
      foreach (var itm in value.SkyStatics)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("SkyStatics");
    }
    writer.WritePropertyName("SkyStaticsColor");
    JsonSerializer.Serialize(writer, value.SkyStaticsColor, options);
    writer.WritePropertyName("SkyUpperColor");
    JsonSerializer.Serialize(writer, value.SkyUpperColor, options);
    if (value.Sounds != default)
    {
      writer.WritePropertyName("Sounds");
      writer.WriteStartArray();
      foreach (var itm in value.Sounds)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Sounds");
    }
    writer.WritePropertyName("StarsColor");
    JsonSerializer.Serialize(writer, value.StarsColor, options);
    writer.WritePropertyName("SunColor");
    JsonSerializer.Serialize(writer, value.SunColor, options);
    writer.WritePropertyName("SunDamage");
    JsonSerializer.Serialize(writer, value.SunDamage, options);
    writer.WritePropertyName("SunGlare");
    JsonSerializer.Serialize(writer, value.SunGlare, options);
    writer.WritePropertyName("SunGlareColor");
    JsonSerializer.Serialize(writer, value.SunGlareColor, options);
    writer.WritePropertyName("SunGlareLensFlare");
    JsonSerializer.Serialize(writer, value.SunGlareLensFlare, options);
    writer.WritePropertyName("SunlightColor");
    JsonSerializer.Serialize(writer, value.SunlightColor, options);
    writer.WritePropertyName("ThunderLightningBeginFadeIn");
    JsonSerializer.Serialize(writer, value.ThunderLightningBeginFadeIn, options);
    writer.WritePropertyName("ThunderLightningEndFadeOut");
    JsonSerializer.Serialize(writer, value.ThunderLightningEndFadeOut, options);
    writer.WritePropertyName("ThunderLightningFrequency");
    JsonSerializer.Serialize(writer, value.ThunderLightningFrequency, options);
    writer.WritePropertyName("TransDelta");
    JsonSerializer.Serialize(writer, value.TransDelta, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WritePropertyName("UnknownColor");
    JsonSerializer.Serialize(writer, value.UnknownColor, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("VisualEffect");
    JsonSerializer.Serialize(writer, value.VisualEffect, options);
    writer.WritePropertyName("VisualEffectBegin");
    JsonSerializer.Serialize(writer, value.VisualEffectBegin, options);
    writer.WritePropertyName("VisualEffectEnd");
    JsonSerializer.Serialize(writer, value.VisualEffectEnd, options);
    writer.WritePropertyName("VolumetricLighting");
    JsonSerializer.Serialize(writer, value.VolumetricLighting, options);
    writer.WritePropertyName("WaterMultiplierColor");
    JsonSerializer.Serialize(writer, value.WaterMultiplierColor, options);
    writer.WritePropertyName("WindDirection");
    JsonSerializer.Serialize(writer, value.WindDirection, options);
    writer.WritePropertyName("WindDirectionRange");
    JsonSerializer.Serialize(writer, value.WindDirectionRange, options);
    writer.WritePropertyName("WindSpeed");
    JsonSerializer.Serialize(writer, value.WindSpeed, options);
    writer.WriteEndObject();
  }
}
public class Weather_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Weather>
{
  private IWeatherGetter_Converter _getterConverter;
  public Weather_Converter(IWeatherGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Weather value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeatherGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Weather Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Weather();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "AmbientColor":
            retval.AmbientColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "ANAM":
            break;
        case "Aurora":
            retval.Aurora = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "BNAM":
            break;
        case "CloudLodAmbientColor":
            retval.CloudLodAmbientColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "CloudLodDiffuseColor":
            retval.CloudLodDiffuseColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "Clouds":
            retval.Clouds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.CloudLayer[]>(ref reader, options);
            break;
        case "CloudTextures":
            retval.CloudTextures = JsonSerializer.Deserialize<System.String[]>(ref reader, options);
            break;
        case "CNAM":
            break;
        case "DATADataTypeState":
            retval.DATADataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Weather.DATADataType>(ref reader, options);
            break;
        case "DirectionalAmbientLightingColors":
            retval.DirectionalAmbientLightingColors = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherAmbientColorSet>(ref reader, options);
            break;
        case "DNAM":
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EffectLightingColor":
            retval.EffectLightingColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Weather.Flag>(ref reader, options);
            break;
        case "FNAMDataTypeState":
            retval.FNAMDataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Weather.FNAMDataType>(ref reader, options);
            break;
        case "FogDistanceDayFar":
            retval.FogDistanceDayFar = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogDistanceDayMax":
            retval.FogDistanceDayMax = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogDistanceDayNear":
            retval.FogDistanceDayNear = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogDistanceDayPower":
            retval.FogDistanceDayPower = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogDistanceNightFar":
            retval.FogDistanceNightFar = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogDistanceNightMax":
            retval.FogDistanceNightMax = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogDistanceNightNear":
            retval.FogDistanceNightNear = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogDistanceNightPower":
            retval.FogDistanceNightPower = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "FogFarColor":
            retval.FogFarColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "FogNearColor":
            retval.FogNearColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HorizonColor":
            retval.HorizonColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "ImageSpaces":
            retval.ImageSpaces = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherImageSpaces>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LightningColor":
            retval.LightningColor = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "LNAM":
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MoonGlareColor":
            retval.MoonGlareColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "NAM0DataTypeState":
            retval.NAM0DataTypeState = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Weather.NAM0DataType>(ref reader, options);
            break;
        case "NAM2":
            break;
        case "NAM3":
            break;
        case "ONAM":
            break;
        case "Precipitation":
            ConverterHelpers.ReadFormLinkNullable<IShaderParticleGeometryGetter>(retval.Precipitation, ref reader);
            break;
        case "PrecipitationBeginFadeIn":
            retval.PrecipitationBeginFadeIn = JsonSerializer.Deserialize<Noggog.Percent>(ref reader, options);
            break;
        case "PrecipitationEndFadeOut":
            retval.PrecipitationEndFadeOut = JsonSerializer.Deserialize<Noggog.Percent>(ref reader, options);
            break;
        case "SkyLowerColor":
            retval.SkyLowerColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SkyStatics":
            ConverterHelpers.ReadFormLinkList<IStaticGetter>(retval.SkyStatics, ref reader);
            break;
        case "SkyStaticsColor":
            retval.SkyStaticsColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "SkyUpperColor":
            retval.SkyUpperColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "Sounds":
            ConverterHelpers.ReadExtendedList<WeatherSound>(retval.Sounds, ref reader, options);
            break;
        case "StarsColor":
            retval.StarsColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "SunColor":
            retval.SunColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "SunDamage":
            retval.SunDamage = JsonSerializer.Deserialize<Noggog.Percent>(ref reader, options);
            break;
        case "SunGlare":
            retval.SunGlare = JsonSerializer.Deserialize<Noggog.Percent>(ref reader, options);
            break;
        case "SunGlareColor":
            retval.SunGlareColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "SunGlareLensFlare":
            ConverterHelpers.ReadFormLinkNullable<ILensFlareGetter>(retval.SunGlareLensFlare, ref reader);
            break;
        case "SunlightColor":
            retval.SunlightColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "ThunderLightningBeginFadeIn":
            retval.ThunderLightningBeginFadeIn = JsonSerializer.Deserialize<Noggog.Percent>(ref reader, options);
            break;
        case "ThunderLightningEndFadeOut":
            retval.ThunderLightningEndFadeOut = JsonSerializer.Deserialize<Noggog.Percent>(ref reader, options);
            break;
        case "ThunderLightningFrequency":
            retval.ThunderLightningFrequency = JsonSerializer.Deserialize<Noggog.Percent>(ref reader, options);
            break;
        case "TransDelta":
            retval.TransDelta = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "UnknownColor":
            retval.UnknownColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "VisualEffect":
            ConverterHelpers.ReadFormLink<IVisualEffectGetter>(retval.VisualEffect, ref reader);
            break;
        case "VisualEffectBegin":
            retval.VisualEffectBegin = JsonSerializer.Deserialize<Noggog.Percent>(ref reader, options);
            break;
        case "VisualEffectEnd":
            retval.VisualEffectEnd = JsonSerializer.Deserialize<Noggog.Percent>(ref reader, options);
            break;
        case "VolumetricLighting":
            retval.VolumetricLighting = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherVolumetricLighting>(ref reader, options);
            break;
        case "WaterMultiplierColor":
            retval.WaterMultiplierColor = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherColor>(ref reader, options);
            break;
        case "WindDirection":
            retval.WindDirection = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "WindDirectionRange":
            retval.WindDirectionRange = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "WindSpeed":
            retval.WindSpeed = JsonSerializer.Deserialize<Noggog.Percent>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeatherAlphaGetter_Converter : JsonConverter<IWeatherAlphaGetter>
{
  public override IWeatherAlphaGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeatherAlphaGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WeatherAlpha");
    writer.WritePropertyName("Day");
    JsonSerializer.Serialize(writer, value.Day, options);
    writer.WritePropertyName("Night");
    JsonSerializer.Serialize(writer, value.Night, options);
    writer.WritePropertyName("Sunrise");
    JsonSerializer.Serialize(writer, value.Sunrise, options);
    writer.WritePropertyName("Sunset");
    JsonSerializer.Serialize(writer, value.Sunset, options);
    writer.WriteEndObject();
  }
}
public class WeatherAlpha_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WeatherAlpha>
{
  private IWeatherAlphaGetter_Converter _getterConverter;
  public WeatherAlpha_Converter(IWeatherAlphaGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WeatherAlpha value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeatherAlphaGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WeatherAlpha Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WeatherAlpha();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Day":
            retval.Day = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Night":
            retval.Night = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Sunrise":
            retval.Sunrise = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "Sunset":
            retval.Sunset = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeatherAmbientColorSetGetter_Converter : JsonConverter<IWeatherAmbientColorSetGetter>
{
  public override IWeatherAmbientColorSetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeatherAmbientColorSetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WeatherAmbientColorSet");
    writer.WritePropertyName("Day");
    JsonSerializer.Serialize(writer, value.Day, options);
    writer.WritePropertyName("Night");
    JsonSerializer.Serialize(writer, value.Night, options);
    writer.WritePropertyName("Sunrise");
    JsonSerializer.Serialize(writer, value.Sunrise, options);
    writer.WritePropertyName("Sunset");
    JsonSerializer.Serialize(writer, value.Sunset, options);
    writer.WriteEndObject();
  }
}
public class WeatherAmbientColorSet_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WeatherAmbientColorSet>
{
  private IWeatherAmbientColorSetGetter_Converter _getterConverter;
  public WeatherAmbientColorSet_Converter(IWeatherAmbientColorSetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WeatherAmbientColorSet value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeatherAmbientColorSetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WeatherAmbientColorSet Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WeatherAmbientColorSet();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Day":
            retval.Day = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AmbientColors>(ref reader, options);
            break;
        case "Night":
            retval.Night = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AmbientColors>(ref reader, options);
            break;
        case "Sunrise":
            retval.Sunrise = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AmbientColors>(ref reader, options);
            break;
        case "Sunset":
            retval.Sunset = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.AmbientColors>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeatherColorGetter_Converter : JsonConverter<IWeatherColorGetter>
{
  public override IWeatherColorGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeatherColorGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WeatherColor");
    writer.WritePropertyName("Day");
    JsonSerializer.Serialize(writer, value.Day, options);
    writer.WritePropertyName("Night");
    JsonSerializer.Serialize(writer, value.Night, options);
    writer.WritePropertyName("Sunrise");
    JsonSerializer.Serialize(writer, value.Sunrise, options);
    writer.WritePropertyName("Sunset");
    JsonSerializer.Serialize(writer, value.Sunset, options);
    writer.WriteEndObject();
  }
}
public class WeatherColor_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WeatherColor>
{
  private IWeatherColorGetter_Converter _getterConverter;
  public WeatherColor_Converter(IWeatherColorGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WeatherColor value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeatherColorGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WeatherColor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WeatherColor();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Day":
            retval.Day = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Night":
            retval.Night = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Sunrise":
            retval.Sunrise = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        case "Sunset":
            retval.Sunset = JsonSerializer.Deserialize<System.Drawing.Color>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeatherImageSpacesGetter_Converter : JsonConverter<IWeatherImageSpacesGetter>
{
  public override IWeatherImageSpacesGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeatherImageSpacesGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WeatherImageSpaces");
    writer.WritePropertyName("Day");
    JsonSerializer.Serialize(writer, value.Day, options);
    writer.WritePropertyName("Night");
    JsonSerializer.Serialize(writer, value.Night, options);
    writer.WritePropertyName("Sunrise");
    JsonSerializer.Serialize(writer, value.Sunrise, options);
    writer.WritePropertyName("Sunset");
    JsonSerializer.Serialize(writer, value.Sunset, options);
    writer.WriteEndObject();
  }
}
public class WeatherImageSpaces_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WeatherImageSpaces>
{
  private IWeatherImageSpacesGetter_Converter _getterConverter;
  public WeatherImageSpaces_Converter(IWeatherImageSpacesGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WeatherImageSpaces value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeatherImageSpacesGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WeatherImageSpaces Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WeatherImageSpaces();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Day":
            ConverterHelpers.ReadFormLink<IImageSpaceAdapterGetter>(retval.Day, ref reader);
            break;
        case "Night":
            ConverterHelpers.ReadFormLink<IImageSpaceAdapterGetter>(retval.Night, ref reader);
            break;
        case "Sunrise":
            ConverterHelpers.ReadFormLink<IImageSpaceAdapterGetter>(retval.Sunrise, ref reader);
            break;
        case "Sunset":
            ConverterHelpers.ReadFormLink<IImageSpaceAdapterGetter>(retval.Sunset, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeatherSoundGetter_Converter : JsonConverter<IWeatherSoundGetter>
{
  public override IWeatherSoundGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeatherSoundGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WeatherSound");
    writer.WritePropertyName("Sound");
    JsonSerializer.Serialize(writer, value.Sound, options);
    writer.WritePropertyName("Type");
    JsonSerializer.Serialize(writer, value.Type, options);
    writer.WriteEndObject();
  }
}
public class WeatherSound_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WeatherSound>
{
  private IWeatherSoundGetter_Converter _getterConverter;
  public WeatherSound_Converter(IWeatherSoundGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WeatherSound value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeatherSoundGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WeatherSound Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WeatherSound();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Sound":
            ConverterHelpers.ReadFormLink<ISoundGetter>(retval.Sound, ref reader);
            break;
        case "Type":
            retval.Type = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WeatherSound.TypeEnum>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeatherTypeGetter_Converter : JsonConverter<IWeatherTypeGetter>
{
  public override IWeatherTypeGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeatherTypeGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WeatherType");
    writer.WritePropertyName("Chance");
    JsonSerializer.Serialize(writer, value.Chance, options);
    writer.WritePropertyName("Global");
    JsonSerializer.Serialize(writer, value.Global, options);
    writer.WritePropertyName("Weather");
    JsonSerializer.Serialize(writer, value.Weather, options);
    writer.WriteEndObject();
  }
}
public class WeatherType_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WeatherType>
{
  private IWeatherTypeGetter_Converter _getterConverter;
  public WeatherType_Converter(IWeatherTypeGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WeatherType value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeatherTypeGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WeatherType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WeatherType();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Chance":
            retval.Chance = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Global":
            ConverterHelpers.ReadFormLink<IGlobalGetter>(retval.Global, ref reader);
            break;
        case "Weather":
            ConverterHelpers.ReadFormLink<IWeatherGetter>(retval.Weather, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWeatherVolumetricLightingGetter_Converter : JsonConverter<IWeatherVolumetricLightingGetter>
{
  public override IWeatherVolumetricLightingGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWeatherVolumetricLightingGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WeatherVolumetricLighting");
    writer.WritePropertyName("Day");
    JsonSerializer.Serialize(writer, value.Day, options);
    writer.WritePropertyName("Night");
    JsonSerializer.Serialize(writer, value.Night, options);
    writer.WritePropertyName("Sunrise");
    JsonSerializer.Serialize(writer, value.Sunrise, options);
    writer.WritePropertyName("Sunset");
    JsonSerializer.Serialize(writer, value.Sunset, options);
    writer.WriteEndObject();
  }
}
public class WeatherVolumetricLighting_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WeatherVolumetricLighting>
{
  private IWeatherVolumetricLightingGetter_Converter _getterConverter;
  public WeatherVolumetricLighting_Converter(IWeatherVolumetricLightingGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WeatherVolumetricLighting value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWeatherVolumetricLightingGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WeatherVolumetricLighting Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WeatherVolumetricLighting();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Day":
            ConverterHelpers.ReadFormLink<IVolumetricLightingGetter>(retval.Day, ref reader);
            break;
        case "Night":
            ConverterHelpers.ReadFormLink<IVolumetricLightingGetter>(retval.Night, ref reader);
            break;
        case "Sunrise":
            ConverterHelpers.ReadFormLink<IVolumetricLightingGetter>(retval.Sunrise, ref reader);
            break;
        case "Sunset":
            ConverterHelpers.ReadFormLink<IVolumetricLightingGetter>(retval.Sunset, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWordOfPowerGetter_Converter : JsonConverter<IWordOfPowerGetter>
{
  public override IWordOfPowerGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWordOfPowerGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WordOfPower");
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("Translation");
    JsonSerializer.Serialize(writer, value.Translation, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WriteEndObject();
  }
}
public class WordOfPower_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WordOfPower>
{
  private IWordOfPowerGetter_Converter _getterConverter;
  public WordOfPower_Converter(IWordOfPowerGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WordOfPower value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWordOfPowerGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WordOfPower Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WordOfPower();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "Translation":
            retval.Translation = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorkbenchDataGetter_Converter : JsonConverter<IWorkbenchDataGetter>
{
  public override IWorkbenchDataGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorkbenchDataGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorkbenchData");
    writer.WritePropertyName("BenchType");
    JsonSerializer.Serialize(writer, value.BenchType, options);
    writer.WritePropertyName("UsesSkill");
    JsonSerializer.Serialize(writer, value.UsesSkill, options);
    writer.WriteEndObject();
  }
}
public class WorkbenchData_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorkbenchData>
{
  private IWorkbenchDataGetter_Converter _getterConverter;
  public WorkbenchData_Converter(IWorkbenchDataGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorkbenchData value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorkbenchDataGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorkbenchData Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorkbenchData();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BenchType":
            retval.BenchType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WorkbenchData.Type>(ref reader, options);
            break;
        case "UsesSkill":
            retval.UsesSkill = JsonSerializer.Deserialize<Skill?>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceGetter_Converter : JsonConverter<IWorldspaceGetter>
{
  public override IWorldspaceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "Worldspace");
    writer.WritePropertyName("CanopyShadow");
    JsonSerializer.Serialize(writer, value.CanopyShadow, options);
    writer.WritePropertyName("Climate");
    JsonSerializer.Serialize(writer, value.Climate, options);
    writer.WritePropertyName("CloudModel");
    JsonSerializer.Serialize(writer, value.CloudModel, options);
    writer.WritePropertyName("DistantLodMultiplier");
    JsonSerializer.Serialize(writer, value.DistantLodMultiplier, options);
    writer.WritePropertyName("EditorID");
    JsonSerializer.Serialize(writer, value.EditorID, options);
    writer.WritePropertyName("EncounterZone");
    JsonSerializer.Serialize(writer, value.EncounterZone, options);
    writer.WritePropertyName("FixedDimensionsCenterCell");
    JsonSerializer.Serialize(writer, value.FixedDimensionsCenterCell, options);
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("FormVersion");
    JsonSerializer.Serialize(writer, value.FormVersion, options);
    writer.WritePropertyName("HdLodDiffuseTexture");
    JsonSerializer.Serialize(writer, value.HdLodDiffuseTexture, options);
    writer.WritePropertyName("HdLodNormalTexture");
    JsonSerializer.Serialize(writer, value.HdLodNormalTexture, options);
    writer.WritePropertyName("InteriorLighting");
    JsonSerializer.Serialize(writer, value.InteriorLighting, options);
    writer.WritePropertyName("IsCompressed");
    JsonSerializer.Serialize(writer, value.IsCompressed, options);
    writer.WritePropertyName("IsDeleted");
    JsonSerializer.Serialize(writer, value.IsDeleted, options);
    writer.WritePropertyName("LandDefaults");
    JsonSerializer.Serialize(writer, value.LandDefaults, options);
    if (value.LargeReferences != default)
    {
      writer.WritePropertyName("LargeReferences");
      writer.WriteStartArray();
      foreach (var itm in value.LargeReferences)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("LargeReferences");
    }
    writer.WritePropertyName("Location");
    JsonSerializer.Serialize(writer, value.Location, options);
    writer.WritePropertyName("LodWater");
    JsonSerializer.Serialize(writer, value.LodWater, options);
    writer.WritePropertyName("LodWaterHeight");
    JsonSerializer.Serialize(writer, value.LodWaterHeight, options);
    writer.WritePropertyName("MajorFlags");
    JsonSerializer.Serialize(writer, value.MajorFlags, options);
    writer.WritePropertyName("MajorRecordFlagsRaw");
    JsonSerializer.Serialize(writer, value.MajorRecordFlagsRaw, options);
    writer.WritePropertyName("MapData");
    JsonSerializer.Serialize(writer, value.MapData, options);
    writer.WritePropertyName("MapImage");
    JsonSerializer.Serialize(writer, value.MapImage, options);
    writer.WritePropertyName("MapOffset");
    JsonSerializer.Serialize(writer, value.MapOffset, options);
    writer.WritePropertyName("MaxHeight");
    JsonSerializer.Serialize(writer, value.MaxHeight, options);
    writer.WritePropertyName("Music");
    JsonSerializer.Serialize(writer, value.Music, options);
    writer.WritePropertyName("Name");
    JsonSerializer.Serialize(writer, value.Name, options);
    writer.WritePropertyName("ObjectBounds");
    JsonSerializer.Serialize(writer, value.ObjectBounds, options);
    writer.WritePropertyName("OffsetData");
    JsonSerializer.Serialize(writer, value.OffsetData, options);
    writer.WritePropertyName("Parent");
    JsonSerializer.Serialize(writer, value.Parent, options);
    if (value.SubCells != default)
    {
      writer.WritePropertyName("SubCells");
      writer.WriteStartArray();
      foreach (var itm in value.SubCells)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("SubCells");
    }
    writer.WritePropertyName("SubCellsTimestamp");
    JsonSerializer.Serialize(writer, value.SubCellsTimestamp, options);
    writer.WritePropertyName("SubCellsUnknown");
    JsonSerializer.Serialize(writer, value.SubCellsUnknown, options);
    writer.WritePropertyName("TopCell");
    JsonSerializer.Serialize(writer, value.TopCell, options);
    writer.WritePropertyName("Version2");
    JsonSerializer.Serialize(writer, value.Version2, options);
    writer.WritePropertyName("VersionControl");
    JsonSerializer.Serialize(writer, value.VersionControl, options);
    writer.WritePropertyName("Water");
    JsonSerializer.Serialize(writer, value.Water, options);
    writer.WritePropertyName("WaterEnvironmentMap");
    JsonSerializer.Serialize(writer, value.WaterEnvironmentMap, options);
    writer.WritePropertyName("WaterNoiseTexture");
    JsonSerializer.Serialize(writer, value.WaterNoiseTexture, options);
    writer.WriteEndObject();
  }
}
public class Worldspace_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.Worldspace>
{
  private IWorldspaceGetter_Converter _getterConverter;
  public Worldspace_Converter(IWorldspaceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.Worldspace value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.Worldspace Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.Worldspace();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CanopyShadow":
            retval.CanopyShadow = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "Climate":
            ConverterHelpers.ReadFormLinkNullable<IClimateGetter>(retval.Climate, ref reader);
            break;
        case "CloudModel":
            retval.CloudModel = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Model>(ref reader, options);
            break;
        case "DistantLodMultiplier":
            retval.DistantLodMultiplier = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "EditorID":
            retval.EditorID = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "EncounterZone":
            ConverterHelpers.ReadFormLinkNullable<IEncounterZoneGetter>(retval.EncounterZone, ref reader);
            break;
        case "FixedDimensionsCenterCell":
            retval.FixedDimensionsCenterCell = JsonSerializer.Deserialize<P2Int16?>(ref reader, options);
            break;
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Worldspace.Flag>(ref reader, options);
            break;
        case "FormVersion":
            retval.FormVersion = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "HdLodDiffuseTexture":
            retval.HdLodDiffuseTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "HdLodNormalTexture":
            retval.HdLodNormalTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "InteriorLighting":
            ConverterHelpers.ReadFormLinkNullable<ILightingTemplateGetter>(retval.InteriorLighting, ref reader);
            break;
        case "IsCompressed":
            retval.IsCompressed = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "IsDeleted":
            retval.IsDeleted = JsonSerializer.Deserialize<System.Boolean>(ref reader, options);
            break;
        case "LandDefaults":
            retval.LandDefaults = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WorldspaceLandDefaults>(ref reader, options);
            break;
        case "LargeReferences":
            ConverterHelpers.ReadExtendedList<WorldspaceGridReference>(retval.LargeReferences, ref reader, options);
            break;
        case "Location":
            ConverterHelpers.ReadFormLinkNullable<ILocationGetter>(retval.Location, ref reader);
            break;
        case "LodWater":
            ConverterHelpers.ReadFormLinkNullable<IWaterGetter>(retval.LodWater, ref reader);
            break;
        case "LodWaterHeight":
            retval.LodWaterHeight = JsonSerializer.Deserialize<Single?>(ref reader, options);
            break;
        case "MajorFlags":
            retval.MajorFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Worldspace.MajorFlag>(ref reader, options);
            break;
        case "MajorRecordFlagsRaw":
            retval.MajorRecordFlagsRaw = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "MapData":
            retval.MapData = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WorldspaceMap>(ref reader, options);
            break;
        case "MapImage":
            retval.MapImage = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "MapOffset":
            retval.MapOffset = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WorldspaceMapOffset>(ref reader, options);
            break;
        case "MaxHeight":
            retval.MaxHeight = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WorldspaceMaxHeight>(ref reader, options);
            break;
        case "Music":
            ConverterHelpers.ReadFormLinkNullable<IMusicTypeGetter>(retval.Music, ref reader);
            break;
        case "Name":
            retval.Name = JsonSerializer.Deserialize<Mutagen.Bethesda.Strings.TranslatedString>(ref reader, options);
            break;
        case "ObjectBounds":
            retval.ObjectBounds = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WorldspaceObjectBounds>(ref reader, options);
            break;
        case "OffsetData":
            break;
        case "Parent":
            retval.Parent = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WorldspaceParent>(ref reader, options);
            break;
        case "SkyrimMajorRecordFlags":
            retval.SkyrimMajorRecordFlags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.SkyrimMajorRecord.SkyrimMajorRecordFlag>(ref reader, options);
            break;
        case "SubCells":
            ConverterHelpers.ReadExtendedList<WorldspaceBlock>(retval.SubCells, ref reader, options);
            break;
        case "SubCellsTimestamp":
            retval.SubCellsTimestamp = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "SubCellsUnknown":
            retval.SubCellsUnknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "TopCell":
            retval.TopCell = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.Cell>(ref reader, options);
            break;
        case "Version2":
            retval.Version2 = JsonSerializer.Deserialize<System.UInt16>(ref reader, options);
            break;
        case "VersionControl":
            retval.VersionControl = JsonSerializer.Deserialize<System.UInt32>(ref reader, options);
            break;
        case "Water":
            ConverterHelpers.ReadFormLinkNullable<IWaterGetter>(retval.Water, ref reader);
            break;
        case "WaterEnvironmentMap":
            retval.WaterEnvironmentMap = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        case "WaterNoiseTexture":
            retval.WaterNoiseTexture = JsonSerializer.Deserialize<System.String>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceBlockGetter_Converter : JsonConverter<IWorldspaceBlockGetter>
{
  public override IWorldspaceBlockGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceBlockGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceBlock");
    writer.WritePropertyName("BlockNumberX");
    JsonSerializer.Serialize(writer, value.BlockNumberX, options);
    writer.WritePropertyName("BlockNumberY");
    JsonSerializer.Serialize(writer, value.BlockNumberY, options);
    writer.WritePropertyName("GroupType");
    JsonSerializer.Serialize(writer, value.GroupType, options);
    if (value.Items != default)
    {
      writer.WritePropertyName("Items");
      writer.WriteStartArray();
      foreach (var itm in value.Items)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Items");
    }
    writer.WritePropertyName("LastModified");
    JsonSerializer.Serialize(writer, value.LastModified, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class WorldspaceBlock_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceBlock>
{
  private IWorldspaceBlockGetter_Converter _getterConverter;
  public WorldspaceBlock_Converter(IWorldspaceBlockGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceBlock value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceBlockGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceBlock Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceBlock();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BlockNumberX":
            retval.BlockNumberX = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "BlockNumberY":
            retval.BlockNumberY = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "GroupType":
            retval.GroupType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.GroupTypeEnum>(ref reader, options);
            break;
        case "Items":
            ConverterHelpers.ReadExtendedList<WorldspaceSubBlock>(retval.Items, ref reader, options);
            break;
        case "LastModified":
            retval.LastModified = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceGridReferenceGetter_Converter : JsonConverter<IWorldspaceGridReferenceGetter>
{
  public override IWorldspaceGridReferenceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceGridReferenceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceGridReference");
    writer.WritePropertyName("GridPosition");
    JsonSerializer.Serialize(writer, value.GridPosition, options);
    if (value.References != default)
    {
      writer.WritePropertyName("References");
      writer.WriteStartArray();
      foreach (var itm in value.References)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("References");
    }
    writer.WriteEndObject();
  }
}
public class WorldspaceGridReference_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceGridReference>
{
  private IWorldspaceGridReferenceGetter_Converter _getterConverter;
  public WorldspaceGridReference_Converter(IWorldspaceGridReferenceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceGridReference value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceGridReferenceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceGridReference Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceGridReference();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "GridPosition":
            retval.GridPosition = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        case "References":
            ConverterHelpers.ReadExtendedList<WorldspaceReference>(retval.References, ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceLandDefaultsGetter_Converter : JsonConverter<IWorldspaceLandDefaultsGetter>
{
  public override IWorldspaceLandDefaultsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceLandDefaultsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceLandDefaults");
    writer.WritePropertyName("DefaultLandHeight");
    JsonSerializer.Serialize(writer, value.DefaultLandHeight, options);
    writer.WritePropertyName("DefaultWaterHeight");
    JsonSerializer.Serialize(writer, value.DefaultWaterHeight, options);
    writer.WriteEndObject();
  }
}
public class WorldspaceLandDefaults_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceLandDefaults>
{
  private IWorldspaceLandDefaultsGetter_Converter _getterConverter;
  public WorldspaceLandDefaults_Converter(IWorldspaceLandDefaultsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceLandDefaults value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceLandDefaultsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceLandDefaults Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceLandDefaults();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "DefaultLandHeight":
            retval.DefaultLandHeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "DefaultWaterHeight":
            retval.DefaultWaterHeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceMapGetter_Converter : JsonConverter<IWorldspaceMapGetter>
{
  public override IWorldspaceMapGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceMapGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceMap");
    writer.WritePropertyName("CameraInitialPitch");
    JsonSerializer.Serialize(writer, value.CameraInitialPitch, options);
    writer.WritePropertyName("CameraMaxHeight");
    JsonSerializer.Serialize(writer, value.CameraMaxHeight, options);
    writer.WritePropertyName("CameraMinHeight");
    JsonSerializer.Serialize(writer, value.CameraMinHeight, options);
    writer.WritePropertyName("NorthwestCellCoords");
    JsonSerializer.Serialize(writer, value.NorthwestCellCoords, options);
    writer.WritePropertyName("SoutheastCellCoords");
    JsonSerializer.Serialize(writer, value.SoutheastCellCoords, options);
    writer.WritePropertyName("UsableDimensions");
    JsonSerializer.Serialize(writer, value.UsableDimensions, options);
    writer.WritePropertyName("Versioning");
    JsonSerializer.Serialize(writer, value.Versioning, options);
    writer.WriteEndObject();
  }
}
public class WorldspaceMap_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceMap>
{
  private IWorldspaceMapGetter_Converter _getterConverter;
  public WorldspaceMap_Converter(IWorldspaceMapGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceMap value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceMapGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceMap Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceMap();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CameraInitialPitch":
            retval.CameraInitialPitch = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CameraMaxHeight":
            retval.CameraMaxHeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "CameraMinHeight":
            retval.CameraMinHeight = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        case "NorthwestCellCoords":
            retval.NorthwestCellCoords = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        case "SoutheastCellCoords":
            retval.SoutheastCellCoords = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        case "UsableDimensions":
            retval.UsableDimensions = JsonSerializer.Deserialize<Noggog.P2Int>(ref reader, options);
            break;
        case "Versioning":
            retval.Versioning = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WorldspaceMap.VersioningBreaks>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceMapOffsetGetter_Converter : JsonConverter<IWorldspaceMapOffsetGetter>
{
  public override IWorldspaceMapOffsetGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceMapOffsetGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceMapOffset");
    writer.WritePropertyName("CellOffset");
    JsonSerializer.Serialize(writer, value.CellOffset, options);
    writer.WritePropertyName("Scale");
    JsonSerializer.Serialize(writer, value.Scale, options);
    writer.WriteEndObject();
  }
}
public class WorldspaceMapOffset_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceMapOffset>
{
  private IWorldspaceMapOffsetGetter_Converter _getterConverter;
  public WorldspaceMapOffset_Converter(IWorldspaceMapOffsetGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceMapOffset value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceMapOffsetGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceMapOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceMapOffset();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CellOffset":
            retval.CellOffset = JsonSerializer.Deserialize<Noggog.P3Float>(ref reader, options);
            break;
        case "Scale":
            retval.Scale = JsonSerializer.Deserialize<System.Single>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceMaxHeightGetter_Converter : JsonConverter<IWorldspaceMaxHeightGetter>
{
  public override IWorldspaceMaxHeightGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceMaxHeightGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceMaxHeight");
    writer.WritePropertyName("CellData");
    JsonSerializer.Serialize(writer, value.CellData, options);
    writer.WritePropertyName("Max");
    JsonSerializer.Serialize(writer, value.Max, options);
    writer.WritePropertyName("Min");
    JsonSerializer.Serialize(writer, value.Min, options);
    writer.WriteEndObject();
  }
}
public class WorldspaceMaxHeight_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceMaxHeight>
{
  private IWorldspaceMaxHeightGetter_Converter _getterConverter;
  public WorldspaceMaxHeight_Converter(IWorldspaceMaxHeightGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceMaxHeight value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceMaxHeightGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceMaxHeight Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceMaxHeight();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "CellData":
            break;
        case "Max":
            retval.Max = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        case "Min":
            retval.Min = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceNavmeshParentGetter_Converter : JsonConverter<IWorldspaceNavmeshParentGetter>
{
  public override IWorldspaceNavmeshParentGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceNavmeshParentGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceNavmeshParent");
    writer.WritePropertyName("Coordinates");
    JsonSerializer.Serialize(writer, value.Coordinates, options);
    writer.WritePropertyName("Parent");
    JsonSerializer.Serialize(writer, value.Parent, options);
    writer.WriteEndObject();
  }
}
public class WorldspaceNavmeshParent_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceNavmeshParent>
{
  private IWorldspaceNavmeshParentGetter_Converter _getterConverter;
  public WorldspaceNavmeshParent_Converter(IWorldspaceNavmeshParentGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceNavmeshParent value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceNavmeshParentGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceNavmeshParent Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceNavmeshParent();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Coordinates":
            retval.Coordinates = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        case "Parent":
            ConverterHelpers.ReadFormLink<IWorldspaceGetter>(retval.Parent, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceObjectBoundsGetter_Converter : JsonConverter<IWorldspaceObjectBoundsGetter>
{
  public override IWorldspaceObjectBoundsGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceObjectBoundsGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceObjectBounds");
    writer.WritePropertyName("Max");
    JsonSerializer.Serialize(writer, value.Max, options);
    writer.WritePropertyName("Min");
    JsonSerializer.Serialize(writer, value.Min, options);
    writer.WriteEndObject();
  }
}
public class WorldspaceObjectBounds_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceObjectBounds>
{
  private IWorldspaceObjectBoundsGetter_Converter _getterConverter;
  public WorldspaceObjectBounds_Converter(IWorldspaceObjectBoundsGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceObjectBounds value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceObjectBoundsGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceObjectBounds Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceObjectBounds();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Max":
            retval.Max = JsonSerializer.Deserialize<Noggog.P2Float>(ref reader, options);
            break;
        case "Min":
            retval.Min = JsonSerializer.Deserialize<Noggog.P2Float>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceParentGetter_Converter : JsonConverter<IWorldspaceParentGetter>
{
  public override IWorldspaceParentGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceParentGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceParent");
    writer.WritePropertyName("Flags");
    JsonSerializer.Serialize(writer, value.Flags, options);
    writer.WritePropertyName("Worldspace");
    JsonSerializer.Serialize(writer, value.Worldspace, options);
    writer.WriteEndObject();
  }
}
public class WorldspaceParent_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceParent>
{
  private IWorldspaceParentGetter_Converter _getterConverter;
  public WorldspaceParent_Converter(IWorldspaceParentGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceParent value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceParentGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceParent Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceParent();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Flags":
            retval.Flags = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.WorldspaceParent.Flag>(ref reader, options);
            break;
        case "Worldspace":
            ConverterHelpers.ReadFormLink<IWorldspaceGetter>(retval.Worldspace, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceReferenceGetter_Converter : JsonConverter<IWorldspaceReferenceGetter>
{
  public override IWorldspaceReferenceGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceReferenceGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceReference");
    writer.WritePropertyName("Position");
    JsonSerializer.Serialize(writer, value.Position, options);
    writer.WritePropertyName("Reference");
    JsonSerializer.Serialize(writer, value.Reference, options);
    writer.WriteEndObject();
  }
}
public class WorldspaceReference_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceReference>
{
  private IWorldspaceReferenceGetter_Converter _getterConverter;
  public WorldspaceReference_Converter(IWorldspaceReferenceGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceReference value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceReferenceGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceReference Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceReference();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "Position":
            retval.Position = JsonSerializer.Deserialize<Noggog.P2Int16>(ref reader, options);
            break;
        case "Reference":
            ConverterHelpers.ReadFormLink<IPlacedObjectGetter>(retval.Reference, ref reader);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public class IWorldspaceSubBlockGetter_Converter : JsonConverter<IWorldspaceSubBlockGetter>
{
  public override IWorldspaceSubBlockGetter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    throw new NotImplementedException();
  }
  public override void Write(Utf8JsonWriter writer, IWorldspaceSubBlockGetter value, JsonSerializerOptions options)
  {
    writer.WriteStartObject();
    writer.WriteString("$type", "WorldspaceSubBlock");
    writer.WritePropertyName("BlockNumberX");
    JsonSerializer.Serialize(writer, value.BlockNumberX, options);
    writer.WritePropertyName("BlockNumberY");
    JsonSerializer.Serialize(writer, value.BlockNumberY, options);
    writer.WritePropertyName("GroupType");
    JsonSerializer.Serialize(writer, value.GroupType, options);
    if (value.Items != default)
    {
      writer.WritePropertyName("Items");
      writer.WriteStartArray();
      foreach (var itm in value.Items)
      {
        JsonSerializer.Serialize(writer, itm, options);
      }
      writer.WriteEndArray();
    }
    else
    {
      writer.WriteNull("Items");
    }
    writer.WritePropertyName("LastModified");
    JsonSerializer.Serialize(writer, value.LastModified, options);
    writer.WritePropertyName("Unknown");
    JsonSerializer.Serialize(writer, value.Unknown, options);
    writer.WriteEndObject();
  }
}
public class WorldspaceSubBlock_Converter : JsonConverter<Mutagen.Bethesda.Skyrim.WorldspaceSubBlock>
{
  private IWorldspaceSubBlockGetter_Converter _getterConverter;
  public WorldspaceSubBlock_Converter(IWorldspaceSubBlockGetter_Converter getterConverter)
  {
    _getterConverter = getterConverter;
  }
  public override void Write(Utf8JsonWriter writer, Mutagen.Bethesda.Skyrim.WorldspaceSubBlock value, JsonSerializerOptions options)
  {
    _getterConverter.Write(writer, (IWorldspaceSubBlockGetter)value, options);
  }
  public override Mutagen.Bethesda.Skyrim.WorldspaceSubBlock Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
  {
    if (reader.TokenType != JsonTokenType.StartObject)
        throw new JsonException();
    var retval = new Mutagen.Bethesda.Skyrim.WorldspaceSubBlock();
    while (true)
    {
      reader.Read();
      if (reader.TokenType == JsonTokenType.EndObject)
      {
        reader.Read();
        break;
      }
      var prop = reader.GetString();
      reader.Read();
      switch (prop)
      {
        case "BlockNumberX":
            retval.BlockNumberX = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "BlockNumberY":
            retval.BlockNumberY = JsonSerializer.Deserialize<System.Int16>(ref reader, options);
            break;
        case "GroupType":
            retval.GroupType = JsonSerializer.Deserialize<Mutagen.Bethesda.Skyrim.GroupTypeEnum>(ref reader, options);
            break;
        case "Items":
            ConverterHelpers.ReadExtendedList<Cell>(retval.Items, ref reader, options);
            break;
        case "LastModified":
            retval.LastModified = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        case "Unknown":
            retval.Unknown = JsonSerializer.Deserialize<System.Int32>(ref reader, options);
            break;
        default:
            reader.Skip();
            break;
      }
    }
    return retval;
  }
}
public static class GeneratedConvertersExtensions
{
  public static IServiceCollection UseConverters(this IServiceCollection services)
  {
    services.AddSingleton<JsonConverter, IAcousticSpaceGetter_Converter>();
    services.AddSingleton<JsonConverter, IActionRecordGetter_Converter>();
    services.AddSingleton<JsonConverter, IActivateParentGetter_Converter>();
    services.AddSingleton<JsonConverter, IActivateParentsGetter_Converter>();
    services.AddSingleton<JsonConverter, IActivatorGetter_Converter>();
    services.AddSingleton<JsonConverter, IActorValueInformationGetter_Converter>();
    services.AddSingleton<JsonConverter, IActorValuePerkNodeGetter_Converter>();
    services.AddSingleton<JsonConverter, IActorValueSkillGetter_Converter>();
    services.AddSingleton<JsonConverter, IAddonNodeGetter_Converter>();
    services.AddSingleton<JsonConverter, IAIDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IAlchemicalApparatusGetter_Converter>();
    services.AddSingleton<JsonConverter, IAlphaGetter_Converter>();
    services.AddSingleton<JsonConverter, IAlphaLayerGetter_Converter>();
    services.AddSingleton<JsonConverter, IAlternateTextureGetter_Converter>();
    services.AddSingleton<JsonConverter, IAmbientColorsGetter_Converter>();
    services.AddSingleton<JsonConverter, IAmmunitionGetter_Converter>();
    services.AddSingleton<JsonConverter, IAnimatedObjectGetter_Converter>();
    services.AddSingleton<JsonConverter, IAnimationChangeThresholdsGetter_Converter>();
    services.AddSingleton<JsonConverter, IAPackageDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IArmorGetter_Converter>();
    services.AddSingleton<JsonConverter, IArmorAddonGetter_Converter>();
    services.AddSingleton<JsonConverter, IArmorModelGetter_Converter>();
    services.AddSingleton<JsonConverter, IArtObjectGetter_Converter>();
    services.AddSingleton<JsonConverter, IAssociationTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IAttackGetter_Converter>();
    services.AddSingleton<JsonConverter, IAttackDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IAvailableMorphsGetter_Converter>();
    services.AddSingleton<JsonConverter, IBaseLayerGetter_Converter>();
    services.AddSingleton<JsonConverter, IBodyDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IBodyPartGetter_Converter>();
    services.AddSingleton<JsonConverter, IBodyPartDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IBodyTemplateGetter_Converter>();
    services.AddSingleton<JsonConverter, IBookGetter_Converter>();
    services.AddSingleton<JsonConverter, IBookSkillGetter_Converter>();
    services.AddSingleton<JsonConverter, IBookSpellGetter_Converter>();
    services.AddSingleton<JsonConverter, IBookTeachesNothingGetter_Converter>();
    services.AddSingleton<JsonConverter, IBoundingGetter_Converter>();
    services.AddSingleton<JsonConverter, ICameraPathGetter_Converter>();
    services.AddSingleton<JsonConverter, ICameraShotGetter_Converter>();
    services.AddSingleton<JsonConverter, ICellGetter_Converter>();
    services.AddSingleton<JsonConverter, ICellBlockGetter_Converter>();
    services.AddSingleton<JsonConverter, ICellGridGetter_Converter>();
    services.AddSingleton<JsonConverter, ICellLightingGetter_Converter>();
    services.AddSingleton<JsonConverter, ICellMaxHeightDataGetter_Converter>();
    services.AddSingleton<JsonConverter, ICellNavmeshParentGetter_Converter>();
    services.AddSingleton<JsonConverter, ICellSubBlockGetter_Converter>();
    services.AddSingleton<JsonConverter, ICellWaterVelocityGetter_Converter>();
    services.AddSingleton<JsonConverter, IClassGetter_Converter>();
    services.AddSingleton<JsonConverter, IClimateGetter_Converter>();
    services.AddSingleton<JsonConverter, ICloudLayerGetter_Converter>();
    services.AddSingleton<JsonConverter, ICollisionLayerGetter_Converter>();
    services.AddSingleton<JsonConverter, IColorFrameGetter_Converter>();
    services.AddSingleton<JsonConverter, IColorRecordGetter_Converter>();
    services.AddSingleton<JsonConverter, ICombatStyleGetter_Converter>();
    services.AddSingleton<JsonConverter, ICombatStyleCloseRangeGetter_Converter>();
    services.AddSingleton<JsonConverter, ICombatStyleFlightGetter_Converter>();
    services.AddSingleton<JsonConverter, ICombatStyleMeleeGetter_Converter>();
    services.AddSingleton<JsonConverter, IConditionFloatGetter_Converter>();
    services.AddSingleton<JsonConverter, IConditionGlobalGetter_Converter>();
    services.AddSingleton<JsonConverter, IConstructibleObjectGetter_Converter>();
    services.AddSingleton<JsonConverter, IContainerGetter_Converter>();
    services.AddSingleton<JsonConverter, IContainerEntryGetter_Converter>();
    services.AddSingleton<JsonConverter, IContainerItemGetter_Converter>();
    services.AddSingleton<JsonConverter, ICreateReferenceToObjectGetter_Converter>();
    services.AddSingleton<JsonConverter, ICrimeValuesGetter_Converter>();
    services.AddSingleton<JsonConverter, ICriticalDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IDebrisGetter_Converter>();
    services.AddSingleton<JsonConverter, IDebrisModelGetter_Converter>();
    services.AddSingleton<JsonConverter, IDecalGetter_Converter>();
    services.AddSingleton<JsonConverter, IDefaultObjectGetter_Converter>();
    services.AddSingleton<JsonConverter, IDefaultObjectManagerGetter_Converter>();
    services.AddSingleton<JsonConverter, IDestructableDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IDestructibleGetter_Converter>();
    services.AddSingleton<JsonConverter, IDestructionStageGetter_Converter>();
    services.AddSingleton<JsonConverter, IDestructionStageDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IDialogBranchGetter_Converter>();
    services.AddSingleton<JsonConverter, IDialogResponseGetter_Converter>();
    services.AddSingleton<JsonConverter, IDialogResponseFlagsGetter_Converter>();
    services.AddSingleton<JsonConverter, IDialogResponsesGetter_Converter>();
    services.AddSingleton<JsonConverter, IDialogResponsesAdapterGetter_Converter>();
    services.AddSingleton<JsonConverter, IDialogResponsesUnknownDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IDialogTopicGetter_Converter>();
    services.AddSingleton<JsonConverter, IDialogViewGetter_Converter>();
    services.AddSingleton<JsonConverter, IDoorGetter_Converter>();
    services.AddSingleton<JsonConverter, IDoorTriangleGetter_Converter>();
    services.AddSingleton<JsonConverter, IDualCastDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IEdgeLinkGetter_Converter>();
    services.AddSingleton<JsonConverter, IEffectGetter_Converter>();
    services.AddSingleton<JsonConverter, IEffectDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IEffectShaderGetter_Converter>();
    services.AddSingleton<JsonConverter, IEnableParentGetter_Converter>();
    services.AddSingleton<JsonConverter, IEncounterZoneGetter_Converter>();
    services.AddSingleton<JsonConverter, IEntryPointsGetter_Converter>();
    services.AddSingleton<JsonConverter, IEquipTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IExplosionGetter_Converter>();
    services.AddSingleton<JsonConverter, IExternalAliasReferenceGetter_Converter>();
    services.AddSingleton<JsonConverter, IExtraDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IEyesGetter_Converter>();
    services.AddSingleton<JsonConverter, IFaceFxPhonemesGetter_Converter>();
    services.AddSingleton<JsonConverter, IFactionGetter_Converter>();
    services.AddSingleton<JsonConverter, IFactionOwnerGetter_Converter>();
    services.AddSingleton<JsonConverter, IFindMatchingRefFromEventGetter_Converter>();
    services.AddSingleton<JsonConverter, IFindMatchingRefNearAliasGetter_Converter>();
    services.AddSingleton<JsonConverter, IFloraGetter_Converter>();
    services.AddSingleton<JsonConverter, IFootstepGetter_Converter>();
    services.AddSingleton<JsonConverter, IFootstepSetGetter_Converter>();
    services.AddSingleton<JsonConverter, IFormListGetter_Converter>();
    services.AddSingleton<JsonConverter, IFunctionConditionDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IFurnitureGetter_Converter>();
    services.AddSingleton<JsonConverter, IFurnitureMarkerGetter_Converter>();
    services.AddSingleton<JsonConverter, IGameSettingBoolGetter_Converter>();
    services.AddSingleton<JsonConverter, IGameSettingFloatGetter_Converter>();
    services.AddSingleton<JsonConverter, IGameSettingIntGetter_Converter>();
    services.AddSingleton<JsonConverter, IGameSettingStringGetter_Converter>();
    services.AddSingleton<JsonConverter, IGetEventDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IGlobalFloatGetter_Converter>();
    services.AddSingleton<JsonConverter, IGlobalIntGetter_Converter>();
    services.AddSingleton<JsonConverter, IGlobalShortGetter_Converter>();
    services.AddSingleton<JsonConverter, IGrassGetter_Converter>();
    services.AddSingleton<JsonConverter, IHairGetter_Converter>();
    services.AddSingleton<JsonConverter, IHazardGetter_Converter>();
    services.AddSingleton<JsonConverter, IHeadDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IHeadPartGetter_Converter>();
    services.AddSingleton<JsonConverter, IHeadPartReferenceGetter_Converter>();
    services.AddSingleton<JsonConverter, IIconsGetter_Converter>();
    services.AddSingleton<JsonConverter, IIdleAnimationGetter_Converter>();
    services.AddSingleton<JsonConverter, IIdleMarkerGetter_Converter>();
    services.AddSingleton<JsonConverter, IImageSpaceGetter_Converter>();
    services.AddSingleton<JsonConverter, IImageSpaceAdapterGetter_Converter>();
    services.AddSingleton<JsonConverter, IImageSpaceCinematicGetter_Converter>();
    services.AddSingleton<JsonConverter, IImageSpaceDepthOfFieldGetter_Converter>();
    services.AddSingleton<JsonConverter, IImageSpaceHdrGetter_Converter>();
    services.AddSingleton<JsonConverter, IImageSpaceTintGetter_Converter>();
    services.AddSingleton<JsonConverter, IImpactGetter_Converter>();
    services.AddSingleton<JsonConverter, IImpactDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IImpactDataSetGetter_Converter>();
    services.AddSingleton<JsonConverter, IIndexedScriptFragmentGetter_Converter>();
    services.AddSingleton<JsonConverter, IIngestibleGetter_Converter>();
    services.AddSingleton<JsonConverter, IIngredientGetter_Converter>();
    services.AddSingleton<JsonConverter, IInt16MinMaxGetter_Converter>();
    services.AddSingleton<JsonConverter, IIslandDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IKeyGetter_Converter>();
    services.AddSingleton<JsonConverter, IKeyFrameGetter_Converter>();
    services.AddSingleton<JsonConverter, IKeywordGetter_Converter>();
    services.AddSingleton<JsonConverter, ILandscapeGetter_Converter>();
    services.AddSingleton<JsonConverter, ILandscapeTextureGetter_Converter>();
    services.AddSingleton<JsonConverter, ILandscapeVertexHeightMapGetter_Converter>();
    services.AddSingleton<JsonConverter, ILayerHeaderGetter_Converter>();
    services.AddSingleton<JsonConverter, ILensFlareGetter_Converter>();
    services.AddSingleton<JsonConverter, ILeveledItemGetter_Converter>();
    services.AddSingleton<JsonConverter, ILeveledItemEntryGetter_Converter>();
    services.AddSingleton<JsonConverter, ILeveledItemEntryDataGetter_Converter>();
    services.AddSingleton<JsonConverter, ILeveledNpcGetter_Converter>();
    services.AddSingleton<JsonConverter, ILeveledNpcEntryGetter_Converter>();
    services.AddSingleton<JsonConverter, ILeveledNpcEntryDataGetter_Converter>();
    services.AddSingleton<JsonConverter, ILeveledSpellGetter_Converter>();
    services.AddSingleton<JsonConverter, ILeveledSpellEntryGetter_Converter>();
    services.AddSingleton<JsonConverter, ILeveledSpellEntryDataGetter_Converter>();
    services.AddSingleton<JsonConverter, ILightGetter_Converter>();
    services.AddSingleton<JsonConverter, ILightDataGetter_Converter>();
    services.AddSingleton<JsonConverter, ILightingTemplateGetter_Converter>();
    services.AddSingleton<JsonConverter, ILinkedDoorGetter_Converter>();
    services.AddSingleton<JsonConverter, ILinkedReferenceColorGetter_Converter>();
    services.AddSingleton<JsonConverter, ILinkedReferencesGetter_Converter>();
    services.AddSingleton<JsonConverter, ILoadScreenGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationAliasReferenceGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationCellGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationCellEnablePointGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationCellStaticReferenceGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationCellUniqueGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationCoordinateGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationFallbackGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationKeywordGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationObjectIdGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationObjectTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationReferenceGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationReferenceTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationTargetGetter_Converter>();
    services.AddSingleton<JsonConverter, ILocationTargetRadiusGetter_Converter>();
    services.AddSingleton<JsonConverter, ILockDataGetter_Converter>();
    services.AddSingleton<JsonConverter, ILodGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectBoundArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectCloakArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectEnhanceWeaponArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectGuideArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectLightArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectPeakValueModArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectSoundGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectSpawnHazardArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectSummonCreatureArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectVampireArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMagicEffectWerewolfArchetypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMapMarkerGetter_Converter>();
    services.AddSingleton<JsonConverter, IMaterialObjectGetter_Converter>();
    services.AddSingleton<JsonConverter, IMaterialTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMessageGetter_Converter>();
    services.AddSingleton<JsonConverter, IMessageButtonGetter_Converter>();
    services.AddSingleton<JsonConverter, IMiscItemGetter_Converter>();
    services.AddSingleton<JsonConverter, IModelGetter_Converter>();
    services.AddSingleton<JsonConverter, IModStatsGetter_Converter>();
    services.AddSingleton<JsonConverter, IMorphGetter_Converter>();
    services.AddSingleton<JsonConverter, IMountDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IMoveableStaticGetter_Converter>();
    services.AddSingleton<JsonConverter, IMovementTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMusicTrackGetter_Converter>();
    services.AddSingleton<JsonConverter, IMusicTrackLoopDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IMusicTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IMusicTypeDataGetter_Converter>();
    services.AddSingleton<JsonConverter, INavigationDoorLinkGetter_Converter>();
    services.AddSingleton<JsonConverter, INavigationMapInfoGetter_Converter>();
    services.AddSingleton<JsonConverter, INavigationMeshGetter_Converter>();
    services.AddSingleton<JsonConverter, INavigationMeshDataGetter_Converter>();
    services.AddSingleton<JsonConverter, INavigationMeshInfoMapGetter_Converter>();
    services.AddSingleton<JsonConverter, INavmeshNodeGetter_Converter>();
    services.AddSingleton<JsonConverter, INavmeshSetGetter_Converter>();
    services.AddSingleton<JsonConverter, INavmeshTriangleGetter_Converter>();
    services.AddSingleton<JsonConverter, INoOwnerGetter_Converter>();
    services.AddSingleton<JsonConverter, INpcGetter_Converter>();
    services.AddSingleton<JsonConverter, INpcConfigurationGetter_Converter>();
    services.AddSingleton<JsonConverter, INpcFaceMorphGetter_Converter>();
    services.AddSingleton<JsonConverter, INpcFacePartsGetter_Converter>();
    services.AddSingleton<JsonConverter, INpcInheritSoundGetter_Converter>();
    services.AddSingleton<JsonConverter, INpcLevelGetter_Converter>();
    services.AddSingleton<JsonConverter, INpcOwnerGetter_Converter>();
    services.AddSingleton<JsonConverter, INpcSoundGetter_Converter>();
    services.AddSingleton<JsonConverter, INpcSoundTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, INpcSoundTypesGetter_Converter>();
    services.AddSingleton<JsonConverter, IObjectBoundsGetter_Converter>();
    services.AddSingleton<JsonConverter, IObjectEffectGetter_Converter>();
    services.AddSingleton<JsonConverter, IOutfitGetter_Converter>();
    services.AddSingleton<JsonConverter, IOwnershipGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageAdapterGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageBranchGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageDataBoolGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageDataFloatGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageDataIntGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageDataLocationGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageDataObjectListGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageDataTargetGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageDataTopicGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageEventGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageFlagsOverrideGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageIdlesGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageRootGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageScriptFragmentsGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageTargetAliasGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageTargetObjectIDGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageTargetObjectTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageTargetReferenceGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageTargetSelfGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageTargetSpecificReferenceGetter_Converter>();
    services.AddSingleton<JsonConverter, IPackageTargetUnknownGetter_Converter>();
    services.AddSingleton<JsonConverter, IPartGetter_Converter>();
    services.AddSingleton<JsonConverter, IPatrolGetter_Converter>();
    services.AddSingleton<JsonConverter, IPcLevelMultGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkAbilityEffectGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkAdapterGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkConditionGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkEntryPointAbsoluteValueGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkEntryPointAddActivateChoiceGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkEntryPointAddLeveledItemGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkEntryPointAddRangeToValueGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkEntryPointModifyActorValueGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkEntryPointModifyValueGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkEntryPointSelectSpellGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkEntryPointSelectTextGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkEntryPointSetTextGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkPlacementGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkQuestEffectGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkScriptFlagGetter_Converter>();
    services.AddSingleton<JsonConverter, IPerkScriptFragmentsGetter_Converter>();
    services.AddSingleton<JsonConverter, IPhonemeGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedArrowGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedBarrierGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedBeamGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedConeGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedFlameGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedHazardGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedMissileGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedNpcGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedObjectGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedPrimitiveGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacedTrapGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlacementGetter_Converter>();
    services.AddSingleton<JsonConverter, IPlayerSkillsGetter_Converter>();
    services.AddSingleton<JsonConverter, IPortalGetter_Converter>();
    services.AddSingleton<JsonConverter, IPreferredPathingGetter_Converter>();
    services.AddSingleton<JsonConverter, IProjectileGetter_Converter>();
    services.AddSingleton<JsonConverter, IQuestGetter_Converter>();
    services.AddSingleton<JsonConverter, IQuestAdapterGetter_Converter>();
    services.AddSingleton<JsonConverter, IQuestAliasGetter_Converter>();
    services.AddSingleton<JsonConverter, IQuestFragmentAliasGetter_Converter>();
    services.AddSingleton<JsonConverter, IQuestLogEntryGetter_Converter>();
    services.AddSingleton<JsonConverter, IQuestObjectiveGetter_Converter>();
    services.AddSingleton<JsonConverter, IQuestObjectiveTargetGetter_Converter>();
    services.AddSingleton<JsonConverter, IQuestScriptFragmentGetter_Converter>();
    services.AddSingleton<JsonConverter, IQuestStageGetter_Converter>();
    services.AddSingleton<JsonConverter, IQuestTargetGetter_Converter>();
    services.AddSingleton<JsonConverter, IRaceGetter_Converter>();
    services.AddSingleton<JsonConverter, IRaceMovementTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IRankGetter_Converter>();
    services.AddSingleton<JsonConverter, IRankPlacementGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionAreaGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionDataHeaderGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionGrassGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionGrassesGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionLandGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionMapGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionObjectGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionObjectsGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionSoundGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionSoundsGetter_Converter>();
    services.AddSingleton<JsonConverter, IRegionWeatherGetter_Converter>();
    services.AddSingleton<JsonConverter, IRelationGetter_Converter>();
    services.AddSingleton<JsonConverter, IRelationshipGetter_Converter>();
    services.AddSingleton<JsonConverter, IReverbParametersGetter_Converter>();
    services.AddSingleton<JsonConverter, ISceneGetter_Converter>();
    services.AddSingleton<JsonConverter, ISceneActionGetter_Converter>();
    services.AddSingleton<JsonConverter, ISceneActorGetter_Converter>();
    services.AddSingleton<JsonConverter, ISceneAdapterGetter_Converter>();
    services.AddSingleton<JsonConverter, IScenePhaseGetter_Converter>();
    services.AddSingleton<JsonConverter, IScenePhaseFragmentGetter_Converter>();
    services.AddSingleton<JsonConverter, IScenePhaseUnusedDataGetter_Converter>();
    services.AddSingleton<JsonConverter, ISceneScriptFragmentsGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptBoolListPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptBoolPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptEntryGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptFloatListPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptFloatPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptFragmentGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptFragmentsGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptIntListPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptIntPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptObjectListPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptObjectPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptStringListPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScriptStringPropertyGetter_Converter>();
    services.AddSingleton<JsonConverter, IScrollGetter_Converter>();
    services.AddSingleton<JsonConverter, ISeasonalIngredientProductionGetter_Converter>();
    services.AddSingleton<JsonConverter, IShaderParticleGeometryGetter_Converter>();
    services.AddSingleton<JsonConverter, IShoutGetter_Converter>();
    services.AddSingleton<JsonConverter, IShoutWordGetter_Converter>();
    services.AddSingleton<JsonConverter, ISimpleModelGetter_Converter>();
    services.AddSingleton<JsonConverter, ISkillBoostGetter_Converter>();
    services.AddSingleton<JsonConverter, ISkyrimModGetter_Converter>();
    services.AddSingleton<JsonConverter, ISkyrimModHeaderGetter_Converter>();
    services.AddSingleton<JsonConverter, ISoulGemGetter_Converter>();
    services.AddSingleton<JsonConverter, ISoundCategoryGetter_Converter>();
    services.AddSingleton<JsonConverter, ISoundDescriptorGetter_Converter>();
    services.AddSingleton<JsonConverter, ISoundLoopAndRumbleGetter_Converter>();
    services.AddSingleton<JsonConverter, ISoundMarkerGetter_Converter>();
    services.AddSingleton<JsonConverter, ISoundOutputAttenuationGetter_Converter>();
    services.AddSingleton<JsonConverter, ISoundOutputChannelGetter_Converter>();
    services.AddSingleton<JsonConverter, ISoundOutputChannelsGetter_Converter>();
    services.AddSingleton<JsonConverter, ISoundOutputDataGetter_Converter>();
    services.AddSingleton<JsonConverter, ISoundOutputModelGetter_Converter>();
    services.AddSingleton<JsonConverter, ISpeedOverridesGetter_Converter>();
    services.AddSingleton<JsonConverter, ISpellGetter_Converter>();
    services.AddSingleton<JsonConverter, IStaticGetter_Converter>();
    services.AddSingleton<JsonConverter, IStoryManagerBranchNodeGetter_Converter>();
    services.AddSingleton<JsonConverter, IStoryManagerEventNodeGetter_Converter>();
    services.AddSingleton<JsonConverter, IStoryManagerQuestGetter_Converter>();
    services.AddSingleton<JsonConverter, IStoryManagerQuestNodeGetter_Converter>();
    services.AddSingleton<JsonConverter, ITalkingActivatorGetter_Converter>();
    services.AddSingleton<JsonConverter, ITeleportDestinationGetter_Converter>();
    services.AddSingleton<JsonConverter, ITextureSetGetter_Converter>();
    services.AddSingleton<JsonConverter, ITintAssetsGetter_Converter>();
    services.AddSingleton<JsonConverter, ITintLayerGetter_Converter>();
    services.AddSingleton<JsonConverter, ITintPresetGetter_Converter>();
    services.AddSingleton<JsonConverter, ITopicReferenceGetter_Converter>();
    services.AddSingleton<JsonConverter, ITopicReferenceSubtypeGetter_Converter>();
    services.AddSingleton<JsonConverter, ITreeGetter_Converter>();
    services.AddSingleton<JsonConverter, IVendorValuesGetter_Converter>();
    services.AddSingleton<JsonConverter, IVirtualMachineAdapterGetter_Converter>();
    services.AddSingleton<JsonConverter, IVisualEffectGetter_Converter>();
    services.AddSingleton<JsonConverter, IVoiceTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IVolumetricLightingGetter_Converter>();
    services.AddSingleton<JsonConverter, IWaterGetter_Converter>();
    services.AddSingleton<JsonConverter, IWaterReflectionGetter_Converter>();
    services.AddSingleton<JsonConverter, IWaterVelocityGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeaponGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeaponBasicStatsGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeaponDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeatherGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeatherAlphaGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeatherAmbientColorSetGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeatherColorGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeatherImageSpacesGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeatherSoundGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeatherTypeGetter_Converter>();
    services.AddSingleton<JsonConverter, IWeatherVolumetricLightingGetter_Converter>();
    services.AddSingleton<JsonConverter, IWordOfPowerGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorkbenchDataGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceBlockGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceGridReferenceGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceLandDefaultsGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceMapGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceMapOffsetGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceMaxHeightGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceNavmeshParentGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceObjectBoundsGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceParentGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceReferenceGetter_Converter>();
    services.AddSingleton<JsonConverter, IWorldspaceSubBlockGetter_Converter>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IKeywordGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IArmorAddonGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IRaceGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<ICameraPathGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<ICameraShotGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IRegionGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<ICollisionLayerGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IDialogGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IDialogBranchGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IEquipTypeGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IFootstepGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<ISkyrimMajorRecordGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IColorRecordGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<ITextureSetGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<INpcGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IHeadPartGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IIdleRelationGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IIdleAnimationGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<ILandscapeTextureGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IGrassGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IPlacedGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IPlacedSimpleGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IMagicEffectGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IMusicTrackGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<INavigationMeshGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<ISpellRecordGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IPackageGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IOutfitTargetGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<ILocationReferenceTypeGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IPlacedObjectGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IGlobalGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IFactionGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<ISpellGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IEyesGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IHairGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkGetter_Converter<IStaticGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ISoundDescriptorGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IReverbParametersGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IRegionGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IKeywordGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IWaterGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IActorValueInformationGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IMaterialTypeGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IImpactDataSetGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IEquipTypeGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IEffectRecordGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IRaceGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IArmorGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IArtObjectGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IFootstepSetGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IStaticGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IImageSpaceAdapterGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IAcousticSpaceGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IEncounterZoneGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IImageSpaceGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ILocationGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ILockListGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IMusicTypeGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IConstructibleGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IDialogTopicGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IIdleAnimationGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ISoundOutputModelGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IDialogResponsesGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<INpcGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ISkyrimMajorRecordGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IDialogBranchGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IQuestGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IMagicEffectGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IPlacedObjectGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IOutfitGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IFormListGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IHarvestTargetGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ISpellGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ITextureSetGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IColorRecordGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IHeadPartGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IHazardGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ISoundGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IGlobalGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IFactionGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IPlacedSimpleGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ILocationReferenceTypeGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ICombatStyleGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ILeveledItemGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<INpcSpawnGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IVoiceTypeGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IOwnerGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IPerkGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IEmittanceGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ILocationRecordGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IPlacedNpcGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IPlacedThingGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ILightGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IMessageGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ICellGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ILinkedReferenceGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IPlacedGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IAliasVoiceTypeGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IMovementTypeGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IBodyPartDataGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IWorldspaceGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ISoulGemGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ISoundCategoryGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IAStoryManagerNodeGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ISoundMarkerGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IWeaponGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IShaderParticleGeometryGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ILensFlareGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<IClimateGetter>>();
    services.AddSingleton<JsonConverter, IFormLinkNullableGetter_Converter<ILightingTemplateGetter>>();
    return services;
  }
}
